<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>node相关知识点</title>
    <link href="/2021/05/11/node%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2021/05/11/node%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<ul><li>引用模块的目录分析<ol><li>在当前目录下查找package.json(CommonJS包规范定义的包描述文件)，通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件缺少扩展名，将会进入扩展名分析的步骤。 　　</li><li>而如果main属性制定的文件名错误，或者压根没有package.json文件，Node会将index当做默认文件名，然后依次查找index.js、index.node、index.json. 　　</li><li>如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败异常。</li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟列表的简单实现</title>
    <link href="/2021/04/26/%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/04/26/%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>ref:[<a href="https://mp.weixin.qq.com/s/8uttkBw-dwYXsybKePQ3nA]">https://mp.weixin.qq.com/s/8uttkBw-dwYXsybKePQ3nA]</a></p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>虚拟列表<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">      <span class="hljs-selector-tag">html</span> &#123;</span><span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span>      &#125;<span class="css">      <span class="hljs-selector-tag">body</span> &#123;</span><span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><span class="css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span>      &#125;      #app &#123;<span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span>      &#125;      .visible-area&#123;<span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span>      &#125;      .infinite-list-container &#123;<span class="css">        <span class="hljs-attribute">overflow</span>: auto;</span><span class="css">        <span class="hljs-attribute">position</span>: relative;</span><span class="css">        -webkit-<span class="hljs-attribute">overflow</span>-scrolling: touch;</span><span class="css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid black;</span>      &#125;      .infinite-list-phantom &#123;<span class="css">        <span class="hljs-attribute">position</span>: absolute;</span><span class="css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><span class="css">        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><span class="css">        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><span class="css">        <span class="hljs-attribute">z-index</span>: -<span class="hljs-number">1</span>;</span>      &#125;      .infinite-list &#123;<span class="css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><span class="css">        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><span class="css">        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><span class="css">        <span class="hljs-attribute">position</span>: absolute;</span>      &#125;      .infinite-list-item &#123;<span class="css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span>;</span><span class="css">        <span class="hljs-attribute">color</span>: <span class="hljs-number">#555</span>;</span><span class="css">        <span class="hljs-comment">/* box-sizing: border-box; */</span></span><span class="css">        <span class="hljs-attribute">border</span>:<span class="hljs-number">6px</span> solid gray;</span><span class="css">        <span class="hljs-comment">/* height:200px; */</span></span>      &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;visible-area&quot;</span>&gt;</span>        我是可视区域              <span class="hljs-tag">&lt;<span class="hljs-name">virtual-list</span> <span class="hljs-attr">:list-data</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">:estimated-item-size</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">:buffer-scale</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">virtual-list</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">virtual-list</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/Faker/3.1.0/faker.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="javascript">      <span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.esm.browser.js&quot;</span>;</span><span class="javascript">      Vue.component(<span class="hljs-string">&quot;virtual-list&quot;</span>, &#123;</span>        template: `<span class="javascript">        &lt;div ref=<span class="hljs-string">&quot;list&quot;</span> :style=<span class="hljs-string">&quot;&#123;height&#125;&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;infinite-list-container&quot;</span> @scroll=<span class="hljs-string">&quot;scrollEvent($event)&quot;</span>&gt;</span><span class="handlebars"><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;phantom&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;infinite-list-phantom&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><span class="javascript">          &lt;div ref=<span class="hljs-string">&quot;content&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;infinite-list&quot;</span>&gt;</span><span class="javascript">            &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;infinite-list-item&quot;</span> ref=<span class="hljs-string">&quot;items&quot;</span> :id=<span class="hljs-string">&quot;item.id&quot;</span> :key=<span class="hljs-string">&quot;item.id&quot;</span> v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;item in visibleData&quot;</span>&gt;</span><span class="handlebars"><span class="xml">              <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.id</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.value</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><span class="handlebars"><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span>        `,        props: &#123;<span class="javascript">          <span class="hljs-comment">//列表数据</span></span>          listData: &#123;<span class="javascript">            type: <span class="hljs-built_in">Array</span>,</span><span class="javascript">            <span class="hljs-keyword">default</span>: <span class="hljs-function">() =&gt;</span> [],</span>          &#125;,<span class="javascript">          <span class="hljs-comment">//预估高度</span></span>          estimatedItemSize: &#123;<span class="javascript">            type: <span class="hljs-built_in">Number</span>,</span><span class="javascript">            required: <span class="hljs-literal">true</span>,</span>          &#125;,<span class="javascript">          <span class="hljs-comment">//缓冲区比例</span></span>          bufferScale: &#123;<span class="javascript">            type: <span class="hljs-built_in">Number</span>,</span><span class="javascript">            <span class="hljs-keyword">default</span>: <span class="hljs-number">1</span>,</span>          &#125;,<span class="javascript">          <span class="hljs-comment">//容器高度 100px or 50vh</span></span>          height: &#123;<span class="javascript">            type: <span class="hljs-built_in">String</span>,</span><span class="javascript">            <span class="hljs-keyword">default</span>: <span class="hljs-string">&quot;100%&quot;</span>,</span>          &#125;,        &#125;,        computed: &#123;<span class="javascript">          <span class="hljs-comment">// 可视区域内能显示几条数据</span></span><span class="javascript">          <span class="hljs-function"><span class="hljs-title">visibleCount</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">this</span>.screenHeight / <span class="hljs-built_in">this</span>.estimatedItemSize);</span>          &#125;,<span class="javascript">          <span class="hljs-comment">// 可视区域上方数据条数</span></span><span class="javascript">          <span class="hljs-comment">// Math.min取缓冲区值</span></span><span class="javascript">          <span class="hljs-function"><span class="hljs-title">aboveCount</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">this</span>.start, <span class="hljs-built_in">this</span>.bufferScale * <span class="hljs-built_in">this</span>.visibleCount);</span>          &#125;,<span class="javascript">          <span class="hljs-comment">// 可视区域下方数据条数</span></span><span class="javascript">          <span class="hljs-function"><span class="hljs-title">belowCount</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(</span><span class="javascript">              <span class="hljs-built_in">this</span>.listData.length - <span class="hljs-built_in">this</span>.end,</span><span class="javascript">              <span class="hljs-built_in">this</span>.bufferScale * <span class="hljs-built_in">this</span>.visibleCount</span>            );          &#125;,<span class="javascript">          <span class="hljs-function"><span class="hljs-title">visibleData</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-comment">// 需要渲染的数据 = 显示的数据加上上下缓冲区</span></span><span class="javascript">            <span class="hljs-keyword">let</span> start = <span class="hljs-built_in">this</span>.start - <span class="hljs-built_in">this</span>.aboveCount;</span><span class="javascript">            <span class="hljs-keyword">let</span> end = <span class="hljs-built_in">this</span>.end + <span class="hljs-built_in">this</span>.belowCount;</span><span class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.listData.slice(start, end);</span>          &#125;,        &#125;,<span class="javascript">        <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">          <span class="hljs-built_in">this</span>.initPositions();</span>        &#125;,<span class="javascript">        <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">          <span class="hljs-built_in">this</span>.screenHeight = <span class="hljs-built_in">this</span>.$el.clientHeight;</span><span class="javascript">          <span class="hljs-built_in">this</span>.start = <span class="hljs-number">0</span>;</span><span class="javascript">          <span class="hljs-built_in">this</span>.end = <span class="hljs-built_in">this</span>.start + <span class="hljs-built_in">this</span>.visibleCount;</span>        &#125;,<span class="javascript">        <span class="hljs-function"><span class="hljs-title">updated</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">          <span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.$refs.items || !<span class="hljs-built_in">this</span>.$refs.items.length) &#123;</span><span class="javascript">              <span class="hljs-keyword">return</span>;</span>            &#125;<span class="javascript">            <span class="hljs-comment">//获取真实元素大小，修改对应的尺寸缓存</span></span><span class="javascript">            <span class="hljs-built_in">this</span>.updateItemsSize();</span><span class="javascript">            <span class="hljs-comment">//更新列表总高度</span></span><span class="javascript">            <span class="hljs-keyword">let</span> height = <span class="hljs-built_in">this</span>.positions[<span class="hljs-built_in">this</span>.positions.length - <span class="hljs-number">1</span>].bottom;</span><span class="javascript">            <span class="hljs-built_in">this</span>.$refs.phantom.style.height = height + <span class="hljs-string">&quot;px&quot;</span>;</span><span class="javascript">            <span class="hljs-comment">//更新真实偏移量</span></span><span class="javascript">            <span class="hljs-built_in">this</span>.setStartOffset();</span>          &#125;);        &#125;,<span class="javascript">        <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">          <span class="hljs-keyword">return</span> &#123;</span><span class="javascript">            <span class="hljs-comment">//可视区域高度</span></span>            screenHeight: 0,<span class="javascript">            <span class="hljs-comment">//起始索引</span></span>            start: 0,<span class="javascript">            <span class="hljs-comment">//结束索引</span></span>            end: 0,          &#125;;        &#125;,        methods: &#123;<span class="javascript">          <span class="hljs-function"><span class="hljs-title">initPositions</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-built_in">this</span>.positions = <span class="hljs-built_in">this</span>.listData.map(<span class="hljs-function">(<span class="hljs-params">d, index</span>) =&gt;</span> (&#123;</span>              index,<span class="javascript">              height: <span class="hljs-built_in">this</span>.estimatedItemSize,</span><span class="javascript">              top: index * <span class="hljs-built_in">this</span>.estimatedItemSize,</span><span class="javascript">              bottom: (index + <span class="hljs-number">1</span>) * <span class="hljs-built_in">this</span>.estimatedItemSize,</span>            &#125;));          &#125;,<span class="javascript">          <span class="hljs-comment">//获取列表起始索引</span></span><span class="javascript">          <span class="hljs-function"><span class="hljs-title">getStartIndex</span>(<span class="hljs-params">scrollTop = <span class="hljs-number">0</span></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-comment">//二分法查找</span></span><span class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.binarySearch(<span class="hljs-built_in">this</span>.positions, scrollTop);</span>          &#125;,<span class="javascript">          <span class="hljs-function"><span class="hljs-title">binarySearch</span>(<span class="hljs-params">list, value</span>)</span> &#123;</span><span class="javascript">            <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;</span><span class="javascript">            <span class="hljs-keyword">let</span> end = list.length - <span class="hljs-number">1</span>;</span><span class="javascript">            <span class="hljs-keyword">let</span> tempIndex = <span class="hljs-literal">null</span>;</span><span class="javascript">            <span class="hljs-keyword">while</span> (start &lt;= end) &#123;</span><span class="javascript">              <span class="hljs-keyword">let</span> midIndex = <span class="hljs-built_in">parseInt</span>((start + end) / <span class="hljs-number">2</span>);</span><span class="javascript">              <span class="hljs-keyword">let</span> midValue = list[midIndex].bottom;</span>              if (midValue === value) &#123;<span class="javascript">                <span class="hljs-keyword">return</span> midIndex + <span class="hljs-number">1</span>;</span><span class="javascript">              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (midValue &lt; value) &#123;</span>                start = midIndex + 1;<span class="javascript">              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (midValue &gt; value) &#123;</span><span class="javascript">                <span class="hljs-keyword">if</span> (tempIndex === <span class="hljs-literal">null</span> || tempIndex &gt; midIndex) &#123;</span>                  tempIndex = midIndex;                &#125;                end = end - 1;              &#125;            &#125;<span class="javascript">            <span class="hljs-keyword">return</span> tempIndex;</span>          &#125;,<span class="javascript">          <span class="hljs-comment">//更新列表项的当前尺寸</span></span><span class="javascript">          <span class="hljs-function"><span class="hljs-title">updateItemsSize</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-keyword">let</span> nodes = <span class="hljs-built_in">this</span>.$refs.items;</span><span class="javascript">            nodes.forEach(<span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;</span><span class="javascript">              <span class="hljs-keyword">let</span> rect = node.getBoundingClientRect();</span><span class="javascript">              <span class="hljs-keyword">let</span> height = rect.height;</span><span class="javascript">              <span class="hljs-keyword">let</span> index = +node.id.slice(<span class="hljs-number">1</span>);</span><span class="javascript">              <span class="hljs-keyword">let</span> oldHeight = <span class="hljs-built_in">this</span>.positions[index].height;</span><span class="javascript">              <span class="hljs-keyword">let</span> dValue = oldHeight - height;</span><span class="javascript">              <span class="hljs-comment">//存在差值</span></span>              if (dValue) &#123;<span class="javascript">                <span class="hljs-built_in">this</span>.positions[index].bottom =</span><span class="javascript">                  <span class="hljs-built_in">this</span>.positions[index].bottom - dValue;</span><span class="javascript">                <span class="hljs-built_in">this</span>.positions[index].height = height;</span><span class="javascript">                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = index + <span class="hljs-number">1</span>; k &lt; <span class="hljs-built_in">this</span>.positions.length; k++) &#123;</span><span class="javascript">                  <span class="hljs-built_in">this</span>.positions[k].top = <span class="hljs-built_in">this</span>.positions[k - <span class="hljs-number">1</span>].bottom;</span><span class="javascript">                  <span class="hljs-built_in">this</span>.positions[k].bottom = <span class="hljs-built_in">this</span>.positions[k].bottom - dValue;</span>                &#125;              &#125;            &#125;);          &#125;,<span class="javascript">          <span class="hljs-comment">//计算偏移量并translate</span></span><span class="javascript">          <span class="hljs-function"><span class="hljs-title">setStartOffset</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-keyword">let</span> startOffset;</span><span class="javascript">            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.start &gt;= <span class="hljs-number">1</span>) &#123;</span><span class="javascript">              <span class="hljs-keyword">let</span> size =</span><span class="javascript">                <span class="hljs-built_in">this</span>.positions[<span class="hljs-built_in">this</span>.start].top -</span><span class="javascript">                (<span class="hljs-built_in">this</span>.positions[<span class="hljs-built_in">this</span>.start - <span class="hljs-built_in">this</span>.aboveCount]</span><span class="javascript">                  ? <span class="hljs-built_in">this</span>.positions[<span class="hljs-built_in">this</span>.start - <span class="hljs-built_in">this</span>.aboveCount].top</span>                  : 0);<span class="javascript">              startOffset = <span class="hljs-built_in">this</span>.positions[<span class="hljs-built_in">this</span>.start - <span class="hljs-number">1</span>].bottom - size;</span><span class="javascript">            &#125; <span class="hljs-keyword">else</span> &#123;</span>              startOffset = 0;            &#125;<span class="javascript">            <span class="hljs-built_in">this</span>.$refs.content.style.transform = <span class="hljs-string">`translate3d(0,<span class="hljs-subst">$&#123;startOffset&#125;</span>px,0)`</span>;</span>          &#125;,<span class="javascript">          <span class="hljs-comment">//滚动事件</span></span><span class="javascript">          <span class="hljs-function"><span class="hljs-title">scrollEvent</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-comment">//当前滚动位置</span></span><span class="javascript">            <span class="hljs-keyword">let</span> scrollTop = <span class="hljs-built_in">this</span>.$refs.list.scrollTop;</span><span class="javascript">            <span class="hljs-comment">// let startBottom = this.positions[this.start - ]</span></span><span class="javascript">            <span class="hljs-comment">//此时的开始索引</span></span><span class="javascript">            <span class="hljs-built_in">this</span>.start = <span class="hljs-built_in">this</span>.getStartIndex(scrollTop);</span><span class="javascript">            <span class="hljs-comment">//此时的结束索引</span></span><span class="javascript">            <span class="hljs-built_in">this</span>.end = <span class="hljs-built_in">this</span>.start + <span class="hljs-built_in">this</span>.visibleCount;</span><span class="javascript">            <span class="hljs-comment">//此时的偏移量</span></span><span class="javascript">            <span class="hljs-built_in">this</span>.setStartOffset();</span>          &#125;,        &#125;,      &#125;);<span class="javascript">      <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="javascript">        el: <span class="hljs-string">&quot;#app&quot;</span>,</span>        data: &#123;          dataLength: 100000,          list: [],        &#125;,<span class="javascript">        <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>; id &lt; <span class="hljs-built_in">this</span>.dataLength; ++id) &#123;</span><span class="javascript">            <span class="hljs-built_in">this</span>.list.push(&#123;</span>              id,              value: faker.lorem.sentences(),            &#125;);          &#125;        &#125;,      &#125;);    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端涉及到的数据存储</title>
    <link href="/2021/04/20/%E5%89%8D%E7%AB%AF%E5%AD%98%E5%82%A8/"/>
    <url>/2021/04/20/%E5%89%8D%E7%AB%AF%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="LocalStorage-h5-web-storage"><a href="#LocalStorage-h5-web-storage" class="headerlink" title="LocalStorage[h5 web storage]"></a><code>LocalStorage</code>[h5 web storage]</h3><ul><li><p>不会过期</p></li><li><p>数据大小5MB</p></li><li><p>浏览器中共享</p></li><li><p>同源共享同一份<code>localStorage</code></p></li><li><p>只能为<code>string</code>类型,注意需要<code>JSON</code>转换</p></li></ul><h3 id="SessionStorage-h5-web-storage"><a href="#SessionStorage-h5-web-storage" class="headerlink" title="SessionStorage[h5 web storage]"></a><code>SessionStorage</code>[h5 web storage]</h3><ul><li><p>窗口/标签页关闭时清理</p></li><li><p>不跨窗口共享</p></li><li><p>数据大小5MB</p></li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a><code>Cookie</code></h3><ul><li><p>手动设置过期时间，否则浏览器关闭失效</p></li><li><p>数据大小 4KB</p></li><li><p>参与每次http请求</p></li><li><p>有路径概念，可以限制不同路径下的 cookie 互相是访问不到的</p></li><li><p>某些浏览器对单网站cookie数目有限制(不超过20个)</p></li><li><p>cookie字段</p><ul><li><p><code>name</code></p></li><li><p><code>value</code></p></li><li><p><code>domain</code>　        可以访问此cookie的域，默认为该请求源的域</p></li><li><p><code>path</code>　        　 可以访问此cookie的页面路径</p></li><li><p><code>expires/Max-Age</code> 过期时间，如没设置则与会话时效相同（关闭浏览器窗口失效）</p></li><li><p><code>httponly</code>　      只能传输不能查看</p></li><li><p><code>secure</code>          只使用HTTPS传输</p></li><li><p><code>sameSite = </code></p><ul><li><code>Strict</code>  跨域时不允许带上任何cookie</li><li><code>Lax</code>  只有三种情况可以带上cookie[a连接,get提交的表单,预加载link]<blockquote><p>现代浏览器会将没有声明 SameSite 值的 cookie 默认设置为Lax</p></blockquote></li><li><code>None</code> 需配合<code>secure</code>使用用 <code>Set-Cookie: widget_session=xxxxx; SameSite=None; Secure</code></li></ul></li></ul></li></ul><h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a><code>IndexedDB</code></h3><ul><li><p>除非被清理否则一直存在</p></li><li><p>数据大小无限制</p></li><li><p>IndexedDB是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB  允许储存大量数据，提供查找接口，还能建立索引。</p></li></ul><h2 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a><code>manifest</code></h2><p>web应用离线缓存</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue拾遗</title>
    <link href="/2021/04/20/vue%E6%8B%BE%E9%81%97/"/>
    <url>/2021/04/20/vue%E6%8B%BE%E9%81%97/</url>
    
    <content type="html"><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><div class="hljs code-wrapper"><pre><code class="hljs javascript">initLifecycle(vm);<span class="hljs-comment">//初始化生命周期,处理parent,children,$refs,root</span>initEvents(vm);<span class="hljs-comment">//初始化事件，父组件监听的</span>initRender(vm);<span class="hljs-comment">//绑定createElement方法，绑定$attrs,$listeners</span>callHook(vm, <span class="hljs-string">&#x27;⭐️beforeCreate&#x27;</span>);initInjections(vm); <span class="hljs-comment">// resolve injections before data/props</span>initState(vm);<span class="hljs-comment">//initState</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initState</span> (<span class="hljs-params">vm</span>) </span>&#123;      initProps(vm, opts.props);      initMethods(vm, opts.methods);      initData(vm);      initComputed(vm, opts.computed);      initWatch(vm, opts.watch);    &#125;<span class="hljs-comment">//</span>initProvide(vm); <span class="hljs-comment">// resolve provide after data/props</span>callHook(vm, <span class="hljs-string">&#x27;⭐️created&#x27;</span>);vm.$mount(vm.$options.el);<span class="hljs-comment">//mount</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountComponent</span> (<span class="hljs-params"></span>) </span>&#123;      callHook(vm, <span class="hljs-string">&#x27;⭐️beforeMount&#x27;</span>);      <span class="hljs-keyword">let</span> updateComponent;        updateComponent = <span class="hljs-function">() =&gt;</span> &#123;          vm._update(vm._render(), hydrating);        &#125;;        <span class="hljs-keyword">new</span> Watcher(vm, updateComponent, noop, &#123;          before () &#123;            <span class="hljs-keyword">if</span> (vm._isMounted) &#123;              callHook(vm, <span class="hljs-string">&#x27;⭐️beforeUpdate&#x27;</span>)            &#125;          &#125;          <span class="hljs-comment">//渲染函数update</span>          <span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params"></span>)</span>&#123;          ...          callHook(vm, <span class="hljs-string">&#x27;⭐️updated&#x27;</span>)          ...          &#125;        &#125;, <span class="hljs-literal">true</span>)        callHook(vm, <span class="hljs-string">&#x27;⭐️mounted&#x27;</span>);      <span class="hljs-keyword">return</span> vm    &#125;<span class="hljs-comment">//</span>Vue.prototype.$destroy = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    callHook(vm, <span class="hljs-string">&#x27;⭐️beforeDestroy&#x27;</span>);    <span class="hljs-comment">// remove self from parent</span>    <span class="hljs-keyword">const</span> parent = vm.$parent;    remove(parent.$children, vm);    <span class="hljs-comment">// teardown watchers</span>    vm._watcher.teardown();    vm._watchers[i].teardown();    <span class="hljs-comment">// remove reference from data ob</span>    <span class="hljs-comment">// frozen object may not have observer.</span>    vm._data.__ob__.vmCount--;    <span class="hljs-comment">// invoke destroy hooks on current rendered tree</span>    vm.__patch__(vm._vnode, <span class="hljs-literal">null</span>);    <span class="hljs-comment">// fire destroyed hook</span>    callHook(vm, <span class="hljs-string">&#x27;⭐️destroyed&#x27;</span>);    <span class="hljs-comment">// turn off all instance listeners.</span>    vm.$off();    <span class="hljs-comment">// remove __vue__ reference</span>    <span class="hljs-keyword">if</span> (vm.$el) &#123;      vm.$el.__vue__ = <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-comment">// release circular reference (#6759)</span>    <span class="hljs-keyword">if</span> (vm.$vnode) &#123;      vm.$vnode.parent = <span class="hljs-literal">null</span>;    &#125;  &#125;;&#125;<span class="hljs-comment">// keep-alive</span>⭐️callHook(vm, <span class="hljs-string">&#x27;⭐️activated&#x27;</span>);  ⭐️ callHook(vm, <span class="hljs-string">&#x27;⭐️deactivated&#x27;</span>);</code></pre></div><h1 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h1><h3 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a><code>defineReactive</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">defineReactive (  ...) &#123;  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> Dep()  ...  <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;    enumerable: <span class="hljs-literal">true</span>,    configurable: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// render函数接触data触发getter</span>    get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveGetter</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">if</span> (Dep.target) &#123;        <span class="hljs-comment">// 此时Dep.target已经是渲染watcher</span>        <span class="hljs-comment">// 执行depend</span>⭐️        dep.depend()        <span class="hljs-keyword">if</span> (childOb) &#123;          ...        &#125;      &#125;      <span class="hljs-keyword">return</span> value    &#125;,    set: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveSetter</span> (<span class="hljs-params">newVal</span>) </span>&#123;      <span class="hljs-keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;        <span class="hljs-keyword">return</span>      &#125;      val = newVal🔥    dep.notify()    &#125;  &#125;)&#125;</code></pre></div><h3 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent "></a><code>mountComponent </code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">mountComponent (...): Component &#123;  callHook(vm, <span class="hljs-string">&#x27;beforeMount&#x27;</span>)  <span class="hljs-keyword">let</span> updateComponent;⭐️ <span class="hljs-comment">// render函数生成虚拟DOM，期间会访问数据</span>  updateComponent = <span class="hljs-function">() =&gt;</span> &#123;    vm._update(vm._render(), hydrating);  &#125;;⭐️ <span class="hljs-comment">//组件`mount`过程中会实例化一个渲染`watcher`，传入updateComponent函数</span>  vm._watcher = <span class="hljs-keyword">new</span> Watcher(vm, updateComponent, noop, &#123;    before () &#123;      <span class="hljs-keyword">if</span> (vm._isMounted) &#123;        callHook(vm, <span class="hljs-string">&#x27;beforeUpdate&#x27;</span>)      &#125;    &#125;  &#125;, <span class="hljs-literal">true</span> <span class="hljs-comment">/* isRenderWatcher */</span>)  <span class="hljs-keyword">if</span> (vm.$vnode == <span class="hljs-literal">null</span>) &#123;    vm._isMounted = <span class="hljs-literal">true</span>    callHook(vm, <span class="hljs-string">&#x27;mounted&#x27;</span>)  &#125;&#125;</code></pre></div><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a><code>Watcher</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watcher</span> </span>&#123;  <span class="hljs-title">constructor</span> (<span class="hljs-params"></span><span class="hljs-params">    vm,</span><span class="hljs-params">    expOrFn,</span><span class="hljs-params">    cb,</span><span class="hljs-params">    options</span><span class="hljs-params">  </span>) &#123;    <span class="hljs-built_in">this</span>.vm = vm;    vm._watchers.push(<span class="hljs-built_in">this</span>);    <span class="hljs-built_in">this</span>.deps = [];    <span class="hljs-built_in">this</span>.newDeps = [];    <span class="hljs-built_in">this</span>.depIds = <span class="hljs-keyword">new</span> _Set();    <span class="hljs-built_in">this</span>.newDepIds = <span class="hljs-keyword">new</span> _Set();    <span class="hljs-comment">// parse expression for getter</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> expOrFn === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;⭐️ <span class="hljs-comment">// getter此时为传入的updateComponent函数</span>      <span class="hljs-built_in">this</span>.getter = expOrFn;    &#125;  &#125;  get () &#123;⭐️  <span class="hljs-comment">//首先触发watcher中的get（）</span>        <span class="hljs-comment">// pushTarget方法    </span>    pushTarget(<span class="hljs-built_in">this</span>)    <span class="hljs-keyword">let</span> value⭐️  <span class="hljs-comment">// 调用getter</span>    value = <span class="hljs-built_in">this</span>.getter.call(vm, vm)    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.deep) &#123;      traverse(value)    &#125;⭐️ <span class="hljs-comment">// 当前组件收集完成后清理</span>    popTarget()    <span class="hljs-built_in">this</span>.cleanupDeps()        <span class="hljs-keyword">return</span> value  &#125;  addDep (dep: Dep) &#123;    <span class="hljs-keyword">const</span> id = dep.id    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.newDepIds.has(id)) &#123;      <span class="hljs-built_in">this</span>.newDepIds.add(id)      <span class="hljs-built_in">this</span>.newDeps.push(dep)      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.depIds.has(id)) &#123;⭐️ <span class="hljs-comment">//执行addSub</span>        dep.addSub(<span class="hljs-built_in">this</span>)      &#125;    &#125;  &#125;⭐️<span class="hljs-comment">// 对比新旧订阅列表，清空依赖</span>  cleanupDeps () &#123;    <span class="hljs-keyword">let</span> i = <span class="hljs-built_in">this</span>.deps.length    <span class="hljs-keyword">while</span> (i--) &#123;      <span class="hljs-keyword">const</span> dep = <span class="hljs-built_in">this</span>.deps[i]      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.newDepIds.has(dep.id)) &#123;        <span class="hljs-comment">//清空依赖</span>        dep.removeSub(<span class="hljs-built_in">this</span>)      &#125;    &#125;    <span class="hljs-comment">// 每次更新页面，render依赖收集的时候</span>    <span class="hljs-comment">// 将不展示于页面上的数据的依赖移除</span>    <span class="hljs-comment">// 考虑v-if</span>    [<span class="hljs-built_in">this</span>.depIds,<span class="hljs-built_in">this</span>.newDepIds]=[<span class="hljs-built_in">this</span>.newDepIds,<span class="hljs-built_in">this</span>.depIds]    <span class="hljs-built_in">this</span>.newDepIds.clear()    [<span class="hljs-built_in">this</span>.deps,<span class="hljs-built_in">this</span>.newDeps] = [<span class="hljs-built_in">this</span>.newDeps,<span class="hljs-built_in">this</span>.deps]    <span class="hljs-built_in">this</span>.newDeps.length = <span class="hljs-number">0</span>  &#125;🔥  update () &#123;    <span class="hljs-comment">/* istanbul ignore else */</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.lazy) &#123;      <span class="hljs-built_in">this</span>.dirty = <span class="hljs-literal">true</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.sync) &#123;      <span class="hljs-built_in">this</span>.run();    &#125; <span class="hljs-keyword">else</span> &#123;🔥    queueWatcher(<span class="hljs-built_in">this</span>);    &#125;  &#125;  <span class="hljs-comment">// ...</span>&#125;</code></pre></div><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a><code>Dep</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dep</span> </span>&#123;  <span class="hljs-keyword">static</span> target: ?Watcher;  id: number;  subs: <span class="hljs-built_in">Array</span>&lt;Watcher&gt;;    <span class="hljs-title">constructor</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-built_in">this</span>.id = uid++    <span class="hljs-built_in">this</span>.subs = []  &#125; <span class="hljs-comment">// 将watcher加入subs</span>  addSub (sub: Watcher) &#123;    <span class="hljs-built_in">this</span>.subs.push(sub)  &#125;⭐️  removeSub (sub: Watcher) &#123;    remove(<span class="hljs-built_in">this</span>.subs, sub)  &#125;⭐️   depend () &#123;    <span class="hljs-keyword">if</span> (Dep.target) &#123; <span class="hljs-comment">// 执行当前watcher中的addDep函数</span>      Dep.target.addDep(<span class="hljs-built_in">this</span>)    &#125;  &#125;🔥  notify () &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = subs.length; i &lt; l; i++) &#123;      subs[i].update()    &#125;  &#125;&#125;⭐️ <span class="hljs-comment">// target置空</span>Dep.target = <span class="hljs-literal">null</span><span class="hljs-keyword">const</span> targetStack = []⭐️ <span class="hljs-comment">// 将Dep.target 指向当前watcher</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushTarget</span> (<span class="hljs-params">_target: ?Watcher</span>) </span>&#123;  <span class="hljs-keyword">if</span> (Dep.target) targetStack.push(Dep.target)  Dep.target = _target&#125;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">popTarget</span> (<span class="hljs-params"></span>) </span>&#123;  Dep.target = targetStack.pop()&#125;</code></pre></div><h2 id="⭐️收集依赖⭐️"><a href="#⭐️收集依赖⭐️" class="headerlink" title="⭐️收集依赖⭐️"></a>⭐️收集依赖⭐️</h2><ol><li>initState阶段为数据添加getter,setter绑定,并为每个数据生成一个新Dep实例</li><li>mountComponent执行过程中，组件实例化一个渲染watcher，并作为Dep.target</li><li>render函数触发数据的getter，将当前渲染watcher添加到该数据持有的Dep实例subs数组中<blockquote><p>可以理解成data数据的subs数组中每个watcher即代表一个受该数据响应式影响的组件实例</p></blockquote></li></ol><h2 id="🔥派发更新🔥"><a href="#🔥派发更新🔥" class="headerlink" title="🔥派发更新🔥"></a>🔥派发更新🔥</h2><ol><li>修改数据触发setter，执行dep.notify()</li><li>遍历当前数据subs中的watcher，执行其update()</li><li>vue不会每次数据更新就立刻去更新视图，而是用队列管理这些回调任务</li><li>队列会对watcher判断是否重复，并且进行排序【先父后子】【自定义watcher&gt;渲染watcher】</li><li>在下一个tick执行这个队列</li></ol><h1 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a><code>nextTick</code></h1><ul><li>执行主线程的过程就是一个tick</li><li>执行完当前tick包括所有同步任务，异步任务（宏任务，微任务）</li><li>nextTick就是把回调加入本次tick的尾部执行</li><li>vue根据环境尝试使用<code>Promise``SetImmediate``setTimeout(0)</code></li></ul><h1 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h1><ul><li>组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。</li><li>组件的销毁操作是先父后子，销毁完成的顺序是先子后父。<h3 id="加载渲染过程"><a href="#加载渲染过程" class="headerlink" title="加载渲染过程"></a>加载渲染过程</h3>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount- &gt;子mounted-&gt;父mounted<h3 id="子组件更新过程"><a href="#子组件更新过程" class="headerlink" title="子组件更新过程"></a>子组件更新过程</h3>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated<h3 id="父组件更新过程"><a href="#父组件更新过程" class="headerlink" title="父组件更新过程"></a>父组件更新过程</h3>父 beforeUpdate -&gt; 父 updated<h3 id="销毁过程"><a href="#销毁过程" class="headerlink" title="销毁过程"></a>销毁过程</h3>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</li></ul><h1 id="计算属性和侦听属性"><a href="#计算属性和侦听属性" class="headerlink" title="计算属性和侦听属性"></a>计算属性和侦听属性</h1><h2 id="Computed"><a href="#Computed" class="headerlink" title="Computed"></a><code>Computed</code></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript">initComputed (vm: Component, <span class="hljs-attr">computed</span>: <span class="hljs-built_in">Object</span>) &#123;  <span class="hljs-keyword">const</span> watchers = vm._computedWatchers = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)  <span class="hljs-keyword">const</span> isSSR = isServerRendering()  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> computed) &#123;    <span class="hljs-keyword">const</span> userDef = computed[key]    <span class="hljs-keyword">const</span> getter = <span class="hljs-keyword">typeof</span> userDef === <span class="hljs-string">&#x27;function&#x27;</span> ? userDef : userDef.get    ...⭐️<span class="hljs-number">1</span>      watchers[key] = <span class="hljs-keyword">new</span> Watcher(        vm,        getter || noop,        noop,        &#123; <span class="hljs-attr">computed</span>: <span class="hljs-literal">true</span> &#125;      )    <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> vm)) &#123;⭐️<span class="hljs-number">2</span>      defineComputed(vm, key, userDef)    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;      <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> vm.$data) &#123;        <span class="hljs-comment">// ... key名称被data或者prop占用的警告</span>      &#125;    &#125;  &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript">createComputedGetter (key) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computedGetter</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">const</span> watcher = <span class="hljs-built_in">this</span>._computedWatchers &amp;&amp; <span class="hljs-built_in">this</span>._computedWatchers[key]    <span class="hljs-keyword">if</span> (watcher) &#123;⭐️<span class="hljs-number">2</span>      watcher.depend()      <span class="hljs-keyword">return</span> watcher.evaluate()    &#125;  &#125;&#125;</code></pre></div><ol><li>遍历Computed内的key，为每个key创建computed watcher</li><li>利用 Object.defineProperty 给 key 值添加 getter</li><li>渲染函数访问到computed内的key时候，触发getter，生成一个Dep实例，并且此时Dep.target是渲染watcher，渲染watcher就订阅了这个key的变化</li><li>继续执行计算逻辑，会触发其中响应式数据的getter，则computed watcher也就订阅了data的变化，最后也返回计算值</li><li>当依赖的响应式数据变化时，响应的computed watcher会收到通知</li><li>computed watcher会重新求值，结果改变时才会通知渲染watcher</li></ol><h2 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a><code>Watch</code></h2><ul><li>deep</li><li>immediate<div class="hljs code-wrapper"><pre><code class="hljs javascript">initWatch (vm: Component, <span class="hljs-attr">watch</span>: <span class="hljs-built_in">Object</span>) &#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> watch) &#123;    <span class="hljs-keyword">const</span> handler = watch[key]    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(handler)) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; handler.length; i++) &#123;        <span class="hljs-comment">// 遍历handlers</span>        createWatcher(vm, key, handler[i])      &#125;    &#125; <span class="hljs-keyword">else</span> &#123;      createWatcher(vm, key, handler)    &#125;  &#125;&#125;</code></pre></div></li></ul><ol><li>遍历Watch内的key</li><li>遍历每一个handler，为每一个handler创建user watcher</li><li>user watcher会被添加进订阅响应数据的subs[]完成订阅</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web安全</title>
    <link href="/2021/04/13/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    <url>/2021/04/13/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>两个URl <strong>!同协议 !同域名 !同端口</strong></li><li>同源策略限制了同一个源加载的脚本和文档如何与其他源的资源进行交互，包括js脚本，缓存的读取，cookie，ajax等</li><li>三种标签不受同源限制<code>script</code> <code>link</code> <code>img</code></li></ul><h3 id="跨域的方法"><a href="#跨域的方法" class="headerlink" title="跨域的方法"></a>跨域的方法</h3><ul><li><p>代理服务器-<code>nginx,devServer等</code></p></li><li><p>更改页面的源<code>document.domain</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;someWebSite.com/dir1/pageA.html&#x27;</span><span class="hljs-string">&#x27;someWebSite.com/dir2/pageB.html&#x27;</span>都设置<span class="hljs-built_in">document</span>.domain = <span class="hljs-string">&#x27;someWebSite.com&#x27;</span>则他们之间通信将通过同源检测，并都访问父源的cookie</code></pre></div></li><li><p><code>postMessage</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// pageA通过iframe嵌入了pageB</span><span class="hljs-comment">// pageA中代码</span><span class="hljs-built_in">window</span>.iframe[i].postMessage(<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-string">&#x27;pqgeB的URL&#x27;</span>)<span class="hljs-comment">// pageB中的代码</span><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>,<span class="hljs-function"><span class="hljs-title">funciton</span>(<span class="hljs-params">e</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(e.data)     <span class="hljs-comment">// data</span>    <span class="hljs-built_in">console</span>.log(e.source)   <span class="hljs-comment">// a中window的引用</span>    <span class="hljs-built_in">console</span>.log(e.oringin)  <span class="hljs-comment">// pageA的URL</span>&#125;,<span class="hljs-literal">false</span>)<span class="hljs-comment">// 反过来pageB向pageA发送数据</span><span class="hljs-comment">// 在pageA中加入window.addEventListener</span><span class="hljs-comment">// 在pageB中e.source.postMessage</span></code></pre></div></li><li><p><code>iframe</code>+<code>hash</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// pageA通过iframe嵌入了pageB</span><span class="hljs-keyword">var</span> B = <span class="hljs-built_in">document</span>.getElementByTagName(<span class="hljs-string">&quot;iframe&quot;</span>);B.src = B.src + <span class="hljs-string">&quot;#&quot;</span> + <span class="hljs-string">&quot;data&quot;</span>;<span class="hljs-comment">// pageB中的代码</span><span class="hljs-built_in">window</span>.onhashchange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;data = <span class="hljs-built_in">window</span>.location.hash; <span class="hljs-comment">//  &lt;-  pageB就获取到了hash值</span>&#125;;</code></pre></div></li><li><p><code>jsonp</code></p></li></ul>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonp</span>(<span class="hljs-params">&#123; url, params, callback &#125;</span>) </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatParams</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> attrs = []    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [key,value] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(params))&#123;      attrs.push(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;value&#125;</span>`</span>)    &#125;    attrs.push(<span class="hljs-string">`callback=<span class="hljs-subst">$&#123;callback&#125;</span>`</span>)    <span class="hljs-keyword">return</span> attrs.join(<span class="hljs-string">&#x27;&amp;)</span><span class="hljs-string">  &#125;</span><span class="hljs-string">  return new Promise((resolve,reject)=&gt;&#123;</span><span class="hljs-string">    const script = document.createElement(&#x27;</span>script<span class="hljs-string">&#x27;)</span><span class="hljs-string">    script.src = url+&#x27;</span>?<span class="hljs-string">&#x27;+formatParams()</span><span class="hljs-string">    try&#123;</span><span class="hljs-string">      window[callback] = function(data)&#123;</span><span class="hljs-string">        resolve(data)</span><span class="hljs-string">        document.removeChild(script)</span><span class="hljs-string">      &#125;</span><span class="hljs-string">    &#125;catch(err)&#123;</span><span class="hljs-string">      reject(err)</span><span class="hljs-string">    &#125;</span><span class="hljs-string">  &#125;)</span><span class="hljs-string">&#125;</span></code></pre></div>  <div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 发送</span>jsonp(&#123;url: <span class="hljs-string">&quot;http://localhost:3000/jsptest&quot;</span>,params: &#123; <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;jsptestmessage&quot;</span> &#125;,callback: <span class="hljs-string">&quot;jsonpCallback&quot;</span>&#125;).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<span class="hljs-comment">//处理data</span>    &#125;);</code></pre></div><ul><li><p><code>imgPing</code><strong>添加img标签src中放入get请求</strong></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> Image();img.onload = img.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    alert(<span class="hljs-string">&quot;已发送&quot;</span>);&#125;;img.src = <span class="hljs-string">&quot;http://xxx.xxx.com/query?key=value&quot;</span>;<span class="hljs-comment">// 设置完src属性那一刻开始请求就发送了</span></code></pre></div></li><li><p><code>CORS</code>跨域资源共享（详见下文）</p></li><li><p><code>websocket</code>协议</p></li><li><p><code>Fetch</code>API</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postData</span>(<span class="hljs-params">url, data</span>) </span>&#123;<span class="hljs-comment">// Default options are marked with *</span>  <span class="hljs-keyword">return</span> fetch(url, &#123;      body: <span class="hljs-built_in">JSON</span>.stringify(data), <span class="hljs-comment">// must match &#x27;Content-Type&#x27; header</span>      cache: <span class="hljs-string">&quot;no-cache&quot;</span>, <span class="hljs-comment">// *default, no-cache, reload, force-cache, only-if-cached</span>      credentials: <span class="hljs-string">&quot;same-origin&quot;</span>, <span class="hljs-comment">// include, same-origin, *omit</span>      headers: &#123;        <span class="hljs-string">&quot;user-agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/4.0 MDN Example&quot;</span>,       <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>      &#125;,      method: <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-comment">// *GET, POST, PUT, DELETE, etc.</span>      mode: <span class="hljs-string">&quot;cors&quot;</span>, <span class="hljs-comment">// no-cors, cors, *same-origin</span>      redirect: <span class="hljs-string">&quot;follow&quot;</span>, <span class="hljs-comment">// manual, *follow, error</span>      referrer: <span class="hljs-string">&quot;no-referrer&quot;</span> <span class="hljs-comment">// *client, no-referrer</span>      &#125;).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json()); <span class="hljs-comment">// parses response to JSON</span>  &#125;</code></pre></div></li></ul><h3 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a><code>CORS</code>跨域</h3><h4 id="！简单请求"><a href="#！简单请求" class="headerlink" title="！简单请求"></a>！简单请求</h4><ul><li>方法<code>post get head</code>,</li><li><code>Content-Type</code>：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul><h5 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h5><ul><li>header中添加<code>Origin</code>字段</li></ul><h5 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h5><ul><li><p><code>Access-Control-Allow-Origin</code>:允许跨域访问的域，可以是一个域的列表，也可以是通配符”*“</p></li><li><p><code>Access-Control-Allow-Credentials</code>:是否允许请求带有 cookie</p><p>如果要发送<code>Cookie，Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名</p><p>并且 ajax 中要打开</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();xhr.withCredentials = <span class="hljs-literal">true</span>;  <span class="xml">&lt;-------</span></code></pre></div></li><li><p><code>Access-Control-Expose-Headers</code>: 自定义字段</p></li></ul><h4 id="！非简单请求"><a href="#！非简单请求" class="headerlink" title="！非简单请求"></a>！非简单请求</h4><ul><li>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code></li><li>正式通信前会先发起”预检”请求</li><li>一旦服务器通过了”预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样</li></ul><h5 id="请求-1"><a href="#请求-1" class="headerlink" title="请求"></a>请求</h5><ul><li><code>OPTIONS</code>询问</li><li><code>Origin</code>来源域</li><li><code>Access-Control-Request-Method</code>接下来请求的方法</li></ul><h5 id="响应-1"><a href="#响应-1" class="headerlink" title="响应"></a>响应</h5><ul><li><code>Access-Control-Allow-Origin</code>允许跨域访问的域</li><li><code>Access-Control-Allow-Methods</code>服务器支持的所有跨域请求的方法</li><li><code>Access-Control-Max-Age</code>预检请求有效期</li><li><code>Access-Control-Allow-Credentials</code>与简单请求相同</li></ul><h2 id="XSS跨域脚本攻击"><a href="#XSS跨域脚本攻击" class="headerlink" title="XSS跨域脚本攻击"></a>XSS跨域脚本攻击</h2><p><code>Cross-site scripting</code></p><blockquote><p>浏览器渲染过程中执行了预期外的恶意代码，使非法脚本在用户页面内运行</p></blockquote><ul><li><p>存储型XSS</p><p>  input, textarea等）中写入恶意脚本上传到服务器，其他人下载带有该脚本的html页面至浏览器时脚本运行</p></li><li><p>反射型XSS</p><p>  将恶意代码加入<code>URL</code>中提交给服务器，服务器返回内容就带上了恶意代码，浏览器下载页面则执行了恶意代码，服务器不存储恶意代码</p></li><li><p>DOM XSS</p><ul><li>JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等函数</li><li><code>&lt;a&gt;</code>标签的<code>href</code>属性</li><li>DOM中的内联事件监视器,<code>location</code>,<code>onclick</code>,<code>onerror</code>,<code>onload</code>等</li><li>都可以将字符串作为代码执行</li></ul></li></ul><h3 id="防范XSS"><a href="#防范XSS" class="headerlink" title="防范XSS"></a>防范XSS</h3><ul><li>设置cookie  <code>httponly</code></li><li>校验用户输入和URL参数进行过滤</li><li>对发送至用户的内容进行转码，避免浏览器执行</li><li>使用内容安全策略CSP<code>Content Security Policy</code>,限制该页面可以获取的资源和来源</li><li>! <code>jsonp</code>如何防止xss<ol><li>前后端约定jsonp请求的js的回调函数名</li><li>服务器端指定返回的数据格式为json</li><li>进行referrer验证 （<code>$_SERVER[&#39;HTTP_REFERRER&#39;] 中的 host</code>）</li></ol></li></ul><h2 id="CSRF跨域请求伪造"><a href="#CSRF跨域请求伪造" class="headerlink" title="CSRF跨域请求伪造"></a>CSRF跨域请求伪造</h2><p><code>Cross-site request forgery</code><br> 利用用户的登陆状态诱导至恶意网站，以合法身份向原先网站发送恶意请求</p><h3 id="防御CSRF"><a href="#防御CSRF" class="headerlink" title="防御CSRF"></a>防御CSRF</h3><ul><li>同源检测，验证<code>http</code>请求的来源<code>origin</code>和<code>referrer</code></li><li>设置<code>cookie</code>的<code>SameSite</code>属性，使<code>cookie</code>只可被第一方使用</li><li>合法页面中加入<code>token</code>，并在合法页面的后续请求（a标签和表单）中都加上这个<code>token</code>,服务器验证</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="SQl注入"><a href="#SQl注入" class="headerlink" title="SQl注入"></a>SQl注入</h4><ol><li><p>黑客提交畸形数据改变语义提交sql查询得到非法数据</p></li><li><p>防御</p><ol><li>过滤sql保留字</li><li>减少抛出不必要的数据库错误信息</li><li>禁止动态拼接sql语句访问数据库</li></ol></li></ol><h4 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h4><ol><li>点击透明iframe</li><li>监听鼠标移动位置</li><li>H5拖拽</li><li>防御：<ol><li>服务端添加 <code>X-Frame-Options</code> 响应头</li><li>js判断顶层视口是否同源</li><li>敏感操作复杂操作（验证码，二次确认</li></ol></li></ol><h4 id="window-opener"><a href="#window-opener" class="headerlink" title="window.opener"></a><code>window.opener</code></h4><ol><li>修改<code>window.opener.location</code>可以改写来源站点的地址</li><li>防御：<ol><li>设置a标签的rel属性<code>rel=noopener</code>,禁止新页面传递源页面地址</li><li>外部链接改为经由服务器跳转</li><li>使用window.open打开外链</li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue组件之间通信方式</title>
    <link href="/2021/04/13/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <url>/2021/04/13/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="ref和-refs"><a href="#ref和-refs" class="headerlink" title="ref和$refs"></a><code>ref和$refs</code></h3><ul><li><p><code>ref</code>挂载在普通HTML组件上访问它得到DOM</p></li><li><p><code>ref</code>挂载在VUE组件上访问它得到组件实例</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;usernameInput&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">base-input</span>&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$refs.usernameInput</code></pre></div><h3 id="emit和prop"><a href="#emit和prop" class="headerlink" title="$emit和prop"></a><code>$emit</code>和<code>prop</code></h3><ul><li>子组件<code>props</code>接收父组件传递的数据</li><li>动态数据加冒号<code>:</code></li><li>子组件可对收到的<code>props</code>设置校验</li><li>子组件定义<code>$emit</code>自定义方法<br><code>this.$emit(&#39;childToParentMsg&#39;,this.childInfor,this.type)</code></li><li>父组件就可以<code>v-on</code>监听该方法</li><li>该方法绑定父组件的<code>methods</code></li><li>获得方法中传递的参数</li></ul><h3 id="parent和-children"><a href="#parent和-children" class="headerlink" title="$parent和$children"></a><code>$parent</code>和<code>$children</code></h3><ul><li>$parent得到  <strong>对象</strong></li><li>$children得到子组件实例的 <strong>数组</strong></li></ul><h3 id="provide和inject"><a href="#provide和inject" class="headerlink" title="provide和inject"></a><code>provide</code>和<code>inject</code></h3><ul><li><p>父组件向<code>任意深度</code>子组件传值</p></li><li><p>父组件中通过<code>provide</code>来提供变量</p></li><li><p>子组件中通过<code>inject</code>来注入变量</p></li><li><p>不论子组件有多深，只要调用了<code>inject</code>那么就可以注入<code>provider</code>中的数据。只要在父组件的生命周期内，子组件都可以调用。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">Vue.component(<span class="hljs-string">&#x27;child&#x27;</span>,&#123;    <span class="hljs-comment">// </span>    inject:[<span class="hljs-string">&#x27;for&#x27;</span>],      <span class="xml">&lt;------------------将for变量插入本实例</span><span class="xml">    data()&#123;</span><span class="xml">        return &#123;</span><span class="xml">            mymessage:this.for</span><span class="xml">        &#125;</span><span class="xml">    &#125;</span><span class="xml">&#125;)</span><span class="xml">Vue.component(&#x27;parent&#x27;,&#123;</span>    provide:&#123;    &lt;---------------------------提供了for变量        for:&#x27;test&#x27;    &#125;&#125;)</code></pre></div></li></ul><h3 id="attrs-amp-amp-listeners"><a href="#attrs-amp-amp-listeners" class="headerlink" title="$attrs &amp;&amp; $listeners"></a><code>$attrs</code> &amp;&amp; <code>$listeners</code></h3><ul><li><p><code>$attrs</code>包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外),通过<code>v-bind=&quot;$attrs&quot;</code> 传入内部组件</p></li><li></li><li><p><code>$listeners</code>包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// A-&gt;B-&gt;C</span>  <span class="hljs-comment">// 二级子组件C</span>  Vue.component(<span class="hljs-string">&#x27;C&#x27;</span>,&#123;          template:<span class="hljs-string">`</span><span class="hljs-string">              &lt;div&gt;</span><span class="hljs-string">                  &lt;input type=&quot;text&quot; v-model=&quot;$attrs.messagec&quot; @input=&quot;passCData($attrs.messagec)&quot;&gt; &lt;/div&gt;</span><span class="hljs-string">          `</span>,          methods:&#123;              <span class="hljs-function"><span class="hljs-title">passCData</span>(<span class="hljs-params">val</span>)</span>&#123;                  <span class="hljs-comment">//触发父组件A中的事件</span>                  <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;getCData&#x27;</span>,val)              &#125;          &#125;      &#125;)  <span class="hljs-comment">// 一级子组件B</span>  Vue.component(<span class="hljs-string">&#x27;B&#x27;</span>,&#123;      <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;          <span class="hljs-keyword">return</span> &#123;              mymessage:<span class="hljs-built_in">this</span>.message          &#125;      &#125;,      template:<span class="hljs-string">`</span><span class="hljs-string">          &lt;div&gt;</span><span class="hljs-string">              &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @input=&quot;passData(mymessage)&quot;&gt; </span><span class="hljs-string">              &lt;C v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/C&gt;</span><span class="hljs-string">          &lt;/div&gt;</span><span class="hljs-string">      `</span>,      props:[<span class="hljs-string">&#x27;message&#x27;</span>],<span class="hljs-comment">//props中取走了A传下来的一个attr</span>      <span class="hljs-comment">// 另外一个使用:bind=&quot;$attrs&quot;继续向下传递给C</span>      methods:&#123;          <span class="hljs-function"><span class="hljs-title">passData</span>(<span class="hljs-params">val</span>)</span>&#123;              <span class="hljs-comment">//触发父组件中的事件</span>              <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;getChildData&#x27;</span>,val)          &#125;      &#125;  &#125;)  <span class="hljs-comment">// 父组件A</span>  Vue.component(<span class="hljs-string">&#x27;A&#x27;</span>,&#123;      template:<span class="hljs-string">`</span><span class="hljs-string">          &lt;div&gt;</span><span class="hljs-string">              &lt;p&gt;this is parent compoent!&lt;/p&gt;</span><span class="hljs-string">              &lt;B :messagec=&quot;messagec&quot; :message=&quot;message&quot; v-on:getCData=&quot;getCData&quot; v-on:getChildData=&quot;getChildData(message)&quot;&gt;&lt;/B&gt;</span><span class="hljs-string">          &lt;/div&gt;</span><span class="hljs-string">      `</span>,      <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;          <span class="hljs-keyword">return</span> &#123;              message:<span class="hljs-string">&#x27;hello&#x27;</span>,              messagec:<span class="hljs-string">&#x27;hello c&#x27;</span> <span class="hljs-comment">//传递给c组件的数据</span>          &#125;      &#125;,      methods:&#123;          <span class="hljs-function"><span class="hljs-title">getChildData</span>(<span class="hljs-params">val</span>)</span>&#123;              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这是来自B组件的数据&#x27;</span>)          &#125;,          <span class="hljs-comment">//执行C子组件触发的事件</span>          <span class="hljs-function"><span class="hljs-title">getCData</span>(<span class="hljs-params">val</span>)</span>&#123;              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;这是来自C组件的数据：&quot;</span>+val)          &#125;      &#125;  &#125;)</code></pre></div></li></ul><h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// eventBus.js</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">const</span> EventBus  = <span class="hljs-keyword">new</span> Vue()<span class="hljs-comment">// componentA</span><span class="hljs-keyword">import</span> EventBus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;eventBus.js&#x27;</span>methods:&#123;    <span class="hljs-function"><span class="hljs-title">someFunc</span>(<span class="hljs-params"></span>)</span>&#123;        EventBus.$emit(<span class="hljs-string">&#x27;funcName&#x27;</span>,&#123;            <span class="hljs-comment">//props</span>        &#125;)    &#125;&#125;<span class="hljs-comment">// componentsB</span><span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span>&#123;    EventBus.$on(<span class="hljs-string">&#x27;funcName&#x27;</span>,<span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> &#123;        <span class="hljs-comment">//params取得传过来的参数</span>    &#125;)&#125;</code></pre></div><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包</title>
    <link href="/2021/04/13/js%E9%97%AD%E5%8C%85/"/>
    <url>/2021/04/13/js%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h2><ul><li><p>函数与其词法环境共同构成 <em>闭包（closure）</em> 。</p></li><li><p>词法环境 = 代码内变量标识符与变量值和函数值之间的关联关系（环境记录）+ 外部词法环境的引用</p></li><li><p>js的词法作用域为静态作用域，在书写完成后函数词法环境就被确定，与调用位置无关</p></li><li><p>闭包函数会保持对外部词法环境的引用，使外部变量常驻内存不可回收</p></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCounter</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>; <span class="hljs-comment">// 执行结束后不会被清除</span>  <span class="hljs-keyword">const</span> myFunction = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    counter = counter + <span class="hljs-number">1</span>; <span class="hljs-comment">// myFunction函数可以读取add函数内部的变量</span>    <span class="hljs-keyword">return</span> counter;  &#125;;  <span class="hljs-keyword">return</span> myFunction;&#125;<span class="hljs-keyword">const</span> increment = addCounter();<span class="hljs-keyword">const</span> c1 = increment();<span class="hljs-keyword">const</span> c2 = increment();<span class="hljs-keyword">const</span> c3 = increment();<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;increment:&quot;</span>, c1, c2, c3);<span class="hljs-comment">// increment: 1 2 3</span></code></pre></div><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(i)  &#125;, <span class="hljs-number">1000</span> * i)&#125;<span class="hljs-comment">// 6 6 6 6 6 6</span><span class="hljs-comment">// 创建的6个setTimeout闭包共享一个词法作用域</span>**闭包只能取得包含函数中任何变量赋值最后一个值** <span class="hljs-comment">// 6</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;  (<span class="hljs-function">(<span class="hljs-params">j</span>) =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(j)    &#125;, <span class="hljs-number">1000</span> * j)  &#125;)(i)&#125;<span class="hljs-comment">// 1 2 3 4 5 6</span><span class="hljs-comment">// 6个setTimeout闭包有自己独立的词法环境</span><span class="hljs-comment">// 闭包读取到不同的i值</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span> ;i&lt;<span class="hljs-number">7</span>;i++)&#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">j</span>=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(j);  &#125;,<span class="hljs-number">1000</span>*i,i)&#125;<span class="hljs-comment">// setTimeout 可以接受一个参数当函数调用时传入</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">num2</span>) </span>&#123;  <span class="hljs-keyword">var</span> num = <span class="hljs-number">15</span>;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">abc</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 函数作为返回值</span>    num++;    <span class="hljs-keyword">return</span>(num + num2);  &#125;  <span class="hljs-keyword">return</span> abc;&#125;<span class="hljs-keyword">var</span> aa = fn(<span class="hljs-number">20</span>); <span class="hljs-comment">//  没有引用？？</span>aa(); <span class="hljs-comment">//16+20</span>aa(); <span class="hljs-comment">//17+20</span>fn(<span class="hljs-number">20</span>)(); <span class="hljs-comment">//36</span>fn(<span class="hljs-number">20</span>)(); <span class="hljs-comment">//36</span></code></pre></div><h2 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h2><h3 id="作用域：变量可以起作用的范围"><a href="#作用域：变量可以起作用的范围" class="headerlink" title="作用域：变量可以起作用的范围"></a>作用域：变量可以起作用的范围</h3><h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><div class="hljs code-wrapper"><pre><code>全局变量对应的作用域`全局变量`：在任何地方都可以访问到的变量，全局变量关闭网页或浏览器才会销毁(生命周期)</code></pre></div><h4 id="局部作用域（函数作用域）"><a href="#局部作用域（函数作用域）" class="headerlink" title="局部作用域（函数作用域）"></a>局部作用域（函数作用域）</h4><div class="hljs code-wrapper"><pre><code>函数内部就是一个局部作用域`局部变量`：只在固定的代码片段内可访问到的变量，变量退出作用域之后会销毁</code></pre></div><h4 id="块级作用域（es5）"><a href="#块级作用域（es5）" class="headerlink" title="块级作用域（es5）"></a>块级作用域（es5）</h4><div class="hljs code-wrapper"><pre><code>任何一对花括号`&#123;&#125;`中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为 `块级作用域`</code></pre></div><h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><div class="hljs code-wrapper"><pre><code>变量的作用域是在定义时决定而不是执行时决定，也就是说词法作用域取决于源码，通过静态分析就能确定(书写时就已经确定)，因此词法作用域也叫做静态作用域</code></pre></div><p><em>在 js 中词法作用域规则:</em></p><ul><li>函数允许访问函数外的数据.</li><li>整个代码结构中只有函数可以限定作用域</li><li>作用域规则首先使用提升规则分析</li><li>如果当前作用规则中有名字了, 就不考虑外面的名字</li></ul><h3 id="自由变量"><a href="#自由变量" class="headerlink" title="自由变量"></a>自由变量</h3><ul><li><p>当前作用域没有定义的变量，这成为<code>自由变量</code>。</p></li><li><p>自由变量向父级作用域中寻找</p></li><li><p><strong>自由变量从作用域链中去寻找，依据的是函数定义时的作用域链，而不是函数执行时的作用域</strong></p></li></ul><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>只有函数可以制造作用域结构， 那么只要是代码，就至少有一个作用域, 即全局作用域。凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。</p><p>将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。</p><h2 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h2><ul><li>实现数据(变量和方法)私有化</li><li>函数柯里化（函数式编程</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js模块化</title>
    <link href="/2021/04/13/js%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2021/04/13/js%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<blockquote><p>模块化的演进过程</p></blockquote><ol><li>文件划分</li><li>命名空间 (将每个模块暴露在全局对象</li><li>IIFE 立即执行函数 </li></ol><h2 id="模块化开发的思想"><a href="#模块化开发的思想" class="headerlink" title="模块化开发的思想"></a>模块化开发的思想</h2><p>模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。</p><h3 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h3><ul><li>命名冲突</li><li>文件依赖</li><li>代码复用</li><li>不污染全局空间</li></ul><h3 id="CommonJS-Node-js"><a href="#CommonJS-Node-js" class="headerlink" title="CommonJS (Node.js)"></a>CommonJS (Node.js)</h3><ul><li><p>运行在服务端`</p></li><li><p>代码同步加载</p></li><li><p>代码可以多次加载，但是运行结果会被缓存</p></li><li><p><code>require(&#39;xxx&#39;)</code>加载模块</p></li><li><p><code>module.exports=&#123;&#125;</code>(全局变量或方法)或<code>exports</code>定义对外的接口</p></li></ul><h3 id="AMD-require-js"><a href="#AMD-require-js" class="headerlink" title="AMD (require.js)"></a>AMD (require.js)</h3><ul><li><code>Async Module Definition</code></li><li>代码异步加载</li><li>依赖前置，在定义模块的时候就要声明其依赖的模块</li><li>执行顺序不一定和代码中顺序相同，而是谁先下载完执行谁  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// AMD</span>define([<span class="hljs-string">&quot;./a&quot;</span>, <span class="hljs-string">&quot;./b&quot;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;    <span class="hljs-comment">// ...</span>    a.doSomething();    <span class="hljs-comment">// ...</span>    b.doSomething();    <span class="hljs-comment">// ...可能b比a先do了</span>&#125;);</code></pre></div></li></ul><h3 id="CMD-sea-js"><a href="#CMD-sea-js" class="headerlink" title="CMD (sea.js)"></a>CMD (sea.js)</h3><ul><li><code>Common Module Definition</code></li><li> 定义和加载与AMD相同</li><li> 依赖可以就近书写</li><li>依赖全部加载完才按顺序执行  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// CMD</span>define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>) </span>&#123;    <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./a&quot;</span>);    a.doSomething();    <span class="hljs-comment">//...</span>    <span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./b&quot;</span>);     b.doSomething();<span class="hljs-comment">// ...</span>&#125;);</code></pre></div></li></ul><h3 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h3><ul><li> <code>Universal Module Definition</code></li><li> 写法是一个自运行函数</li><li> 兼容CMD/AMD/命名空间</li></ul><h3 id="ES6-MODULE"><a href="#ES6-MODULE" class="headerlink" title="ES6 MODULE"></a>ES6 MODULE</h3><ul><li><p>！ES6模块不是对象，<code>import</code>指向的是模块的的只读引用（<strong>动态引用</strong>），<code>export</code>只是显式指定输出的代码</p></li><li><p>编译时加载,用到才执行</p></li><li><p><code>export</code>导出模块,提供<code>export default</code>制定默认输出</p></li><li><p><code>import</code>引入</p></li><li><p><code>import</code>和<code>export</code>命令只能写在代码顶层</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// modules.js</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;    <span class="hljs-keyword">return</span> x * y;&#125;<span class="hljs-keyword">export</span> &#123;add <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>&#125;;<span class="hljs-comment">// 等同于</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> add;<span class="hljs-comment">// app.js</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;modules&#x27;</span>;<span class="hljs-comment">// 等同于</span><span class="hljs-keyword">import</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;modules&#x27;</span>;</code></pre></div></li></ul><h3 id="ES6-MODULE和CommonJS的区别"><a href="#ES6-MODULE和CommonJS的区别" class="headerlink" title="ES6 MODULE和CommonJS的区别"></a>ES6 MODULE和CommonJS的区别</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// CommonJS模块</span><span class="hljs-comment">// 运行时加载</span><span class="hljs-keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-comment">// 等同于</span><span class="hljs-keyword">let</span> _fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-keyword">let</span> stat = _fs.stat;<span class="hljs-keyword">let</span> exists = _fs.exists;<span class="hljs-keyword">let</span> readfile = _fs.readfile;<span class="hljs-comment">//上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”</span>modules.exports xxx<span class="hljs-comment">//CommonJS 模块输出的是值的拷贝，输出后模块内部的变化就影响不到这个值</span><span class="hljs-comment">// ES6</span><span class="hljs-comment">// 编译时加载</span><span class="hljs-keyword">import</span> &#123; stat, exists, readFile &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;<span class="hljs-comment">//编译时就完成模块加载，（确定了指针</span><span class="hljs-comment">//当然，这也导致了没法引用 ES6 模块本身，因为它不是对象</span><span class="hljs-built_in">exports</span> <span class="hljs-keyword">default</span> xxx<span class="hljs-comment">// ES6 MODULES输出的是值的引用，运行时才到指定模块中取值</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>es6新特性</title>
    <link href="/2021/04/13/es6%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2021/04/13/es6%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="let-const"><a href="#let-const" class="headerlink" title="let / const"></a>let / const</h2><ul><li>都用于声明变量</li><li>不存在变量提升，暂时性死区</li><li>不能重复声明</li><li>快级作用域</li></ul><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li>可以重新赋值<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3></li><li>声明时需赋值</li><li>只读不可改变（对于复杂变量，可以修改变量内容，变量内存地址未改变）</li></ul><h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><ul><li>只有可遍历（具备遍历器<code>[Symbol.Iterator]</code>）的数据结构才能解构赋值<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3></li><li>遍历数据</li><li>交换变量</li><li>提取对象中的数据</li><li>函数参数默认值</li><li>指定模块</li></ul><h2 id="字符串，数值，函数，数组，对象扩展"><a href="#字符串，数值，函数，数组，对象扩展" class="headerlink" title="字符串，数值，函数，数组，对象扩展"></a>字符串，数值，函数，数组，对象扩展</h2><p>例如：</p><ul><li>模版字符串（变量插值，多行字符串</li><li>安全整数<code>Number.isSafeInteger</code>,<code>Number.MAX_SAFE_INTEGER</code>,<code>Number.MAX_SAFE_INTEGER</code><blockquote><p>+-2^53 +-10^16</p></blockquote></li><li>指数运算<code>**</code></li><li>大数<code>BigInt</code>，后要加上字母n<code>123n</code>，没有位数限制<blockquote><p>普通number类型只能保留53个二进制位/16个10进制位</p></blockquote></li><li>箭头函数<ul><li>箭头函数的 this 是语法上的，静态绑定书写时的上下文，不会改变</li><li>箭头函数没有<code>prototype</code> —&gt; <strong>不能作为构造函数，不能 new</strong></li><li>箭头函数没有<code>arguments</code>属性</li><li>不能用作<code>generator</code>函数</li></ul></li></ul><ul><li><p>函数参数默认值</p></li><li><p><code>...rest</code></p></li><li><p>扩展运算符<code>...</code></p></li><li><p>一堆数组方法</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.from()<span class="hljs-built_in">Array</span>.of()includes()copyWithin()find()/findIndex()keys(),values(),entries()</code></pre></div></li><li><p>对象方法</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.is()<span class="hljs-built_in">Object</span>.assign()getPrototypeOf()/setPrototypeOf().__proto__ =</code></pre></div><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>独一无二的值,<code>Symbol()</code>声明</p><h2 id="Set-WeakSet"><a href="#Set-WeakSet" class="headerlink" title="Set/WeakSet"></a>Set/WeakSet</h2></li><li><p>Set类似于数组，但是成员的值都是唯一的</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">sizeadd()<span class="hljs-keyword">delete</span>()has()clear()</code></pre></div></li><li><p>WeakSet的成员只能是对象，【弱引用】，【不可遍历】</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">add()<span class="hljs-keyword">delete</span>()has()</code></pre></div></li></ul><h2 id="Map-WeakMap"><a href="#Map-WeakMap" class="headerlink" title="Map/WeakMap"></a>Map/WeakMap</h2><ul><li>Object的键传统上只能使用字符串，Map无此限制<div class="hljs code-wrapper"><pre><code class="hljs javascript">sizeset(key,value) <span class="hljs-comment">// 返回整个 Map 结构</span>get() <span class="hljs-comment">// 找不到该 key 返回 undefined</span>has()<span class="hljs-keyword">delete</span>() <span class="hljs-comment">// 删除失败返回 false</span>clear() <span class="hljs-comment">// 无返回值</span></code></pre></div></li><li>WeakMap只接受对象作为键名（除了null），【键名弱引用】<div class="hljs code-wrapper"><pre><code class="hljs javascript">set()get()has()<span class="hljs-keyword">delete</span>()</code></pre></div></li></ul><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>拦截器/代理 <code>const _proxy1 = new Proxy(target,handler)</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 常用handlers</span>handler.getPrototypeOf()<span class="hljs-comment">// Object.getPrototypeOf 方法的捕捉器。</span>handler.setPrototypeOf()<span class="hljs-comment">// Object.setPrototypeOf 方法的捕捉器。</span>handler.getOwnPropertyDescriptor()<span class="hljs-comment">// Object.getOwnPropertyDescriptor 方法的捕捉器。</span>handler.defineProperty()<span class="hljs-comment">// Object.defineProperty 方法的捕捉器。</span>handler.has()<span class="hljs-comment">// in 操作符的捕捉器。</span>handler.get()<span class="hljs-comment">// 属性读取操作的捕捉器。</span>handler.set()<span class="hljs-comment">// 属性设置操作的捕捉器。</span>handler.deleteProperty()<span class="hljs-comment">// delete 操作符的捕捉器。</span>handler.ownKeys()<span class="hljs-comment">// Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。</span>handler.apply()<span class="hljs-comment">// 函数调用操作的捕捉器。</span>handler.construct()<span class="hljs-comment">// new 操作符的捕捉器。</span></code></pre></div><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><p>操作对象的API</p><ul><li>将对象操作的返回更合理化（报错-&gt;false</li><li>将对象操作函数化<blockquote><p>某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</p></blockquote></li><li>与Proxy中方法均对应<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2></li><li>处理异步操作，避免回调嵌套</li><li>状态不可逆</li><li>中途不可停止</li><li>需要捕获promise内错误</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve,reject))<span class="hljs-built_in">Promise</span>.prototype.then(onFulfilled,onRejected)<span class="hljs-built_in">Promise</span>.prototype.catch()<span class="hljs-comment">// promise中的错误会一直冒泡到最后，没有捕获则报错</span><span class="hljs-built_in">Promise</span>.prototype.finally()<span class="hljs-built_in">Promise</span>.all() <span class="hljs-comment">// 全部fulfilled或者有谁rejected</span><span class="hljs-built_in">Promise</span>.allSettled() <span class="hljs-comment">// 全部得到不管什么状态</span><span class="hljs-built_in">Promise</span>.race() <span class="hljs-comment">// 最先改变status</span><span class="hljs-built_in">Promise</span>.any() <span class="hljs-comment">// 最先fulfilled或者全部rejected</span><span class="hljs-built_in">Promise</span>.resolve()<span class="hljs-built_in">Promise</span>.reject()<span class="hljs-built_in">Promise</span>.try()</code></pre></div><h2 id="Iterator和for…of循环"><a href="#Iterator和for…of循环" class="headerlink" title="Iterator和for…of循环"></a>Iterator和for…of循环</h2><h3 id="Symbol-Iterator"><a href="#Symbol-Iterator" class="headerlink" title="[Symbol.Iterator]"></a>[Symbol.Iterator]</h3><ul><li>统一的遍历集合数据的借口</li><li>只要拥有<code>[Symbol.Iterator]</code>的数据结构都可以用for…of遍历</li></ul><h3 id="原生具备-Iterator-接口的数据结构如下。"><a href="#原生具备-Iterator-接口的数据结构如下。" class="headerlink" title="原生具备 Iterator 接口的数据结构如下。"></a>原生具备 Iterator 接口的数据结构如下。</h3><ul><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>函数的 arguments 对象</li><li>NodeList 对象</li></ul><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><h3 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h3><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await。<br>可以看作是多个异步操作包装成的 Promise 对象，await命令就是内部 then 命令的语法糖。</p><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><ul><li>可以暂停的状态机，遇到yield则暂停</li><li>.next（）执行到下一个yield</li><li>自执行generator<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">co</span>(<span class="hljs-params">fn</span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;    <span class="hljs-keyword">const</span> gen = fn()    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step</span>(<span class="hljs-params">nextF</span>)</span>&#123;      <span class="hljs-keyword">let</span> ret      <span class="hljs-keyword">try</span>&#123;        ret = nextF()      &#125;<span class="hljs-keyword">catch</span>(e)&#123;        <span class="hljs-keyword">return</span> reject(e)      &#125;      <span class="hljs-keyword">if</span>(ret.done) <span class="hljs-keyword">return</span> resolve(ret.value)      <span class="hljs-built_in">Promise</span>.resolve(ret.value).then(<span class="hljs-function"><span class="hljs-params">v</span>=&gt;</span>&#123;        step(<span class="hljs-function">()=&gt;</span>gen.next(v))      &#125;,<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span>&#123;        step(<span class="hljs-function">()=&gt;</span>gen.throe(e))      &#125;)    &#125;    step(<span class="hljs-function">()=&gt;</span>gen.next(<span class="hljs-literal">undefined</span>))  &#125;)&#125;</code></pre></div><h2 id="async-await-1"><a href="#async-await-1" class="headerlink" title="async/await"></a>async/await</h2>generator语法糖<h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2></li></ul><ol><li><p>类表达式和类声明</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> A = <span class="hljs-class"><span class="hljs-keyword">class</span> </span>&#123;&#125;<span class="hljs-comment">// or</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;</code></pre></div><blockquote><p>类声明和类表达式的主体都执行在严格模式下</p></blockquote></li><li><p>继承</p><p>本质使用的是原型式继承</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span>&#123;    <span class="hljs-built_in">this</span>.name = name  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-title">extend</span> <span class="hljs-title">B</span></span>&#123;  <span class="hljs-title">constructor</span> (<span class="hljs-params">name</span>)&#123;    <span class="hljs-built_in">super</span>(name)      &#125;  &#125;</code></pre></div></li><li><p>静态字段，私有字段，私有实例字段</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span></span>&#123;  <span class="hljs-comment">//静态字段</span>  <span class="hljs-keyword">static</span> attr1 = <span class="hljs-number">123</span>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">func1</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;im func1&#x27;</span>&#125;  <span class="hljs-comment">//只在类声明中存在，实例不能访问</span>  <span class="hljs-comment">// 公有字段</span>  attr2 = <span class="hljs-number">666</span>  <span class="hljs-function"><span class="hljs-title">func2</span>(<span class="hljs-params"></span>)</span>&#123;&#125;  <span class="hljs-comment">// 每个实例都复制一份</span>  <span class="hljs-comment">//私有实例字段</span>  <span class="hljs-comment">//不能直接访问，闭包访问</span>  #attr3  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span>&#123;    <span class="hljs-built_in">this</span>.#attr3 = name  &#125;  <span class="hljs-function"><span class="hljs-title">getPrivate</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.#attr3  &#125;  #func3 = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;im private&#x27;</span>);  &#125;  <span class="hljs-function"><span class="hljs-title">getPrivateFunc</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.#func3()  &#125;&#125;</code></pre></div></li></ol><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ol><li>语法</li></ol><p><code>export / export</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 这是 Node 中向外暴露成员的形式：</span><span class="hljs-comment">// module.exports = &#123;&#125;</span><span class="hljs-comment">// ES6中导入模块，使用 import 模块名称 from &#x27;模块标识符&#x27; import &#x27;表示路径&#x27;</span><span class="hljs-comment">// 在 ES6 中，使用 export default 和 export 向外暴露成员：</span><span class="hljs-keyword">var</span> info = &#123;  name: <span class="hljs-string">&quot;zs&quot;</span>,  age: <span class="hljs-number">20</span>&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> info;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  address: <span class="hljs-string">&quot;深圳&quot;</span>&#125;;<span class="hljs-comment">// 注意： export default 向外暴露的成员，可以使用任意的变量来接收</span><span class="hljs-comment">// 注意： 在一个模块中，export default 只允许向外暴露1次</span><span class="hljs-comment">// 注意： 在一个模块中，可以同时使用 export default 和 export 向外暴露成员</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> title = <span class="hljs-string">&quot;小星星&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> content = <span class="hljs-string">&quot;哈哈哈&quot;</span>;<span class="hljs-comment">// 注意： 使用 export 向外暴露的成员，只能使用 &#123; &#125; 的形式来接收，这种形式，叫做 【按需导出】</span><span class="hljs-comment">// 注意： export 可以向外暴露多个成员， 同时，如果某些成员，我们在 import 的时候，不需要，则可以不在 &#123;&#125; 中定义</span><span class="hljs-comment">// 注意： 使用 export 导出的成员，必须严格按照 导出时候的名称，来使用 &#123;&#125; 按需接收；</span><span class="hljs-comment">// 注意： 使用 export 导出的成员，如果 就想 换个 名称来接收，可以使用 as 来起别名；</span><span class="hljs-comment">// 在Node中 使用 var 名称 = require(&#x27;模块标识符&#x27;)</span><span class="hljs-comment">// module.exports 和 exports 来暴露成员</span></code></pre></div><ol start="2"><li><p>使用 babel 编译 ES6 语法</p><p>Babel 是一个工具链，主要用于在旧的浏览器或环境中将 ECMAScript 2015+ 代码转换为向后兼容版本的 JavaScript 代码</p></li><li><p>模块化工具 webpack,rollup</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flex布局</title>
    <link href="/2021/04/13/flex/"/>
    <url>/2021/04/13/flex/</url>
    
    <content type="html"><![CDATA[<p>ref:<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">阮一峰的网络日志</a></p><h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><ul><li><p>flex-direction 主轴的方向</p><p><code>flex-direction</code>: </p><ul><li><code>row(默认住) | row-reverse</code> 横向排列</li><li><code>column | column-reverse</code>纵向排列</li></ul></li><li><p>flex-wrap 排列不下时的换行处理</p><p><code>flex-wrap</code>:</p><ul><li><code>nowrap</code>不换行</li><li><code>wrap</code>换行</li><li><code>wrap-reverse</code>逆序换行</li></ul></li><li><p>flex-flow(上述两种的简写)</p><p><code>flex-flow属性是flex-direction属性和flex-wrap属性的简写</code></p></li><li><p>justify-content 主轴上的对齐方式</p><ul><li><code>flex-start</code>（默认值）：左对齐 </li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</li></ul></li><li><p>align-items 项目在交叉轴上如何对齐 </p><ul><li><code>flex-start</code>：交叉轴的起点对齐</li><li><code>flex-end</code>：交叉轴的终点对齐</li><li><code>center</code>：交叉轴的中点对齐</li><li><code>baseline</code>: 项目的第一行文字的基线对齐</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度</li></ul></li><li><p>align-content 多根轴线的对齐方式</p><ul><li><code>flex-start</code>：与交叉轴的起点对齐</li><li><code>flex-end</code>：与交叉轴的终点对齐</li><li><code>center</code>：与交叉轴的中点对齐</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴</li></ul></li></ul><h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><ul><li><p><code>order</code></p><p>项目的排列顺序。数值越小，排列越靠前，默认为0</p></li><li><p><code>flex-grow</code></p><p>如果存在剩余空间，1放大，0不放大</p></li><li><p><code>flex-shrink</code></p><p>如果空间不足，1缩小，0不缩小</p></li><li><p><code>flex-basis</code></p><p>  基础大小</p></li><li><p><code>flex</code></p><p><code>[flex-grow][flex-shrink][flex-basis]</code></p></li><li><p><code>align-self</code></p><p>与其他项目不一样的对齐方式,参考<code>[align-item]</code></p></li></ul><ol><li><p>圣杯布局</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:burlywood&quot;</span>&gt;</span>header<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 按照顺序渲染，如果需提前修改元素order属性，越小越优先 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:chocolate&quot;</span>&gt;</span>nav<span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:blueviolet&quot;</span>&gt;</span>main<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aside</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:cadetblue&quot;</span>&gt;</span>aside<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:darkslateblue&quot;</span>&gt;</span>footer<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs css">*&#123;  <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;&#125;<span class="hljs-selector-tag">body</span>&#123;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100vh</span>;  <span class="hljs-comment">/* 垂直方向 */</span>  <span class="hljs-attribute">flex-direction</span>: column;&#125;<span class="hljs-selector-tag">header</span>,<span class="hljs-selector-tag">footer</span>&#123;  <span class="hljs-comment">/* 6em 为本身的固定宽度 */</span>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">6em</span>;&#125;<span class="hljs-selector-class">.body</span>&#123;  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;  <span class="hljs-attribute">display</span>: flex;&#125;<span class="hljs-selector-class">.body</span> <span class="hljs-selector-tag">nav</span>,<span class="hljs-selector-class">.body</span> <span class="hljs-selector-tag">aside</span>&#123;  <span class="hljs-comment">/* 10em 为本身的固定宽度 */</span>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10em</span>;&#125;<span class="hljs-selector-class">.body</span> <span class="hljs-selector-tag">main</span>&#123;  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>&#125;</code></pre></div></li><li><p>固定的底栏</p><div class="hljs code-wrapper"><pre><code class="hljs css">*&#123;  <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;&#125;<span class="hljs-selector-tag">body</span>&#123;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-comment">/* 改变flex朝向 */</span>  <span class="hljs-attribute">flex-direction</span>:column;  <span class="hljs-comment">/* 占满视口高度 */</span> &lt;----------------  <span class="hljs-attribute">min-height</span>:<span class="hljs-number">100vh</span>;&#125;<span class="hljs-selector-tag">header</span>&#123;  <span class="hljs-attribute">height</span>:<span class="hljs-number">30px</span>;  <span class="hljs-attribute">background</span>: blue;&#125;<span class="hljs-selector-tag">main</span>&#123;  <span class="hljs-comment">/* 主题内容填满剩余空间 */</span>  <span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span>&#125;<span class="hljs-selector-tag">footer</span>&#123;  <span class="hljs-attribute">background</span>:black;&#125;</code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML面试题</title>
    <link href="/2021/04/13/html%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2021/04/13/html%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="HTML5-新特性"><a href="#HTML5-新特性" class="headerlink" title="HTML5 新特性"></a>HTML5 新特性</h2><h3 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h3><ul><li><p>纯表现的元素/可以用css实现的元素：<code>basefont</code>，<code>big</code>，<code>center</code>，<code>font</code>, <code>s</code>，<code>strike</code></p></li><li><p>对可用性产生负面影响的元素：<code>frame</code>，<code>frameset</code>，<code>noframes</code>；</p></li></ul><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><ul><li><p>拖拽API </p></li><li><p><code>canvas</code> 画布和内联 <code>svg</code></p></li><li><p><code>audio/video</code> 音视频元素</p></li><li><p>语意化更好的标签，比如<code>header,nav,section,article,footer,aside</code></p></li><li><p>表单校验API</p></li><li><p>增强了<code>input</code>类型:<code>color,date,url,time,tel,range</code></p></li><li><p>新的表单元素:<code>datalist,progress,meter</code></p></li><li><p><code>manifest</code>web应用离线缓存</p></li><li><p>地理定位<code>Geolocation</code> API</p></li><li><p><code>webworker</code>将JS计算交给后台线程</p></li><li><p><code>websocket</code>全双工的支持服务端推送的持久化连接协议</p></li><li><p>webStorage：<code>localStorage sessionStorage</code></p></li><li><p><code>history</code></p></li></ul><h3 id="HTML5-哪些标签可以做-SEO-优化"><a href="#HTML5-哪些标签可以做-SEO-优化" class="headerlink" title="HTML5 哪些标签可以做 SEO 优化"></a>HTML5 哪些标签可以做 SEO 优化</h3><p><code>title、meta、header、footer、nav、article、aside</code></p><h3 id="meta标签的作用"><a href="#meta标签的作用" class="headerlink" title="meta标签的作用"></a>meta标签的作用</h3><ul><li>charset 字符编码</li><li>关键词seo优化 </li><li>适用与移动设备的viewport scale页面缩放</li><li>dns预解析</li><li>csp内容安全策略</li></ul><h3 id="link和-import和src"><a href="#link和-import和src" class="headerlink" title="link和@import和src"></a><code>link</code>和<code>@import</code>和<code>src</code></h3><ul><li><code>src</code>指向外部资源的位置，该资源会被嵌入src所在位置，浏览器会在此处暂停其他资源的下载</li><li><code>link</code>引入css，icon，定义RSS等。与页面加载同时进行。</li><li><code>@import</code>只能引入样式表。页面加载完后才下载。可能会有兼容问题</li><li>同样引入css，link权重较高<h3 id="HTML5-的离线存储"><a href="#HTML5-的离线存储" class="headerlink" title="HTML5 的离线存储"></a>HTML5 的离线存储</h3></li></ul><p>在用户没有联网时，可以正常访问站点或应用；在联网的情况下，更新用户机器上的缓存文件。</p><p>如何使用：<br>1、页面头部加入一个 manifest 的属性<br>2、在 cache.manifest 文件的编写离线存储的资源<br>3、在离线状态下，操作 window.applicationCache 进行需求实现</p><h4 id="浏览器是如何对-HTML5-的离线存储资源进行管理和加载的"><a href="#浏览器是如何对-HTML5-的离线存储资源进行管理和加载的" class="headerlink" title="浏览器是如何对 HTML5 的离线存储资源进行管理和加载的"></a>浏览器是如何对 HTML5 的离线存储资源进行管理和加载的</h4><ul><li><p>在线的情况下，浏览器发现 HTML 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，浏览器会根据 manifest 文件的内容下载相应的资源并且进行离线存储。</p></li><li><p>如果已经访问过 app，并且资源已经离线存储，浏览器会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件，如果文件没有发生改变，就不做任何操作，否则就会重新下载文件中的资源并进行离线存储。</p></li><li><p>离线的情况下，浏览器直接使用离线存储的资源。</p></li></ul><h3 id="严格模式和混杂模式"><a href="#严格模式和混杂模式" class="headerlink" title="严格模式和混杂模式"></a>严格模式和混杂模式</h3><ul><li>严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。</li><li>混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以 防止站点无法工作</li></ul><h3 id="超链接访问过后-hover-样式就不出现了"><a href="#超链接访问过后-hover-样式就不出现了" class="headerlink" title="超链接访问过后 hover 样式就不出现了"></a>超链接访问过后 hover 样式就不出现了</h3><p>被点击访问过的超链接样式不在具有 hover 和 active 了解决方法是改变 CSS 属性排列顺序: <code>L-V-H-A</code></p><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;&#125;<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;&#125;<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;&#125;<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;&#125;</code></pre></div><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><blockquote><p>概念<br>HTML 文档中的每个元素都使用一个矩形盒子来描述其占用空间，这个模型称为盒模型。盒模型包含四个区域：<code>margin</code>（外边距），<code>border</code>（边框），<code>padding</code>（内边距），<code>content</code>（内容区域</p></blockquote><h3 id="行内元素和块级元素"><a href="#行内元素和块级元素" class="headerlink" title="行内元素和块级元素"></a>行内元素和块级元素</h3><h4 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h4><p><code>display inline</code></p><ol><li><p>和其他元素在同一行内</p></li><li><p>行内元素不能设置 width、height、margin、padding</p></li><li><p>默认高度和宽度就是内容的高度和宽度</p></li><li><p>可以设置 margin-left 和 margin-right 属性，无法设置 margin-top 和 margin-bottom 属性</p></li><li><p>border 和 padding 可以设置，但是 border-top 和 padding-top 到页面顶部后就不再增加</p></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript">img; <span class="hljs-comment">//可以设置宽高</span>span;lable;strong;a;input; <span class="hljs-comment">//可以设置宽高</span>select; <span class="hljs-comment">//可以设置宽高</span>textarea; <span class="hljs-comment">//可以设置宽高</span></code></pre></div><h4 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h4><p><code>display block</code></p><ol><li><p>独占一行</p></li><li><p>可以设置 width，height，margin，padding，border 属性</p></li><li><p>默认宽度是容器的 100%</p></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript">artical; <span class="hljs-comment">// h5</span>div;header; <span class="hljs-comment">// h5</span>section; <span class="hljs-comment">// h5</span>adress; <span class="hljs-comment">// h5</span>ol;ul;aside; <span class="hljs-comment">// h5</span>footer; <span class="hljs-comment">// h5</span>audio; <span class="hljs-comment">// h5</span>video; <span class="hljs-comment">// h5</span>canvas; <span class="hljs-comment">// h5</span>hgroup; <span class="hljs-comment">// h5</span>p;h1 - h6;table;form;</code></pre></div><ul><li>行内块级元素<br><code>display line-block</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 兼容</span>div &#123;    display： inline-block；    zoom： <span class="hljs-number">1</span>；   <span class="hljs-comment">//在IE下触发hasLayout</span>    display：inline；<span class="hljs-comment">//一旦触发了hasLayout设置display：inline和display：block效果相似。</span>&#125;</code></pre></div><ol><li>不自动换行</li><li>识别宽高</li><li>左向右排列</li></ol><h3 id="优雅降级和渐进增强"><a href="#优雅降级和渐进增强" class="headerlink" title="优雅降级和渐进增强"></a>优雅降级和渐进增强</h3><p>_优雅降级_：Web 站点在所有新式浏览器中都能正常工作，如果用户使用的是旧式浏览器，则代码会针对旧版本的 IE 进行降级处理，使之在旧式浏览器上以某种形式降级体验而不至于完全不能使用。</p><p>_渐进增强_：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能，向页面增加不影响基础浏览器的额外样式和功能。当浏览器支持时，它们会自定地呈现出来并发挥作用。</p><h3 id="常见空-VOID-元素"><a href="#常见空-VOID-元素" class="headerlink" title="常见空 VOID 元素"></a>常见空 VOID 元素</h3><p><code>br、hr、img、input、link、meta</code></p><h3 id="window-onload-和-DOMContentLoaded-的区别"><a href="#window-onload-和-DOMContentLoaded-的区别" class="headerlink" title="window.onload 和 DOMContentLoaded 的区别"></a>window.onload 和 DOMContentLoaded 的区别</h3><p><code>window.onload</code>页面的全部资源加载完<br><code>DOMContentLoaded</code>纯HTML加载完</p><h3 id="visibilityState-有哪些用途"><a href="#visibilityState-有哪些用途" class="headerlink" title="visibilityState 有哪些用途"></a>visibilityState 有哪些用途</h3><p>通过<code>visibilityState</code>的值检测页面当前是否可见，以及打开页面的时间等<br>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放</p><h3 id="标准模型和-IE-模型"><a href="#标准模型和-IE-模型" class="headerlink" title="标准模型和 IE 模型"></a>标准模型和 IE 模型</h3><ul><li>通过[box-sizing]设置</li><li>标准模型[content-box]的宽和高只计算 content 部分</li><li>ie 模型[border-box]的宽高包括 padding 和 border</li></ul><h3 id="获取-DOM-元素的-style"><a href="#获取-DOM-元素的-style" class="headerlink" title="获取 DOM 元素的 style"></a>获取 DOM 元素的 style</h3><ol><li><code>dom.style.width/height</code>content 只能获取内联样式</li><li><code>dom.currentStyle.width/height</code>// 只支持ie</li><li><code>window.getComputedStyle(ele).width/height</code></li><li><code>offsetHeight</code>// content+padding+border + 滚动条</li><li><code>offsetTop//Left</code>//相较于offsetParent的偏移 margin+position</li><li><code>clientHeight</code>// content+padding - 滚动条</li><li><code>scrollHeight</code>// 没有滚动条时等于clientHeight</li><li><code>scrollTop</code>// 滚动像素数</li></ol><p>// 滚动到底</p><blockquote><p>ele.scrollHeight - ele.scrollTop === ele.clientHeight</p></blockquote><h3 id="边距重叠"><a href="#边距重叠" class="headerlink" title="边距重叠"></a>边距重叠</h3><p>两个或多个块级盒子的!!垂直!!相邻边界会重合，它们的边界宽度是相邻边界宽度中的最大值。<br>特别注意内容为空的盒子。</p><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>Block Formatting Context 块级格式化上下文,是常规流式布局中一个决定块级盒子布局及浮动相互影响的一个区域，拥有与普通盒模型不同的特性。</p><h3 id="BFC特性"><a href="#BFC特性" class="headerlink" title="BFC特性"></a>BFC特性</h3><ul><li><p>BFC内盒子竖向排列</p></li><li><p>BFC内盒子之间会发生margin合并</p></li><li><p>BFC内浮动元素参与高度计算（高度塌陷）</p></li><li><p>BFC内盒子不会超出BFC边界（浮动覆盖）</p><h3 id="下列方式会创建BFC："><a href="#下列方式会创建BFC：" class="headerlink" title="下列方式会创建BFC："></a>下列方式会创建BFC：</h3><ul><li>根元素<code>HTML</code></li><li>浮动元素（元素的 <code>float</code> 不是 <code>none</code>）</li><li>定位元素（元素的 <code>position</code> 为 <code>absolute</code> 或 <code>fixed</code></li><li><code>overflow</code> 值不为 <code>visible</code> 的块元素</li><li><code>display</code> 值为 <code>flow-root</code> 的元素</li><li>行内块元素（元素的 <code>display</code> 为 <code>inline-block</code></li><li>弹性元素（<code>display</code> 为 <code>flex</code> 或 <code>inline-flex</code> 元素的直接子元素）</li><li>网格元素（<code>display</code> 为 <code>grid</code> 或 <code>inline-grid</code> 元素的直接子元素）</li><li>表格有关（<code>display</code> 为 <code>table``table-row``table-row-group``table-header-group``table-footer-group</code>）</li></ul></li></ul><p>[MDN] <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context</a> “块格式化上下文”</p><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><ul><li>用父元素伪类清除浮动</li></ul><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-comment">/* 通用 */</span><span class="hljs-selector-class">.clearfather</span>:after &#123;  content: <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-attribute">clear</span>: both;  <span class="hljs-attribute">display</span>: block;  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">overflow</span>: hidden;  <span class="hljs-attribute">visibility</span>: hidden;&#125;<span class="hljs-selector-class">.clearfather</span> &#123;  *zoom: <span class="hljs-number">1</span>; <span class="hljs-comment">/* ie6/7 */</span>&#125;</code></pre></div><ul><li>空 div 清除浮动</li></ul><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-class">.clearfloat</span> &#123;  <span class="hljs-attribute">clear</span>: both;&#125;</code></pre></div><ul><li>父元素 BFC</li></ul><p>设置能触发 BFC 的属性均可</p><h3 id="页面导入样式时，使用-link-和-import-有什么区别"><a href="#页面导入样式时，使用-link-和-import-有什么区别" class="headerlink" title="页面导入样式时，使用 link 和@import 有什么区别"></a>页面导入样式时，使用 link 和@import 有什么区别</h3><ul><li><p>link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务；@import 属于 CSS 范畴，只能加载 CSS。</p></li><li><p>link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载。</p></li><li><p>link 是 XHTML 标签，无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器（IE5 以下）不支持。</p></li><li><p>link 支持使用 Javascript 控制 DOM 去改变样式；而@import 不支持。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面性能优化</title>
    <link href="/2021/04/13/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2021/04/13/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> imgList = [...document.querySelectAll(<span class="hljs-string">&#x27;img&#x27;</span>)]<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyLoad</span>(<span class="hljs-params">imgList</span>)</span>&#123;  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>  <span class="hljs-keyword">const</span> len = imgList.length  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">let</span> doneList = []    imgList.forEach(<span class="hljs-function">(<span class="hljs-params">img,index</span>)=&gt;</span>&#123;      <span class="hljs-keyword">const</span> react = img.getBoundingClientRect()      <span class="hljs-comment">// Element.getBoundingClientRect() 方法返回元素的大小及其相对于视口的位置</span>      <span class="hljs-comment">// 返回值是一个 DOMRect 对象，这个对象是由该元素的 getClientRects() 方法返回的一组矩形的集合，就是该元素的 CSS 边框大小。返回的结果是包含完整元素的最小矩形，并且拥有left, top, right, bottom, x, y, width, 和 height这几个以像素为单位的只读属性用于描述整个边框。</span>      <span class="hljs-keyword">if</span>(react.top&lt;<span class="hljs-built_in">window</span>.innerHeight)&#123;        img.src = img.dataset.src        doneList.push(index)        count++        <span class="hljs-keyword">if</span>(count === len)&#123;          <span class="hljs-built_in">document</span>.removeEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>,lazyLoad)        &#125;      &#125;    &#125;)    imgList = imgList.filter(<span class="hljs-function">(<span class="hljs-params">img,index</span>)=&gt;</span>!doneList.includes(i))  &#125;&#125;<span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>,debounce(lazyLoad))<span class="hljs-comment">// 加上节流</span></code></pre></div><h2 id="非核心代码异步加载"><a href="#非核心代码异步加载" class="headerlink" title="非核心代码异步加载"></a>非核心代码异步加载</h2><ul><li><p>异步加载的方式</p><ol><li>动态创建script标签，window.onload加入页面</li><li>script<code>defer</code></li><li>script<code>async</code></li></ol></li><li><p>script/script async/script defer的区别</p><ul><li>普通的<code>script</code>，html解析暂停，立即下载和执行这个脚本</li><li><code>&lt;script async&gt;</code>，html解析和该脚本的加载同时进行，下载完后执行脚本时暂停html解析</li><li><code>&lt;script defer&gt;</code>，html解析和该脚本的加载同时进行，脚本在页面解析完成后才执行</li></ul><p>  <img src="../images/script.png" alt="script"></p></li></ul><h2 id="预解析DNS"><a href="#预解析DNS" class="headerlink" title="预解析DNS"></a>预解析DNS</h2><p><code>DNS Prefetch</code> 是一种DNS 预解析技术，当浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在单击当前网页中的连接时就无需进行DNS的解析，减少用户等待时间，提高用户体验。</p><ol><li><p>http中浏览器会对a标签自动开启dns预解析</p></li><li><p>https用meta信息来告知浏览器, 当前页面要做DNS预解析:</p></li></ol><blockquote><p>对于https页面，大部分浏览器是关闭a标签的dns预解析的</p></blockquote><p><code>&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;</code></p><ol start="2"><li>在页面header中使用link标签来强制对DNS预解析:</li></ol><p><code> &lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://bdimg.share.baidu.com&quot; /&gt;</code></p><h2 id="预渲染和服务端渲染"><a href="#预渲染和服务端渲染" class="headerlink" title="预渲染和服务端渲染"></a>预渲染和服务端渲染</h2><ul><li><code>SSR:server side render</code></li><li><code>prerender-spa-plugin</code>不适用于个性化的，内容变化大，多路由的页面<br>可以用来优化单页应用</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js运行机制</title>
    <link href="/2021/04/13/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/2021/04/13/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/10714ad38f9a">ref:javascript 运行机制 EventLoop</a></p><h2 id="JS的单线程"><a href="#JS的单线程" class="headerlink" title="JS的单线程"></a>JS的单线程</h2><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。</p><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><ul><li><p>概括：主线程不断从任务队列读取任务进入执行栈执行的循环过程</p></li><li><p>因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。如果遇到了异步任务，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。</p></li><li><p>任务队列可以分为宏任务对列和微任务对列，当‘当前’执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务队列中的任务。</p></li><li><p>事件循环的运行</p><ol><li>循环开始，整体函数script推入执行栈</li><li>执行执行栈中同步函数</li><li>遇到异步函数将其回调分别加入<em>宏任务队列</em>和<em>微任务队列</em></li><li>执行栈为空后（同步函数执行完），查看任务队列里微任务推入执行栈执行</li><li>执行完后，读取宏任务进入执行栈执行</li><li>执行该宏任务，如果该宏任务继续产生微任务则执行完微任务才能继续往下执行<br>blahblahblah。。。</li></ol></li></ul><h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><ul><li>setTimeout/setInterval<blockquote><p>需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行</p></blockquote><ul><li>DOM事件(onclick,onload)</li><li>Promise</li></ul></li></ul><h2 id="微任务-宏任务"><a href="#微任务-宏任务" class="headerlink" title="微任务/宏任务"></a>微任务/宏任务</h2><ul><li><p>不同的异步任务被分为两类：微任务（<code>micro task</code>）和宏任务（<code>macro task</code>）</p></li><li><p>JS的事件循环中每个宏任务称为一个<code>Tick</code>(标记)，在每个标记的末尾会追加一个微任务队列，一个宏任务执行完后会执行所有的微任务，直到队列清空。</p></li><li><p>微任务包括 <code>process.nextTick</code> ，<code>promise.then</code> ，<code>catch</code>,<code>finally</code> ，<code>MutationObserver</code></p><ul><li>！遇到<code>nextTick</code>会提到微任务的栈顶</li></ul></li><li><p>宏任务包括 <code>整体代码script</code> ， <code>setTimeout</code> ，<code>setInterval</code> ，<code>setImmediate</code> ，<code>I/O</code>操作 ，<code>UI</code>渲染</p></li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// js执行顺序</span><span class="hljs-comment">// 1</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;script start&quot;</span>);  <span class="hljs-comment">// 1</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;setTimeout&quot;</span>);<span class="hljs-comment">// 4</span>&#125;, <span class="hljs-number">0</span>);<span class="hljs-built_in">Promise</span>.resolve()  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise1&quot;</span>);<span class="hljs-comment">//2</span>  &#125;)  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise2&quot;</span>);<span class="hljs-comment">//3</span>  &#125;);<span class="hljs-comment">// 2</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//1</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span>);<span class="hljs-comment">// 5</span>  process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3&quot;</span>);<span class="hljs-comment">//7</span>  &#125;);  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;4&quot;</span>);<span class="hljs-comment">//6</span>    resolve();  &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;5&quot;</span>);<span class="hljs-comment">//8</span>  &#125;);&#125;);process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;6&quot;</span>); <span class="hljs-comment">//3</span>&#125;);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;7&quot;</span>); <span class="hljs-comment">//2</span>  resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;8&quot;</span>); <span class="hljs-comment">//4</span>&#125;);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;9&quot;</span>); <span class="hljs-comment">//9</span>  process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;10&quot;</span>); <span class="hljs-comment">//11</span>  &#125;);  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;11&quot;</span>); <span class="hljs-comment">//10</span>    resolve();  &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;12&quot;</span>);  &#125;);<span class="hljs-comment">//12</span>&#125;);<span class="hljs-comment">// 3</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>) <span class="hljs-comment">//1</span>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<span class="hljs-comment">//2</span>  &#125;)  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;异步3&#x27;</span>)<span class="hljs-comment">//6</span>  &#125;)  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;同步3&#x27;</span>)<span class="hljs-comment">//3</span>&#125;<span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">()=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)<span class="hljs-comment">//5</span>&#125;)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>)<span class="hljs-comment">//7</span>&#125;)async1()<span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>)<span class="hljs-comment">//4</span></code></pre></div><ol><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;定时器开始啦&#x27;</span>)&#125;);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;马上执行for循环啦&#x27;</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;        i == <span class="hljs-number">99</span> &amp;&amp; resolve();    &#125;&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;执行then函数啦&#x27;</span>)&#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;代码执行结束&#x27;</span>);<span class="hljs-comment">// 马上执行for循环啦</span><span class="hljs-comment">// 代码执行结束</span><span class="hljs-comment">// 执行then函数啦</span><span class="hljs-comment">// 定时器开始啦</span></code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);&#125;)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise&#x27;</span>);    resolve()&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;then&#x27;</span>);&#125;)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;console&#x27;</span>);<span class="hljs-comment">// promise</span><span class="hljs-comment">// console</span><span class="hljs-comment">// then</span><span class="hljs-comment">// setTimeout</span></code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// console.log(&#x27;2&#x27;);</span>    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);    &#125;)    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;        <span class="hljs-comment">// console.log(&#x27;4&#x27;);</span>        resolve();    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5&#x27;</span>)    &#125;)&#125;)process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>);&#125;)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;7&#x27;</span>);    resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;8&#x27;</span>)&#125;)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;10&#x27;</span>);    &#125;)    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;        resolve();    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;12&#x27;</span>)    &#125;)&#125;)</code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>) &#125;,<span class="hljs-number">0</span>)<span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">()=&gt;</span>&#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>) &#125;)<span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>) <span class="hljs-comment">// 3 2</span><span class="hljs-comment">// 1</span></code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>) &#125;,<span class="hljs-number">0</span>)<span class="hljs-keyword">let</span> a=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)    resolve()&#125;).then(<span class="hljs-function">()=&gt;</span>&#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>) &#125;).then(<span class="hljs-function">()=&gt;</span>&#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>) &#125;)<span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>) <span class="hljs-comment">// 2 5 3 4</span><span class="hljs-comment">// 1</span></code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)  resolve()  &#125;).then(<span class="hljs-function">()=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>)  &#125;)  a.then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)  &#125;)  a.then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)  &#125;)<span class="hljs-comment">// 2 5 3 4</span></code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise1&quot;</span>)    resolve()&#125;).then(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then11&quot;</span>)    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise2&quot;</span>)        resolve()    &#125;).then(<span class="hljs-function">()=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then21&quot;</span>)    &#125;).then(<span class="hljs-function">()=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then23&quot;</span>)     &#125;)&#125;).then(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then12&quot;</span>)&#125;)<span class="hljs-comment">// promise1,then11,promise2,then21,then12,then23</span></code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise1&quot;</span>)    resolve()&#125;).then(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then11&quot;</span>)     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise2&quot;</span>)        resolve()    &#125;).then(<span class="hljs-function">()=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then21&quot;</span>)     &#125;).then(<span class="hljs-function">()=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then23&quot;</span>)     &#125;)&#125;).then(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then12&quot;</span>)  &#125;)<span class="hljs-comment">// promise1 then11  promise2 then21 then12  then23</span></code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise1&quot;</span>)      resolve()&#125;).then(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then11&quot;</span>)      <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise2&quot;</span>)          resolve()    &#125;).then(<span class="hljs-function">()=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then21&quot;</span>)      &#125;).then(<span class="hljs-function">()=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then23&quot;</span>)      &#125;)&#125;).then(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then12&quot;</span>)  &#125;)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise3&quot;</span>)      resolve()&#125;).then(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then31&quot;</span>)  &#125;)<span class="hljs-comment">//promise1 promise3 then11 promise2 then31 then21 then12 then23</span></code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;async1 start&quot;</span>);    <span class="hljs-keyword">await</span>  async2();    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;async1 end&quot;</span>);&#125;<span class="hljs-keyword">async</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&#x27;async2&#x27;</span>);&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;script start&quot;</span>);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;settimeout&quot;</span>);&#125;,<span class="hljs-number">0</span>);async1();<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise1&quot;</span>);    resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise2&quot;</span>);&#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script end&#x27;</span>);<span class="hljs-comment">// script start,async1 start,async2,promise1,script end,async1 end,promise2</span><span class="hljs-comment">// settimeout</span></code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;async1 start&quot;</span>);    <span class="hljs-keyword">await</span>  async2();    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;async1 end&quot;</span>);&#125;<span class="hljs-keyword">async</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&#x27;async2&#x27;</span>);&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;script start&quot;</span>);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;settimeout&quot;</span>);&#125;);async1()<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise1&quot;</span>);    resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise2&quot;</span>);&#125;);setImmediate(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;setImmediate&quot;</span>)&#125;)process.nextTick(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;process&quot;</span>)&#125;)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script end&#x27;</span>); <span class="hljs-comment">//script start,async1 start,async2,promise1,script end,process,async1 end,promise2</span><span class="hljs-comment">//sttimeout,setImmediate</span></code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js面试题集</title>
    <link href="/2021/04/13/js%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    <url>/2021/04/13/js%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<ul><li>向 setTimeout 传参</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func1</span>(<span class="hljs-params">name</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    alert(name + <span class="hljs-string">&quot;最帅&quot;</span>);  &#125;;&#125;<span class="hljs-keyword">var</span> n1 = func1(<span class="hljs-string">&quot;刘德华&quot;</span>);<span class="hljs-built_in">setTimeout</span>(n1, <span class="hljs-number">1000</span>);<span class="hljs-comment">//使用setTimeout第三个参数</span><span class="hljs-built_in">setTimeout</span>(  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123;    alert(name);  &#125;,  <span class="hljs-number">2000</span>,  <span class="hljs-string">&quot;周杰伦&quot;</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(i);  &#125;, i * <span class="hljs-number">1000</span>);&#125; <span class="hljs-comment">// 每一秒钟输出一个6</span><span class="hljs-comment">// 6 6 6 6 6</span><span class="hljs-comment">//</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(i);  &#125;, i * <span class="hljs-number">1000</span>);&#125; <span class="hljs-comment">// let创建块级作用域</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;  <span class="hljs-built_in">setTimeout</span>(    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">j</span>) </span>&#123;      <span class="hljs-built_in">console</span>.log(j);    &#125;,    i * <span class="hljs-number">1000</span>,    i  );&#125; <span class="hljs-comment">//使用setTimeout第三个参数</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;  (<span class="hljs-function">(<span class="hljs-params">j</span>) =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(j);    &#125;, <span class="hljs-number">1000</span> * j);  &#125;)(i);&#125;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;setTimeout&quot;</span>);&#125;);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promishe&quot;</span>);&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then&quot;</span>);&#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;console&quot;</span>);<span class="hljs-comment">//执行结果</span><span class="hljs-comment">//promise</span><span class="hljs-comment">//console</span><span class="hljs-comment">//then</span><span class="hljs-comment">//setTimeout</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span>);&#125;);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span>);  resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3&quot;</span>);&#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;4&quot;</span>);<span class="hljs-comment">//2</span><span class="hljs-comment">//4</span><span class="hljs-comment">//3</span><span class="hljs-comment">//1</span><span class="hljs-comment">//then是Promise的微任务,new Promise</span></code></pre></div><ul><li>instance of</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">instance_of</span>(<span class="hljs-params">l, r</span>) </span>&#123;  <span class="hljs-keyword">let</span> r = r.prototype;  <span class="hljs-keyword">let</span> l = <span class="hljs-built_in">Object</span>.getPrototypeOf(l);  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;    <span class="hljs-keyword">if</span> (l === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (o === l) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    l = <span class="hljs-built_in">Object</span>.getPrototypeOf(l); <span class="hljs-comment">// 一直到有结果return</span>  &#125;&#125;</code></pre></div><ul><li>手写 new<br>new 操作:<ul><li>创建一个空对象</li><li>将空对象连接上构造函数的原型</li><li>将 this 指向新对象，执行构造函数</li><li>如果该函数没有返回对象，则返回 this</li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_new</span>(<span class="hljs-params">func, ...args</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> func !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;first argument must be a function&quot;</span>);  &#125;  <span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.create(func.prototype);  <span class="hljs-comment">//Object.create(proto)等效于</span>  <span class="hljs-comment">//let O = &#123;&#125;</span>  <span class="hljs-comment">//O.__proto__ = proto</span>  <span class="hljs-comment">//return O</span>  <span class="hljs-keyword">const</span> res = func.apply(obj, args);  <span class="hljs-keyword">if</span> (res !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&quot;function&quot;</span> || <span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&quot;object&quot;</span>)) &#123;    <span class="hljs-keyword">return</span> res;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> obj;  &#125;&#125;<span class="hljs-comment">//or</span><span class="hljs-keyword">const</span> isComplexType = <span class="hljs-function">(<span class="hljs-params">func</span>) =&gt;</span>  (<span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;function&quot;</span>) &amp;&amp; obj !== <span class="hljs-literal">null</span>;<span class="hljs-keyword">const</span> _new = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">func, ...args</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> func !== <span class="hljs-string">&quot;function&quot;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;err&quot;</span>;  <span class="hljs-keyword">const</span> instance = <span class="hljs-built_in">Object</span>.create(func.prototype);  <span class="hljs-keyword">const</span> res = func.apply(instance, args);  <span class="hljs-keyword">return</span> isComplexType(res) ? res : instance;&#125;;</code></pre></div><ul><li>实现一个Object.create<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">Object</span>._create = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proto,propertyObj</span>)</span>&#123;  <span class="hljs-comment">// propertyObj</span>  <span class="hljs-comment">// 要定义其可枚举属性或修改的属性描述符的对象</span>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">&#x27;function&#x27;</span> || <span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">&#x27;object&#x27;</span>)&#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(proto+<span class="hljs-string">&#x27;should be an object&#x27;</span>)  &#125;  <span class="hljs-keyword">if</span>(propertyObj &amp;&amp; (<span class="hljs-keyword">typeof</span> propertyObj === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> propertyObj !== <span class="hljs-string">&#x27;object&#x27;</span>))&#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;cant convert null to object&#x27;</span>)  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fn</span>(<span class="hljs-params"></span>)</span>&#123;&#125;  Fn.prototype = proto  <span class="hljs-keyword">const</span> newObj = <span class="hljs-keyword">new</span> Fn()  <span class="hljs-keyword">if</span>(propertyObj !== <span class="hljs-literal">undefined</span>)&#123;    <span class="hljs-built_in">Object</span>.definedProperty(newObj,propertyObj)  &#125;  <span class="hljs-keyword">if</span>(proto === <span class="hljs-literal">null</span>)&#123;    newObj.__proto__ = <span class="hljs-literal">null</span>  &#125;  <span class="hljs-keyword">return</span> newObj&#125;)</code></pre></div></li></ul><ul><li>手写防抖/节流</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 防抖</span><span class="hljs-comment">// 多次触发最后一次执行</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func,wait,immediate = <span class="hljs-literal">true</span>,...args1</span>)</span>&#123;  <span class="hljs-comment">// 有立即执行选项</span>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span> ｜｜ <span class="hljs-keyword">typeof</span> delay !== <span class="hljs-string">&#x27;number&#x27;</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span> (<span class="hljs-string">&#x27;bad args&#x27;</span>)  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>  <span class="hljs-keyword">const</span> _debounce = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args2</span>)</span>&#123;    <span class="hljs-keyword">if</span>(timer)&#123;      <span class="hljs-built_in">clearTimeout</span>(timer)      timer = <span class="hljs-literal">null</span>    &#125;    <span class="hljs-keyword">if</span>(immediate &amp;&amp; !timer)&#123;      fn.apply(<span class="hljs-built_in">this</span>,[...args1,...args2])      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-literal">null</span>,delay)    &#125;<span class="hljs-keyword">else</span>&#123;      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;        fn.apply(<span class="hljs-built_in">this</span>,args)        <span class="hljs-built_in">clearTimeout</span>(timeout)        timer = <span class="hljs-literal">null</span>      &#125;,delay)    &#125;  &#125;  _debounce.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">clearTimeout</span>(timer)    timer = <span class="hljs-literal">null</span>  &#125;  <span class="hljs-keyword">return</span> _debounce&#125;<span class="hljs-comment">// 节流</span><span class="hljs-comment">// 连续触发限制定时间隔执行</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">func, wait, tail,...args1</span>) </span>&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span> ｜｜ <span class="hljs-keyword">typeof</span> delay !== <span class="hljs-string">&#x27;number&#x27;</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span> (<span class="hljs-string">&#x27;bad args&#x27;</span>)  <span class="hljs-comment">// tail = true wait结束后执行</span>  <span class="hljs-comment">// tail = false 满足条件立即执行</span>  <span class="hljs-keyword">let</span> timeout,pre = <span class="hljs-number">0</span>  <span class="hljs-keyword">const</span> _throttle = <span class="hljs-function">(<span class="hljs-params">...args2</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(tail)&#123;      <span class="hljs-keyword">if</span>(timeout) <span class="hljs-keyword">return</span>      timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;        func.apply(<span class="hljs-built_in">this</span>,[...args1,...args2])        <span class="hljs-built_in">clearTimeout</span>(timeout)        timeout = <span class="hljs-literal">null</span>      &#125;,wait)    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-keyword">let</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()      <span class="hljs-keyword">if</span>(now-pre&gt;wait)&#123;        func.apply(<span class="hljs-built_in">this</span>,[...args1,...args2])        pre = now      &#125;    &#125;  &#125;  _throttle.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">clearTimeout</span>(timeout)    timeout = <span class="hljs-literal">null</span>  &#125;  <span class="hljs-keyword">return</span> _throttle&#125;<span class="hljs-keyword">const</span> f1 = throttle(<span class="hljs-function">()=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>),<span class="hljs-number">3000</span>,<span class="hljs-literal">false</span>)<span class="hljs-built_in">setInterval</span>(f1, <span class="hljs-number">1000</span>);</code></pre></div><ul><li>计算数组中元素出现的次数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>];<span class="hljs-comment">//reduce</span><span class="hljs-keyword">let</span> countArr = arr.reduce(<span class="hljs-function">(<span class="hljs-params">obj, i</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> obj) &#123;    obj[i]++;  &#125; <span class="hljs-keyword">else</span> &#123;    obj[i] = <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">return</span> obj;&#125;, &#123;&#125;);<span class="hljs-comment">// &#123; &#x27;1&#x27;: 2, &#x27;2&#x27;: 2, &#x27;3&#x27;: 2, &#x27;4&#x27;: 4 &#125;</span><span class="hljs-comment">// 循环</span><span class="hljs-keyword">let</span> obj = &#123;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> arr) &#123;  <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> obj) &#123;    obj[i]++;  &#125; <span class="hljs-keyword">else</span> &#123;    obj[i] = <span class="hljs-number">1</span>;  &#125;&#125;</code></pre></div><ul><li>call/bind/apply 区别</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = &#123;  sing: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg1, arg2</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;笨小孩&quot;</span> + <span class="hljs-built_in">this</span>.name);    <span class="hljs-built_in">console</span>.log(arg1 + arg2);  &#125;,&#125;;<span class="hljs-keyword">const</span> b = &#123;  name: <span class="hljs-string">&quot;刘德华&quot;</span>,&#125;;<span class="hljs-keyword">const</span> c = &#123;  name: <span class="hljs-string">&quot;张学友&quot;</span>,&#125;;a.sing();<span class="hljs-comment">//笨小孩undefined</span><span class="hljs-comment">// NaN</span>a.sing.call(b, <span class="hljs-number">666</span>, <span class="hljs-number">888</span>);<span class="hljs-comment">// call后一个一个传args</span><span class="hljs-comment">// 笨小孩刘德华</span><span class="hljs-comment">// 1554</span>a.sing.apply(c, [<span class="hljs-number">666</span>, <span class="hljs-number">888</span>]);<span class="hljs-comment">// apply第二个参数[]</span><span class="hljs-comment">// 笨小孩刘德华</span><span class="hljs-comment">// 1554</span><span class="hljs-keyword">let</span> d = a.sing.bind(b, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">// bind返回函数不执行，传参数方式和call一样</span>d();<span class="hljs-comment">//call是apply的语法糖</span></code></pre></div><ul><li>限制并发</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 线程池</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncPool</span>(<span class="hljs-params">limit, arr, func</span>) </span>&#123;  <span class="hljs-keyword">let</span> i = o;  <span class="hljs-keyword">const</span> ret = []; <span class="hljs-comment">// 所有任务</span>  <span class="hljs-keyword">const</span> executing = []; <span class="hljs-comment">// 运行中</span>  <span class="hljs-keyword">const</span> enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">if</span> (array.length === <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve();    &#125;    <span class="hljs-keyword">const</span> item = arr[i++];    <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> func(item));    ret.push(p);    <span class="hljs-comment">//</span>    executing.push(e);    <span class="hljs-comment">//</span>    <span class="hljs-keyword">const</span> e = p.then(<span class="hljs-function">() =&gt;</span> executing.splice(executing.indexOf(e), <span class="hljs-number">1</span>)); <span class="hljs-comment">// 自己resolve后从并发池中删除</span>    <span class="hljs-keyword">let</span> r = <span class="hljs-built_in">Promise</span>.resolve();    <span class="hljs-keyword">if</span> (executing.length &gt;= limit) &#123;      r = <span class="hljs-built_in">Promise</span>.race(executing);      <span class="hljs-comment">//使用race，并发池中只要有一个promise返回resolve，则继续调用enqueue方法添加新的进去</span>    &#125;    <span class="hljs-keyword">return</span> r.then(<span class="hljs-function">() =&gt;</span> enqueue());  &#125;;  <span class="hljs-keyword">return</span> enqueue().then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">Promise</span>.all(ret));&#125;</code></pre></div><ul><li>实现重试功能</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">retry</span>(<span class="hljs-params">fn, interval, limit</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attempt</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> fn());      p.then(resolve).catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (limit-- &lt;= <span class="hljs-number">1</span>) &#123;          reject(<span class="hljs-string">&quot;run out of limit&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;            attempt();            <span class="hljs-built_in">clearTimeout</span>(timer);          &#125;, interval);        &#125;      &#125;);    &#125;    attempt();  &#125;);&#125;</code></pre></div><ul><li>浅拷贝</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//</span><span class="hljs-built_in">Object</span>.assign();<span class="hljs-comment">//展开运算符</span><span class="hljs-keyword">let</span> a = &#123;  age: <span class="hljs-number">1</span>,&#125;;<span class="hljs-keyword">let</span> b = &#123; ...a &#125;;a.age = <span class="hljs-number">2</span>;<span class="hljs-built_in">console</span>.log(b.age); <span class="hljs-comment">// 1</span>**只会对对象的表层属性进行拷贝，遇到复杂类型时只是拷贝了地址**</code></pre></div><ul><li>深拷贝</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(source))<span class="hljs-comment">//先JSON.stringify转成字符串，再JSON.parse把字符串转换成新的对象</span>**遇到<span class="hljs-built_in">Symbol</span>和函数则报错**</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 实现</span><span class="hljs-keyword">const</span> isObject = <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> obj !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;object&quot;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">source, map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) </span>&#123;  <span class="hljs-comment">//WeakMap 避免循环引用爆栈</span>  <span class="hljs-comment">// obj.o1 = obj  // boom</span>  <span class="hljs-keyword">if</span> (!isObject(source)) <span class="hljs-keyword">return</span> source  <span class="hljs-keyword">if</span> (map.has(source)) <span class="hljs-keyword">return</span> map.get(source);  <span class="hljs-keyword">const</span> _constructor = source.constructor;  <span class="hljs-keyword">if</span>(<span class="hljs-regexp">/RegExp|Date/</span>.test(_constructor))&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> _constructor(source)  &#125;  <span class="hljs-comment">// 正则和日期</span>  <span class="hljs-keyword">const</span> _new_ =    _constructor === <span class="hljs-built_in">Array</span> ? [] : &#123;&#125;  map.set(source, newObj);  <span class="hljs-built_in">Reflect</span>.ownKeys(source).forEach(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;    <span class="hljs-comment">// Reflect.ownKeys 方法返回一个由目标对象自身的属性键组成的数组。它的返回值等同于Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))。</span>    newObj[key] = deepClone(source[key], map);  &#125;);  <span class="hljs-keyword">return</span> _new;&#125;</code></pre></div><ul><li>for…in /for…of</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.method = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.length);&#125;;<span class="hljs-keyword">var</span> myArray = [<span class="hljs-string">&quot;1&quot;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;mmm&quot;</span> &#125;, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];myArray.name = <span class="hljs-string">&quot;数组&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> value <span class="hljs-keyword">of</span> myArray) &#123;  <span class="hljs-built_in">console</span>.log(value);&#125;<span class="hljs-comment">//1 &#123;name: &quot;mmm&quot;&#125; 3 4 5 6 7</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> index <span class="hljs-keyword">in</span> myArray) &#123;  <span class="hljs-built_in">console</span>.log(myArray[index]);&#125;<span class="hljs-comment">//1 2 3 4 5 6 7 数组 ƒ () &#123;</span><span class="hljs-comment">//  console.log(this.length);</span><span class="hljs-comment">//&#125;</span></code></pre></div><ul><li>阻止冒泡和默认事件</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopBubble</span>(<span class="hljs-params">e</span>) </span>&#123;  <span class="hljs-keyword">if</span> (e &amp;&amp; e.stopPropagation) &#123;    e.stopPropagation();  &#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">window</span>.event.cancelBubble = <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopDefault</span>(<span class="hljs-params">e</span>) </span>&#123;  <span class="hljs-keyword">if</span> (e &amp;&amp; e.preventDefault) e.preventDefault();  <span class="hljs-keyword">else</span> <span class="hljs-built_in">window</span>.event.returnValue = <span class="hljs-literal">false</span>;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre></div><ul><li>let/const/var</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// JavaScript 变量提升 var声明会提前（声明不是赋值）</span><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// undefined</span><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 报错</span><span class="hljs-built_in">console</span>.log(c); <span class="hljs-comment">// 报错</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> c = <span class="hljs-number">3</span>;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 1</span></code></pre></div><ul><li>手写 call/apply/bind</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype._call = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;must call a function&quot;</span>);  context = context || <span class="hljs-built_in">window</span>;  <span class="hljs-keyword">const</span> caller = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;caller&quot;</span>);  context[caller] = <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">let</span> result = context[caller](...args);  <span class="hljs-keyword">delete</span> context[caller];  <span class="hljs-keyword">return</span> result;&#125;;<span class="hljs-built_in">Function</span>.prototype._apply = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, args</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;must apply a function&quot;</span>);  context = context || <span class="hljs-built_in">window</span>;  <span class="hljs-keyword">const</span> caller = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;caller&quot;</span>);  context[caller] = <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">let</span> result = context[caller](...args);  <span class="hljs-keyword">delete</span> context[caller];  <span class="hljs-keyword">return</span> result;&#125;;<span class="hljs-comment">// 返回一个原函数的拷贝，并拥有指定的this值和初始参数。</span><span class="hljs-built_in">Function</span>.prototype._bind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args1</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;must bind a function&quot;</span>);  <span class="hljs-keyword">const</span> originFn = <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">const</span> notBFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;  <span class="hljs-keyword">const</span> boundFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args2</span>) </span>&#123;    <span class="hljs-keyword">return</span> originFn.apply(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> originFn ? <span class="hljs-built_in">this</span> : context, [      <span class="hljs-comment">// 如果绑定函数被new调用</span>      <span class="hljs-comment">// 则this指向new obj的this</span>      ...args1,      ...args2,    ]);  &#125;;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.prototype) &#123;    notBFn.prototype = <span class="hljs-built_in">this</span>.prototype;  &#125;  boundFn.prototype = <span class="hljs-keyword">new</span> notBFn();  <span class="hljs-comment">// boundFn.prototype = Object.create(this.prototype)</span>  <span class="hljs-comment">// 使用notBFn间接连接boundFn和originFn原型链</span>  <span class="hljs-keyword">return</span> boundFn;&#125;;</code></pre></div><ul><li>手动实现一个继承</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">///////最完美办法</span><span class="hljs-comment">// 1.call</span><span class="hljs-comment">// 2.Object.create</span><span class="hljs-comment">// 3.原型的构造器指向自己</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">this</span>.type = <span class="hljs-string">&quot;human&quot;</span>;  <span class="hljs-built_in">this</span>.eat = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我肚子饿了&quot;</span>);  &#125;;&#125;Person.prototype.live = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;吃饭睡觉打豆豆&quot;</span>);&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Avenger</span>(<span class="hljs-params">name</span>) </span>&#123;  Person.call(<span class="hljs-built_in">this</span>);  <span class="hljs-built_in">this</span>.name = name;&#125;Avenger.prototype = <span class="hljs-built_in">Object</span>.create(Person.prototype);Avenger.prototype.constructor = Avenger;<span class="hljs-keyword">let</span> hulk = <span class="hljs-keyword">new</span> Avenger(<span class="hljs-string">&quot;HULK&quot;</span>);hulk.live();<span class="hljs-comment">// 吃饭睡觉打豆豆</span>其他方法：<span class="hljs-comment">// - 借用构造函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Avenger</span>(<span class="hljs-params">name</span>)</span>&#123;  Person.call(<span class="hljs-built_in">this</span>,name)  <span class="hljs-built_in">this</span>.name = name&#125;<span class="hljs-comment">// 只能继承构造函数上属性</span><span class="hljs-comment">// 2. 原型继承</span>Avenger.prototype = <span class="hljs-keyword">new</span> Person()<span class="hljs-comment">// 子类实例共享原型中的引用类型数据</span><span class="hljs-comment">// 不能传参</span><span class="hljs-comment">// 3.组合继承 1+2</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Avenger</span>(<span class="hljs-params">name</span>)</span>&#123;  Person.call(<span class="hljs-built_in">this</span>,name)  <span class="hljs-built_in">this</span>.name = name&#125;Avenger.prototype = <span class="hljs-keyword">new</span> Person()<span class="hljs-comment">// 实例构造函数会指向父类的构造函数</span><span class="hljs-comment">// 父类构造函数执行多次</span><span class="hljs-comment">// 4. 原型式继承</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Avenger</span>(<span class="hljs-params">name</span>)</span>&#123;    Person.call(<span class="hljs-built_in">this</span>,name)    <span class="hljs-built_in">this</span>.name = name&#125;Avenger.prototype = Person.prototype<span class="hljs-comment">// 子类实例构造函数会指向父类的构造函数</span><span class="hljs-comment">// 分不清实例是谁构造的</span><span class="hljs-comment">// 5. 寄生继承</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Avenger</span>(<span class="hljs-params">name</span>)</span>&#123;    Person.call(<span class="hljs-built_in">this</span>,name)    <span class="hljs-built_in">this</span>.name = name&#125;Avenger.prototype = <span class="hljs-built_in">Object</span>.create(Person.prototype)<span class="hljs-comment">// Object.create() 创造的中间对象的原型对象就是传入的参数</span><span class="hljs-comment">// 此时中间对象的原型也就是父类的原型</span><span class="hljs-comment">// 中间对象通过类似在原型链上“加一段”的方式把父子类的构造器隔开</span><span class="hljs-comment">// 6. 寄生组合</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Avenger</span>(<span class="hljs-params">name</span>)</span>&#123;    Person.call(<span class="hljs-built_in">this</span>,name)    <span class="hljs-built_in">this</span>.name = name&#125;Avenger.prototype = <span class="hljs-built_in">Object</span>.create(Person.prototype)Avenger.prototype.constructor = Avenger<span class="hljs-comment">//   再把构造器指向自己，完成自己的链</span></code></pre></div><ul><li>手动实现一个迭代器</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createIterator</span>(<span class="hljs-params">array</span>) </span>&#123;  <span class="hljs-keyword">let</span> nextIndex = <span class="hljs-number">0</span>;  <span class="hljs-keyword">return</span> &#123;    next: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">return</span> nextIndex &lt; array.length        ? &#123; <span class="hljs-attr">value</span>: array[nextIndex++], <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;        : &#123; <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;    &#125;,    [<span class="hljs-built_in">Symbol</span>.iterator]: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;    &#125;,  &#125;;&#125;<span class="hljs-keyword">var</span> i1 = createIterator([<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">21</span>, <span class="hljs-number">6</span>]);<span class="hljs-built_in">console</span>.log(i1.next()); <span class="hljs-comment">// &#123;value:4,done:false&#125;</span></code></pre></div><ul><li><p>for 循环实现遍历方法</p><ul><li><p>for 循环实现 forEach</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._forEach = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);  &#125;  thisArg = thisArg || <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasOwnProperty(i)) &#123;      callback.call(thisArg, <span class="hljs-built_in">this</span>[i], i, <span class="hljs-built_in">this</span>);    &#125;  &#125;&#125;;</code></pre></div></li><li><p>for 循环实现 map</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._map = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);  &#125;  <span class="hljs-keyword">const</span> result = [];  thisArg = thisArg || <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasOwnProperty(i)) &#123;      result[i] = callback.call(thisArg, <span class="hljs-built_in">this</span>[i], i, <span class="hljs-built_in">this</span>);    &#125;  &#125;  <span class="hljs-keyword">return</span> result;&#125;;</code></pre></div></li><li><p>for 循环实现 filter</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._filter_ = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);  &#125;  <span class="hljs-keyword">const</span> result = [];  thisArg = thisArg || <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasOwnProperty(i)) &#123;      <span class="hljs-keyword">if</span> (callback.call(thisArg, <span class="hljs-built_in">this</span>[i], i, <span class="hljs-built_in">this</span>)) &#123;        result.push(<span class="hljs-built_in">this</span>[i]);      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> result;&#125;;</code></pre></div></li><li><p>for 循环实现 some</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._some = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);  &#125;  thisArg = thisArg || <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasOwnProperty(i)) &#123;      <span class="hljs-keyword">if</span> (callback.call(thisArg, <span class="hljs-built_in">this</span>[i], i, <span class="hljs-built_in">this</span>)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;</code></pre></div></li><li><p>for 循环实现 every</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._every = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);  &#125;  thisArg = thisArg || <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasOwnProperty(i)) &#123;      <span class="hljs-keyword">if</span> (!callback.call(thisArg, <span class="hljs-built_in">this</span>[i], i, <span class="hljs-built_in">this</span>)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;</code></pre></div></li><li><p>for 循环实现 reduce</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._reduce = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, initialValue</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);  &#125;  <span class="hljs-keyword">let</span> res;  <span class="hljs-keyword">let</span> initialIndex = <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span> (!initialValue) &#123;    <span class="hljs-keyword">for</span> (; initialIndex &lt; <span class="hljs-built_in">this</span>.length; initialIndex++) &#123;      <span class="hljs-comment">// 未指定初始值则自行查找第一个非空下标</span>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasOwnProperty(initialIndex)) &#123;        res = <span class="hljs-built_in">this</span>[i];        <span class="hljs-keyword">break</span>;      &#125;    &#125;  &#125; <span class="hljs-keyword">else</span> &#123;    res = initialValue;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = initialIndex + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">this</span>.length; j++) &#123;    res = callback.call(<span class="hljs-literal">null</span>, res, <span class="hljs-built_in">this</span>[j], j, <span class="hljs-built_in">this</span>);  &#125;  <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div></li></ul></li><li><p>reduce 实现遍历方法</p><ul><li>reduce 实现 forEach</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._forEach = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);  &#125;  <span class="hljs-built_in">this</span>.reduce(<span class="hljs-function">(<span class="hljs-params">pre, acc, index</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> [...pre, callback.call(thisArg, acc, index, <span class="hljs-built_in">this</span>)];  &#125;, []);&#125;;</code></pre></div><ul><li>reduce 实现 map</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//加上return</span></code></pre></div><ul><li>reduce 实现 filter</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._filter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback,thisArg</span>)</span>&#123;  ...  ...  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.reduce(<span class="hljs-function">(<span class="hljs-params">pre,acc</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> callback.call(thisArg,acc,index,<span class="hljs-built_in">this</span>)?[...pre,cur]:[...pre]  &#125;,[])&#125;</code></pre></div></li><li><p>实现 object.assign</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> isComplexType = <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span>  (<span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;function&quot;</span>) &amp;&amp; obj !== <span class="hljs-literal">null</span>;<span class="hljs-keyword">const</span> selfAssign = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, ...source</span>) </span>&#123;  <span class="hljs-keyword">if</span> (!target) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;need assign target&#x27;</span>);  <span class="hljs-keyword">return</span> source.reduce(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> acc;    <span class="hljs-keyword">if</span> (!isComplexType(acc)) acc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(acc);    <span class="hljs-built_in">Reflect</span>.ownKeys(cur).forEach(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;      acc[key] = cur[key];    &#125;);    <span class="hljs-keyword">return</span> acc;  &#125;, target);&#125;;</code></pre></div><ul><li>手动实现 typeof</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> selfTypeof = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;  <span class="hljs-keyword">const</span> ret = <span class="hljs-built_in">Object</span>.prototype.toString.call(obj);  <span class="hljs-keyword">return</span> ret.slice(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>).toLowercase();&#125;;</code></pre></div><ul><li>手动实现 instanceof</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> selfInstanceof = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">left, right</span>) </span>&#123;  <span class="hljs-keyword">let</span> _proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(left);  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;    <span class="hljs-keyword">if</span> (_proto === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (_proto === right.prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    _proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(_proto);  &#125;&#125;;</code></pre></div><ul><li><p>二维数组的所有排列组合</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">let</span> len = arr.length;  <span class="hljs-keyword">if</span> (len &gt;= <span class="hljs-number">2</span>) &#123;    <span class="hljs-keyword">let</span> len1 = arr[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">let</span> len2 = arr[<span class="hljs-number">1</span>].length;    <span class="hljs-keyword">let</span> lenBoth = len1 * len2;    <span class="hljs-keyword">let</span> items = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(lenBoth);    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len1; i++) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; len2; j++) &#123;        items[index] = [].concat(arr[<span class="hljs-number">0</span>][i]).concat(arr[<span class="hljs-number">1</span>][j]);        index++;      &#125;    &#125;    <span class="hljs-keyword">let</span> newArr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len - <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; len; i++) &#123;      newArr[i - <span class="hljs-number">1</span>] = arr[i];    &#125;    newArr[<span class="hljs-number">0</span>] = items;    <span class="hljs-keyword">return</span> exchange(newArr);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];  &#125;&#125;</code></pre></div></li><li><p>属性名表达式</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">10</span> &#125;;<span class="hljs-keyword">let</span> b = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">10</span> &#125;;<span class="hljs-keyword">let</span> obj = &#123;  a: <span class="hljs-number">10</span>,&#125;;obj[b] = <span class="hljs-number">20</span>;<span class="hljs-built_in">console</span>.log(obj[a]); <span class="hljs-comment">// 20</span><span class="hljs-comment">//obj.b和obj[b]的不同</span>obj[需要是已经声明的变量名]obj.则不受限制obj.c = <span class="hljs-number">20</span> ===&gt; obj:&#123;<span class="hljs-attr">c</span>:<span class="hljs-number">20</span>,<span class="hljs-attr">a</span>:<span class="hljs-number">10</span>&#125;obj[c] <span class="hljs-comment">//报错</span><span class="hljs-comment">//原题中obj[b]后打印得到</span>obj = &#123;  a:<span class="hljs-number">10</span>,  <span class="hljs-string">&#x27;[object:object]&#x27;</span> : <span class="hljs-number">20</span>  <span class="hljs-comment">//b = &#123; b: 10 &#125; ===&gt; &#x27;[object:object]&#x27;</span>&#125;后再访问obj[a]时也就是访问obj[<span class="hljs-string">&#x27;[object:object]&#x27;</span>] = <span class="hljs-number">20</span></code></pre></div><ul><li>this 的指向</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">20</span>,  say: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);  &#125;,&#125;;obj.say();<span class="hljs-comment">// 打印出10的方法</span><span class="hljs-comment">// 1</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">20</span>,  say: <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);  &#125;,&#125;;obj.say();<span class="hljs-comment">// 2</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">20</span>,  say: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);  &#125;,&#125;;<span class="hljs-keyword">let</span> say = obj.say;say();<span class="hljs-comment">// 3</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">20</span>,  say: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);  &#125;,&#125;;obj.say.call(<span class="hljs-built_in">this</span>);</code></pre></div><ul><li>js 执行顺序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// js执行顺序</span><span class="hljs-comment">// 1</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;script start&quot;</span>); <span class="hljs-comment">// 1</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;setTimeout&quot;</span>); <span class="hljs-comment">// 4</span>&#125;, <span class="hljs-number">0</span>);<span class="hljs-built_in">Promise</span>.resolve()  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise1&quot;</span>); <span class="hljs-comment">//2</span>  &#125;)  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise2&quot;</span>); <span class="hljs-comment">//3</span>  &#125;);<span class="hljs-comment">// 2</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//1</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span>); <span class="hljs-comment">// 5</span>  process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3&quot;</span>); <span class="hljs-comment">//7</span>  &#125;);  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;4&quot;</span>); <span class="hljs-comment">//6</span>    resolve();  &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;5&quot;</span>); <span class="hljs-comment">//8</span>  &#125;);&#125;);process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;6&quot;</span>); <span class="hljs-comment">//3</span>&#125;);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;7&quot;</span>); <span class="hljs-comment">//2</span>  resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;8&quot;</span>); <span class="hljs-comment">//4</span>&#125;);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;9&quot;</span>); <span class="hljs-comment">//9</span>  process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;10&quot;</span>); <span class="hljs-comment">//11</span>  &#125;);  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;11&quot;</span>); <span class="hljs-comment">//10</span>    resolve();  &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;12&quot;</span>);  &#125;); <span class="hljs-comment">//12</span>&#125;);<span class="hljs-comment">// 3</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>); <span class="hljs-comment">//1</span>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>); <span class="hljs-comment">//2</span>  &#125;);  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;异步3&quot;</span>); <span class="hljs-comment">//6</span>  &#125;);  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;同步3&quot;</span>); <span class="hljs-comment">//3</span>&#125;<span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>); <span class="hljs-comment">//5</span>&#125;);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>); <span class="hljs-comment">//7</span>&#125;);async1();<span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>); <span class="hljs-comment">//4</span></code></pre></div><ul><li>设置最大请求次数的请求函数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myRequest</span>(<span class="hljs-params">url,body,successCallback,errorCallback,maxCount</span>)</span>&#123;  <span class="hljs-keyword">return</span> fetch(url,body).then(<span class="hljs-function"><span class="hljs-params">response</span>=&gt;</span>successCallback(response)).catch(<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;    <span class="hljs-keyword">if</span>(maxCount&lt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> errorCallback(<span class="hljs-string">&#x27;请求超时&#x27;</span>)    <span class="hljs-keyword">return</span> myRequest(url,body,successCallback,errorCallback,--maxCount)  &#125;)&#125;myRequest(<span class="hljs-string">&#x27;http://test/aaa&#x27;</span>,&#123;           method: <span class="hljs-string">&#x27;GET&#x27;</span>,           headers: myHeaders,           mode: <span class="hljs-string">&#x27;cors&#x27;</span>,           cache: <span class="hljs-string">&#x27;default&#x27;</span> &#125;           ,successCallback,errorCallback,<span class="hljs-number">10</span>)&lt;!-- <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myRequest2</span>(<span class="hljs-params">params,successCallback,errorCallback,maxCount</span>)</span>&#123;  <span class="hljs-keyword">return</span> axios(params)  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> successCallback(response))&#125;  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(maxCount&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> errorCallback(<span class="hljs-string">&#x27;请求超时&#x27;</span>)    <span class="hljs-keyword">return</span> myRequest2(params,successCallback,errorCallback,--maxCount)  &#125;) --&gt;</code></pre></div><ul><li>js 执行优先级</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>&#123;  getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);  &#125;;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;&#125;Foo.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);&#125;;Foo.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);&#125;;<span class="hljs-keyword">var</span> getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>);&#125;Foo.getName();getName();Foo().getName();<span class="hljs-comment">// function changeThis()&#123;</span><span class="hljs-comment">//   return this</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// changeThis().fn666 = ()=&gt;&#123;</span><span class="hljs-comment">//   console.log(666);</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// global.fn666()</span>getName();<span class="hljs-keyword">new</span> Foo.getName();<span class="hljs-keyword">new</span> Foo().getName();<span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> Foo().getName();</code></pre></div><ul><li>实现一个 setTimeout</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_setTimeout</span>(<span class="hljs-params">cb, timeout, ...args</span>) </span>&#123;  <span class="hljs-keyword">const</span> start = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();  <span class="hljs-keyword">let</span> timer, now;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span>(<span class="hljs-params"></span>) </span>&#123;    timer = <span class="hljs-built_in">window</span>.requestAnimationFrame(loop);    now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();    <span class="hljs-keyword">if</span> (now - start &gt;= timeout) &#123;      cb.apply(<span class="hljs-built_in">this</span>, args);      <span class="hljs-built_in">window</span>.cancelAnimationFrame(timer);    &#125;  &#125;  <span class="hljs-built_in">window</span>.requestAnimationFrame(loop);&#125;</code></pre></div><ul><li>使用 setTimeout 模拟 setInterval</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// setInterval 的问题</span><span class="hljs-comment">// 定时往事件队列中添加回调函数，如果主线程运行时间过长到大量回调超时，则有可能同时执行大量异步回调，违背使用意图</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_setInterval</span>(<span class="hljs-params">fn,timeout,...args</span>)</span>&#123;  <span class="hljs-keyword">const</span> controller = &#123;    stop = <span class="hljs-literal">false</span>    <span class="hljs-comment">// 控制器</span>  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">interval</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">if</span>(!controller.stop)&#123;      fn.apply(<span class="hljs-built_in">this</span>,args)      <span class="hljs-built_in">setTimeout</span>(interval,timeout)    &#125;  &#125;  <span class="hljs-built_in">setTimeout</span>(interval,timeout)  <span class="hljs-keyword">return</span> controller&#125;</code></pre></div><ul><li>模版字符串</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\&#123;\&#123;(w+)\&#125;\&#125;/g</span>;<span class="hljs-keyword">const</span> template = <span class="hljs-string">&quot;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&quot;</span>;<span class="hljs-keyword">const</span> data = &#123;  name: <span class="hljs-string">&quot;森下上士&quot;</span>,  age: <span class="hljs-number">18</span>,&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">template, data</span>) </span>&#123;  <span class="hljs-keyword">if</span> (reg.test(template)) &#123;    <span class="hljs-keyword">const</span> tem = template.match(reg);    tem.forEach(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;      <span class="hljs-keyword">const</span> p = key.slice(<span class="hljs-number">2</span>, -<span class="hljs-number">2</span>);      <span class="hljs-comment">// &#123;&#123;xxx&#125;&#125; ==&gt; xxx</span>      template = template.replace(key, data[p]);    &#125;);  &#125;  <span class="hljs-keyword">return</span> template;&#125;</code></pre></div><ul><li>Ajax</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> request = <span class="hljs-function">(<span class="hljs-params">method,url,<span class="hljs-keyword">async</span>=<span class="hljs-literal">true</span>,data</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.readyState !== <span class="hljs-number">4</span>)<span class="hljs-keyword">return</span>      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.status === <span class="hljs-number">200</span>)&#123;        resolve(<span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">this</span>.response))      &#125;<span class="hljs-keyword">else</span>&#123;        reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-built_in">this</span>.statusText))      &#125;    &#125;    xhr.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;      reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;error&#x27;</span>))    &#125;    xhr.responseType = <span class="hljs-string">&#x27;json&#x27;</span>    xhr.setRequestHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)    <span class="hljs-keyword">if</span>(method===<span class="hljs-string">&#x27;GET&#x27;</span>)&#123;      xhr.open(<span class="hljs-string">&quot;GET&quot;</span>,url+<span class="hljs-string">&#x27;?&#x27;</span>+data,<span class="hljs-literal">true</span>)      xhr.send()    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(method === <span class="hljs-string">&quot;POST&quot;</span>)&#123;      xhr.setRequestHeader(<span class="hljs-string">&quot;Content-type&quot;</span>,<span class="hljs-string">&quot;application/x-www-form-urlencode&quot;</span>)      xhr.open(<span class="hljs-string">&#x27;POST&#x27;</span>,url)      xhr.send(<span class="hljs-built_in">encodeURIComponent</span>(data))    &#125;  &#125;)&#125;</code></pre></div><ul><li>数组随机排序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//方法一：</span><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randSort</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) &#123;    <span class="hljs-keyword">var</span> rand = <span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">Math</span>.random() * len);    <span class="hljs-keyword">var</span> temp = arr[rand];    arr[rand] = arr[i];    arr[i] = temp;  &#125;  <span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-comment">//方法二：</span><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randSort</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">var</span> mixedArray = [];  <span class="hljs-keyword">while</span> (arr.length &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">var</span> randomIndex = <span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">Math</span>.random() * arr.length);    mixedArray.push(arr[randomIndex]);    arr.splice(randomIndex, <span class="hljs-number">1</span>);  &#125;  <span class="hljs-keyword">return</span> mixedArray;&#125;<span class="hljs-comment">//方法三：</span><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>];arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random() - <span class="hljs-number">0.5</span>;&#125;);</code></pre></div><ul><li>js 获取文件扩展名</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getExt</span>(<span class="hljs-params">filename</span>) </span>&#123;  <span class="hljs-keyword">return</span> filename.split(<span class="hljs-string">&quot;.&quot;</span>).pop();&#125;<span class="hljs-comment">// 按.分割字符串为数组</span><span class="hljs-comment">// pop删除最后一项并返回</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getExt</span>(<span class="hljs-params">filename</span>) </span>&#123;  <span class="hljs-keyword">return</span> filename.replace(<span class="hljs-regexp">/.+\./</span>, <span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div><ul><li> 匿名函数自执行</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 直接在匿名函数之后加（）无效</span><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>])&#125;(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<span class="hljs-comment">//加号</span>+<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);&#125;(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//减号</span>-<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);&#125;(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//感叹号</span>!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);&#125;(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//括号</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);&#125;)(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);&#125;(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>));</code></pre></div><ul><li><p>实现一个sleep函数</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1 promise</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">delay</span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span>&#123;    <span class="hljs-built_in">setTimeout</span>(resolve,delay)  &#125;)&#125;<span class="hljs-comment">// 2 async</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">delay</span>)</span>&#123;  <span class="hljs-keyword">await</span> delay(delay)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delay</span>(<span class="hljs-params">delay</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span><span class="hljs-built_in">setTimeout</span>(resolve,delay))&#125;</code></pre></div></li><li><p>数组的全排列</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">permute</span>(<span class="hljs-params">arr</span>)</span>&#123;  <span class="hljs-keyword">const</span> res = []  <span class="hljs-comment">// 回溯算法</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recursion</span>(<span class="hljs-params">path,set</span>)</span>&#123;    <span class="hljs-keyword">if</span>(path.length===arr.length)&#123;      <span class="hljs-keyword">return</span> res.push(path.concat())    &#125;    <span class="hljs-comment">// 使用path记录回溯的路径</span>    <span class="hljs-comment">// [1,2,3,4]</span>    <span class="hljs-comment">// path[1,2]，set[1,2]</span>    <span class="hljs-comment">// 1,2,已经用过</span>    <span class="hljs-comment">// 分别遍历3，4</span>    <span class="hljs-comment">// 添加[1,2,3,4],[1,2,4,3]进结果</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> arr)&#123;      <span class="hljs-keyword">if</span>(set.has(num)) <span class="hljs-keyword">continue</span>      path.push(num)      set.add(num)      recursion(path,set)      path.pop()      set.delete(num)    &#125;  &#125;  recursion([],<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>())  <span class="hljs-keyword">return</span> res&#125;</code></pre></div></li><li><p>二分查找元素</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binaryFind</span>(<span class="hljs-params">arr,target,s=<span class="hljs-number">0</span>,e=arr.length-<span class="hljs-number">1</span></span>)</span>&#123;  <span class="hljs-keyword">const</span> i  = <span class="hljs-built_in">Math</span>.floor((s+e)/<span class="hljs-number">2</span>)  <span class="hljs-keyword">if</span>(arr[i]===target)&#123;    <span class="hljs-keyword">return</span> i  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[i]&gt;target)&#123;    <span class="hljs-keyword">return</span> binaryFind(arr,target,s,i-<span class="hljs-number">1</span>)  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[i]&lt;target)&#123;    <span class="hljs-keyword">return</span> binaryFind(arr,target,i+<span class="hljs-number">1</span>,e)  &#125;  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binaryFind2</span>(<span class="hljs-params">arr,target</span>)</span>&#123;  <span class="hljs-keyword">let</span> s = <span class="hljs-number">0</span>,e = arr.length-<span class="hljs-number">1</span>,mid  <span class="hljs-keyword">while</span>(s&lt;=e)&#123;    mid = <span class="hljs-built_in">Math</span>.floor((s+e)/<span class="hljs-number">2</span>)    <span class="hljs-keyword">if</span>(arr[mid] === target)&#123;      <span class="hljs-keyword">return</span> mid    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &gt; target)&#123;      e = mid - <span class="hljs-number">1</span>     &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &lt; target)&#123;      s = mid + <span class="hljs-number">1</span>    &#125;  &#125;  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>&#125;<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<span class="hljs-built_in">console</span>.log(binaryFind2(arr,<span class="hljs-number">9</span>));</code></pre></div><ul><li>扁平化转换<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 实现一个 fn 函数</span><span class="hljs-keyword">const</span> o = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, &#123; <span class="hljs-attr">c</span>: <span class="hljs-literal">true</span> &#125;], <span class="hljs-attr">d</span>: &#123; <span class="hljs-attr">e</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">f</span>: <span class="hljs-number">3</span> &#125;, <span class="hljs-attr">g</span>: <span class="hljs-literal">null</span> &#125;;<span class="hljs-comment">// fn(o) =&gt; 扁平化转换</span><span class="hljs-comment">// &#123; &quot;a&quot;: 1, &quot;b[0]&quot;: 1, &quot;b[1]&quot;: 2, &quot;b[2].c&quot;: true, &quot;d.e&quot;: 2, ... &#125;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectFlat</span>(<span class="hljs-params">obj</span>) </span>&#123;  <span class="hljs-keyword">const</span> res = &#123;&#125;;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat</span>(<span class="hljs-params">obj, path</span>) </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&quot;object&quot;</span>) &#123;      res[path] = obj;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(obj)) &#123;        <span class="hljs-keyword">const</span> cur = obj[key];          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(cur)) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; cur.length; i++) &#123;              flat(                cur[i],                path ? path + <span class="hljs-string">&quot;.&quot;</span> + key + <span class="hljs-string">&quot;[&quot;</span> + i + <span class="hljs-string">&quot;]&quot;</span> : key + <span class="hljs-string">&quot;[&quot;</span> + i + <span class="hljs-string">&quot;]&quot;</span>              );            &#125;          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj[key] === <span class="hljs-string">&quot;object&quot;</span>) &#123;            flat(cur, path ? path + <span class="hljs-string">&quot;.&quot;</span> + key : key);          &#125; <span class="hljs-keyword">else</span> &#123;            res[path ? path + <span class="hljs-string">&quot;.&quot;</span> + key : key] = cur;          &#125;      &#125;    &#125;  &#125;  flat(obj, <span class="hljs-string">&quot;&quot;</span>);  <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-built_in">console</span>.log(objectFlat(o));</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议</title>
    <link href="/2021/04/13/HTTP/"/>
    <url>/2021/04/13/HTTP/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP（HyperText-Transfer-Protocol，超文本传输协议"><a href="#HTTP（HyperText-Transfer-Protocol，超文本传输协议" class="headerlink" title="HTTP（HyperText Transfer Protocol，超文本传输协议"></a>HTTP（HyperText Transfer Protocol，超文本传输协议</h2><blockquote><p>HTTP 是基于 TCP/IP 协议的应用层协议，用于客户端和服务器之间的通信<br>链路层，网络层，传输层，应用层</p></blockquote><h3 id="HTTP-报文组成部分"><a href="#HTTP-报文组成部分" class="headerlink" title="HTTP 报文组成部分"></a>HTTP 报文组成部分</h3><ul><li><p>请求报文</p><ul><li>请求行 <code>Request Method</code>,<code>Request URL</code></li><li>请求头 包含若干属性，key:value 值</li><li>空行</li><li>请求体</li></ul></li><li><p>响应报文</p><ul><li>状态行 <code>Request Version</code>,<code>Status Code及其描述</code></li><li>响应头 包含若干属性，key:value 值</li><li>空行</li><li>响应体</li></ul></li></ul><h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><ul><li><p>缓存相关</p><ul><li><code>Cache-Control</code></li><li><code>Pragma</code></li><li><code>Expires</code>实体首部</li><li><code>Last-Modified</code>实体首部</li><li><code>If-Modified-Since</code></li><li><code>ETag</code></li><li><code>If-None-Match</code></li></ul></li><li><p>Cookie</p><ul><li><code>Cookie</code></li><li><code>Set-Cookie</code></li></ul></li><li><p>跨域</p><ul><li><code>Origin</code></li><li><code>Access-Control-Request-Method</code></li><li><code>Access-Control-Allow-Origin</code></li><li><code>Access-Control-Allow-Methods</code></li><li><code>Access-Control-Max-Age</code></li><li><code>Access-Control-Allow-Credentials</code></li></ul></li><li><p>连接</p><ul><li><code>Connection</code>:keep-alive / close / upgrade</li><li><code>Referer</code>请求发起URL<blockquote><p>这个单词是错的</p></blockquote></li><li><code>Host</code>服务器域名</li><li><code>Upgrade</code>:websocket<h4 id="HTTP-的响应状态码"><a href="#HTTP-的响应状态码" class="headerlink" title="HTTP 的响应状态码"></a>HTTP 的响应状态码</h4></li></ul></li></ul><p><code>1xx 请求收到</code>,</p><p><code>2xx 处理成功</code>,</p><p><code>3xx 重定向</code>,</p><p><code>4xx 处理发生错误，责任在客户端</code>,</p><p><code>5xx 处理发生错误，责任在服务端</code></p><h4 id="常见-code"><a href="#常见-code" class="headerlink" title="常见 code"></a>常见 code</h4><ul><li>100 继续发送</li><li>101 协议升级</li><li>200 OK</li><li>206 处理了部分请求</li><li></li><li>301 永久性重定向，资源已经分配了新的 URl</li><li>302 临时重定向</li><li>303 表示资源存在着另一个 URL，应使用 GET 方法获取资源<blockquote><p>对于 301/302/303 响应，几乎所有浏览器都会删除报文主体并自动用 GET 重新请求</p></blockquote></li><li>304 资源未修改</li><li></li><li>400 Bad Request请求报文语法错误</li><li>401 Unauthorized需要认证</li><li>403 Forbidden禁止访问</li><li>404 Not Found</li><li>405 不允许该请求方法</li><li>408 请求超时</li><li>500 服务器错误</li><li>503 服务器过载</li><li>505 不支持该版本HTTP协议</li></ul><h2 id="HTTP-发展"><a href="#HTTP-发展" class="headerlink" title="HTTP 发展"></a>HTTP 发展</h2><h3 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h3><ul><li><p>串行连接：每次通信完后断开TCP通道，每个新请求都需要建立新的连接</p></li><li><p><code>GET</code></p><ol><li>请求放在参数放在URL地址后</li><li>刷新无副作用</li><li>能保存书签，会被浏览器缓存，加入历史记录</li><li>编码urlencoded</li><li>参数数据类型限制为ASCII字符，浏览器或者服务器会对参数长度做限制</li></ol></li><li><p><code>POST</code></p><ol><li>请求参数放在body中</li><li>刷新提示再次提交？</li><li>不缓存不保存不记录</li><li>编码form-data，数据类型无限制</li></ol></li><li><p><code>HEAD</code> 与 get 相同的请求，不过只请求头部，获取其中“关于该资源的信息”(元信息或称元数据)</p><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3></li><li><p>持久连接：一定时间内，只要不是主动断开则保持连接，但是下一个请求必须等待上一个请求响应完成（线头阻塞）</p></li><li><p>管线化持久连接：请求/响应 打包处理，可以不用等待响应返回而发送下个请求并+按顺序返回响应+,只能用于GET和HEAD请求</p></li><li><p><code>OPTIONS</code>询问获取当前资源所支持的方法</p></li><li><p><code>PUT</code>从客户端向服务器传送新文件</p></li><li><p><code>PATCH</code>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</p></li><li><p><code>DELETE</code>请求服务器删除指定文件</p></li><li><p><code>TRACE</code>回显服务器收到的请求，主要用于测试或诊断。</p></li><li><p><code>CONNECT</code> HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</p></li></ul><h3 id="SPDY-协议"><a href="#SPDY-协议" class="headerlink" title="SPDY 协议"></a>SPDY 协议</h3><ul><li>2009 年推出</li></ul><blockquote><p>特性：</p></blockquote><ol><li><p>多路复用：通过一个 TCP 连接，可以无限制处理多个 HTTP 请求。</p></li><li><p>赋予请求优先级：给请求逐个分配优先级顺序。可以解决在发送多个请求时，因带宽低而导致响应变慢的问题。</p></li><li><p>压缩 HTTP 首部：压缩方式：DELEFT</p></li><li><p>服务端推送功能</p></li><li><p>服务器提示功能：服务器可以主动提示客户端请求所需的资源。</p></li><li><p>SPDY 位于 HTTP 下，TCP 和 SSL 之上，可以兼容老版本 http 同时使用可用的 ssl 功能</p></li></ol><blockquote><p>缺点：</p></blockquote><p>SPDY 强制使用 https。而且 SPDY 基本上只是将单个域名下的通信多路复用，所以当一个 web 网站上使用多个域名下的资源时，改善效果有限</p><h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><ul><li><p>2015 年发布，基于 SPDY 协议</p></li><li><p>http/1.x 是一个超文本协议，而 http2 是一个二进制协议</p></li></ul><blockquote><p>特性：</p></blockquote><ol><li><p>二进制格式传输数据</p><ul><li><p>1.X使用的文本格式传输数据</p></li><li><p>当客户端同时向服务端发起多个请求，那么这些请求会被分解成一一个的帧，每个帧都会在一个 TCP 链路中无序的传输，同一个请求的帧的 Stream Identifier 都是一样的。当帧到达服务端之后，就可以根据 Stream Identifier 来重新组合得到完整的请求。</p></li></ul></li><li><p>头部压缩</p><ul><li>请求和响应首部压缩</li><li>HPACK 算法，客户端和服务器建立字典（首部表）重复头部不用再发送</li></ul></li><li><p>服务端推送</p></li><li><p>多路复用</p><ul><li>同域名的通信都在单个连接上完成(只占用一个 tcp 连接</li><li>单连接可以承受任意数量的双向数据流</li></ul></li></ol><h3 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h3><ul><li>http3使用新的UDP协议<code>QUIC</code>代替TCP</li><li>解决http2时代丢包阻塞</li><li>切换网络时的连接保持（快速重启会话）</li><li>加密传输</li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="TLS-SSl"><a href="#TLS-SSl" class="headerlink" title="TLS/SSl"></a>TLS/SSl</h3><ul><li><p>传输层安全性协议（英语：Transport Layer Security，缩写作TLS），及其前身安全套接层（Secure Sockets Layer，缩写作SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。</p></li><li><p>TLS协议的特点是与应用层协议（HTTP，FTP）无耦合，应用层协议能透明运行在TLS协议上层（HTTP与TCP之间）</p></li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>【非对称加密】</p><p>只有使用私钥才能解开公钥加密</p></li><li><p>【摘要算法】</p><p>输出固定长度的数据，用来计算数据指纹，比如傻256</p></li><li><p>【数字签名】</p><p>  使用私钥对摘要算法得出的指纹加密</p><h3 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书</h3></li><li><p>证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号，摘要算法等信息的明文</p></li><li><p>CA使用CA私钥对证书明文摘要算法后得出的指纹进行签名</p></li></ul><h3 id="浏览器验证证书合法性"><a href="#浏览器验证证书合法性" class="headerlink" title="浏览器验证证书合法性"></a>浏览器验证证书合法性</h3><ol><li>从操作系统中找到相应的<code>CA机构证书</code></li><li>使用<code>CA证书</code>内置的公钥解密<code>站点证书</code>的签名得到校验码1</li><li>使用生产证书时相同的摘要算法对<code>站点证书</code>计算得到校验码2</li><li>比较两个校验码相同则说明证书没被篡改</li><li>后面就开始查看证书是否在有效期，是否对应当前域名，是否在吊销列表中</li></ol><h3 id="HTTPS-工作流程"><a href="#HTTPS-工作流程" class="headerlink" title="HTTPS 工作流程"></a>HTTPS 工作流程</h3><ol><li>用户访问:443</li><li>服务器返回证书</li><li>用户浏览器使用 <em><strong>CA公钥</strong></em> 打开并验证证书的合法性得到证书中的 <em><strong>服务器公钥</strong></em></li><li>用户生成 <em><strong>客户端私钥</strong></em>，并使用 <em><strong>服务器公钥</strong></em> 加密发送给服务器</li><li>服务器使用自己的 <em><strong>服务器私钥</strong></em> 解密，得到 <em><strong>客户端私钥</strong></em></li><li>至此双方得到了对称加密密钥</li></ol><h2 id="TCP握手"><a href="#TCP握手" class="headerlink" title="TCP握手"></a>TCP握手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ol><li>为了确保通信双方收发能力正常</li><li>指定自己的初始化序列号，为后面的可靠传送做准备</li><li>过程：<ul><li>第一次握手：<br>客户端给服务端发一个 <code>SYN</code> 报文，并指明客户端的初始化序列号 <code>ISN(c)</code>。此时客户端处于 <code>SYN_Send</code> 状态。</li><li>第二次握手：<br>服务器收到客户端的 <code>SYN</code> 报文之后，会以自己的 <code>SYN</code> 报文作为应答，并且也是指定了自己的初始化序列号 <code>ISN(s)</code>，同时会把客户端的 <code>ISN(c) + 1</code> 作为 <code>ACK(确认字符)</code> 的值，表示自己已经收到了客户端的 <code>SYN</code>，此时服务器处于 <code>SYN_REVD</code> 的状态。</li><li>第三次握手：<br>客户端收到 <code>SYN</code> 报文之后，会发送一个 <code>ACK</code> 报文，当然，也是一样把服务器的 <code>ISN(s) + 1</code> 作为 <code>ACK</code> 的值，表示已经收到了服务端的 <code>SYN</code> 报文，此时客户端处于 <code>establised</code> 状态。<blockquote><p>同时该tcp栈已经允许请求数据，例如同时带上一个GET请求</p></blockquote></li><li>服务器收到 ACK 报文之后，也处于 <code>establised</code> 状态，此时，双方以建立起了链接。</li></ul></li></ol><blockquote><p>半连接队列：<br>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。</p></blockquote><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ol><li>断开tcp连接</li><li>过程：<ul><li>第一次挥手：<br>客户端发送<code>FIN</code> 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</li><li>第二次握手：<br>服务端收到 <code>FIN</code> 之后，会把客户端的序列号值 + 1 作为 <code>ACK</code> 报文的序列号值并发送给客户端，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code>状态。</li><li>第三次挥手：<br>如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 <code>FIN</code> 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态。</li><li>第四次挥手：<br>客户端收到 FIN 之后，也把服务端的序列号值 + 1 作为自己 <code>ACK</code> 报文的序列号值并发送给服务端,此时客户端处于 <code>TIME_WAIT</code> 状态。之后才会进入 <code>CLOSED</code> 状态</li><li>服务端收到 <code>ACK</code> 报文之后，就处于关闭连接了，处于 <code>CLOSED</code> 状态。</li></ul></li></ol><blockquote><p><code>TIME_WAIT</code> 状态:<br>客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭,确保服务器是否已经收到了 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</p></blockquote><blockquote><p>也可缩短为三次挥手，上述二三步骤合并，服务器同时回复ACK和FIN</p></blockquote><h2 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h2><ul><li>websocket的出现解决了传统http请求只能由客户端发起的缺陷</li><li>http无法得知服务器连续的状态变化，只能靠轮询</li><li>构造函数就要传入<code>绝对URL</code></li><li>全双工，双向通信</li><li>服务端推送</li><li>持久连接</li><li>基于 TCP 传输，复用 HTTP 的握手通道</li><li>转协议<ol><li>客户端请求<div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">Connection:</span> Upgrade<span class="hljs-symbol">Upgrade:</span> websocket</code></pre></div></li><li>服务端响应协议升级<div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">101</span> Switching Protocols</code></pre></div></li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象</title>
    <link href="/2021/04/13/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/04/13/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="面向对象的设计思想"><a href="#面向对象的设计思想" class="headerlink" title="面向对象的设计思想"></a>面向对象的设计思想</h2><p>面向对象的设计思想是从自然界中来的，因为在自然界中就存在类（Class）和实例（Instance）的概念。</p><ul><li><p>Class 是一种抽象概念，比如我们定义的 Class——Student ，是指学生这个概念，</p></li><li><p>而实例（Instance）则是一个个具体的 Student ，比如， Michael 和 Bob 是两个具体的 Student 。</p></li><li><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</p></li><li><p>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p></li></ul><h2 id="面向对象三要素"><a href="#面向对象三要素" class="headerlink" title="面向对象三要素"></a>面向对象三要素</h2><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#%E5%B0%81%E8%A3%85">ref:https://github.com/CyC2018</a></p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p><p>优点：</p><ul><li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li><li>减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li><li>有效地调节性能：可以通过剖析确定哪些模块影响了系统的性能<br>提高软件的可重用性</li><li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</span><span class="hljs-comment">// 注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    private <span class="hljs-built_in">String</span> name;    private int gender;    private int age;    public <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    public <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getGender</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> gender == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;man&quot;</span> : <span class="hljs-string">&quot;woman&quot;</span>;    &#125;    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">work</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-number">18</span> &lt;= age &amp;&amp; age &lt;= <span class="hljs-number">50</span>) &#123;            System.out.println(name + <span class="hljs-string">&quot; is working very hard!&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(name + <span class="hljs-string">&quot; can&#x27;t work any more!&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p><ul><li><p>继承应该遵循里氏替换原则，子类对象必须能够替换掉父类对象。</p></li><li><p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型 。</p></li></ul><p><code>Animal animal = new Cat();</code></p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态分为编译时多态和运行时多态：</p><ul><li><p>编译时多态主要指方法的重载</p></li><li><p>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定<br>运行时多态有三个条件：</p><ol><li><p>继承</p></li><li><p>覆盖（重写）</p></li><li><p>向上转型</p></li></ol>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//  下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Instrument</span> </span>&#123;    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">play</span>(<span class="hljs-params"></span>)</span> &#123;        System.out.println(<span class="hljs-string">&quot;Instument is playing...&quot;</span>);    &#125;&#125;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wind</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Instrument</span> </span>&#123;    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">play</span>(<span class="hljs-params"></span>)</span> &#123;        System.out.println(<span class="hljs-string">&quot;Wind is playing...&quot;</span>);    &#125;&#125;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Percussion</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Instrument</span> </span>&#123;    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">play</span>(<span class="hljs-params"></span>)</span> &#123;        System.out.println(<span class="hljs-string">&quot;Percussion is playing...&quot;</span>);    &#125;&#125;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Music</span> </span>&#123;    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;        List&lt;Instrument&gt; instruments = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        instruments.add(<span class="hljs-keyword">new</span> Wind());        instruments.add(<span class="hljs-keyword">new</span> Percussion());        <span class="hljs-keyword">for</span>(Instrument instrument : instruments) &#123;            instrument.play();        &#125;    &#125;&#125;</code></pre></div><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2></li></ul><ol><li><code>JavaScript</code> 常被描述为一种基于原型的语言 (prototype-based language),每个对象拥有一个原型对象，对象以其原型为模板创建新对象、并从原型继承方法和属性。而这个原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为<code>原型链 (prototype chain)</code>，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</li></ol><ol><li><p>特殊的<code>Object</code>和<code>Function</code></p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数对象都是由Function函数生成的,则</span><span class="hljs-built_in">Object</span>._proto_ === <span class="hljs-built_in">Function</span>.prototype<span class="hljs-comment">//特例</span><span class="hljs-built_in">Function</span>.__proto__ ===  <span class="hljs-built_in">Function</span>.prototypeƒ () &#123; [native code] &#125;</code></pre></div></li><li><p>原形链的终点</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.prototye === <span class="hljs-string">&#x27;object&#x27;</span><span class="hljs-comment">// 说明他是一个object类型的对象，如果他是由Object函数生成的，</span><span class="hljs-comment">// 为了让原型链有终点。Javascript规定，</span><span class="hljs-built_in">Object</span>.prototype.__proto__ === <span class="hljs-literal">null</span><span class="hljs-comment">// 对于Function</span><span class="hljs-built_in">Function</span>.prototype.__proto__ === <span class="hljs-built_in">Object</span>.prototype<span class="hljs-built_in">Object</span>.prototype.__proto__ === <span class="hljs-literal">null</span></code></pre></div></li><li><p>只有函数才有<code>prototype</code></p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;&#125;f1.__proto__ === <span class="hljs-built_in">Function</span>.prototype <span class="hljs-comment">// f1直接由Function构造而来</span></code></pre></div></li><li><p>在传统的’面向对象‘中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到新实例中。在 JavaScript 中并不如此复制，而是在对象实例和它的构造器之间建立一个链接（它是__proto__属性，是从构造函数的prototype属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。</p></li></ol><div class="hljs code-wrapper"><pre><code>![proto](../images/proto.png)</code></pre></div><ul><li><p>当 js 在查找某属性时，对象本体上没有该属性则会访问对象的<code>__proto__</code>进行查找(即在该函数构造函数的<code>prototype</code>中查找)，还是没有则继续递归访问<code>__proto__</code>,一直到<code>Object</code>，【【【<code>Object.prototype</code>没有<code>__proto__</code>属性】】】，继续访问则返回<code>null</code>,这样一条由<code>__proto__</code>把所有对象链接起来的线成为原型链</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Function</span>.prototype)ƒ () &#123; [native code] &#125;<span class="hljs-built_in">console</span>.log(f1.__proto__)ƒ () &#123; [native code] &#125;<span class="hljs-comment">//    !!!!!!!!!</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Function</span>.prototype.__proto__ == f1.__proto__.__proto__)<span class="hljs-literal">true</span><span class="hljs-comment">// 实例继承自构造函数</span><span class="hljs-comment">// 函数继承自Function对象</span><span class="hljs-comment">// Function继承自Object对象</span><span class="hljs-comment">// 非函数对象</span><span class="hljs-keyword">const</span> o1 = &#123;&#125;o1.__proto__<span class="hljs-comment">// &#123;constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …&#125;</span>o1.__proto__ === <span class="hljs-built_in">Object</span>.prototype<span class="hljs-comment">// true</span>o1.__proto__.__proto__ = <span class="hljs-literal">null</span></code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVC/MVP/MVVM</title>
    <link href="/2021/04/13/mvcmvpmvvm/"/>
    <url>/2021/04/13/mvcmvpmvvm/</url>
    
    <content type="html"><![CDATA[<h3 id="MVCModel-View-Controller"><a href="#MVCModel-View-Controller" class="headerlink" title="MVCModel-View-Controller"></a>MVC<code>Model-View-Controller</code></h3><div class="hljs code-wrapper"><pre><code class="hljs js">View-&gt;Controller-&gt;Model^                     ||                     v&lt;---------------------&lt;</code></pre></div><ol><li><p>单向通信</p></li><li><p><code>Controller</code>只起到路由作用，业务逻辑都在<code>View</code>中</p></li><li><p>UI交互<code>View</code> 传送指令到 <code>Controller</code> ；</p></li><li><p><code>Controller</code> 完成业务逻辑后，操作 <code>Model</code> 改变数据 ；</p></li><li><p>Model通知 <code>View</code>更新，用户得到反馈。</p></li></ol><h3 id="MVPModel-View-Presenter"><a href="#MVPModel-View-Presenter" class="headerlink" title="MVPModel-View-Presenter"></a>MVP<code>Model-View-Presenter</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">View &lt;--&gt; Presenter &lt;==&gt; Model</code></pre></div><ol><li><p>双向通信</p></li><li><p><code>View</code> 与 <code>Model</code> 之间不通信，通过 <code>Presenter</code>解偶</p></li><li><p>主要的程序逻辑在<code>Presenter</code>中</p></li><li><p><code>View</code> 非常薄，不部署任何业务逻辑</p></li><li><p><em>Presenter与具体的View是没有直接关联的</em>，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变，这样就可以重用。</p></li></ol><h3 id="MVVMModel-View-ViewModel"><a href="#MVVMModel-View-ViewModel" class="headerlink" title="MVVMModel-View-ViewModel"></a>MVVM<code>Model-View-ViewModel</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">View &lt;==&gt; ViewModel &lt;==&gt; Model</code></pre></div><blockquote><p>mvvm模式将Presener改名为View Model，基本上与MVP模式一致，由框架代替开发者完成事件收集和view更新的工作</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组</title>
    <link href="/2021/04/13/%E6%95%B0%E7%BB%84/"/>
    <url>/2021/04/13/%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 字面量</span><span class="hljs-keyword">let</span> arr = []<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<span class="hljs-comment">// 构造函数</span><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>()<span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-regexp">/传入数组代表数组长度/</span>)<span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">&#x27;item1&#x27;</span>,<span class="hljs-string">&#x27;item2&#x27;</span>/传入元素/)<span class="hljs-keyword">let</span> arr = <span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>)/省略<span class="hljs-keyword">new</span>操作符/<span class="hljs-comment">// Array.of</span><span class="hljs-built_in">Array</span>.of(<span class="hljs-number">7</span>) 创建一个具有单个元素 <span class="hljs-number">7</span> 的数组，而<span class="hljs-built_in">Array</span>(<span class="hljs-number">7</span>) 创建一个长度为<span class="hljs-number">7</span>的空数组<span class="hljs-comment">// Array.from</span><span class="hljs-built_in">Array</span>.from(arrayLike[, mapFn[, thisArg]])</code></pre></div><h2 id="变异方法（改变原数组）"><a href="#变异方法（改变原数组）" class="headerlink" title="变异方法（改变原数组）"></a>变异方法（改变原数组）</h2><ul><li><code>pop()</code>删除最后一个元素</li><li><code>shift()</code>删除第一个元素</li><li><code>push()</code>添加元素至末尾</li><li><code>unshift()</code>添加元素至首位</li><li><code>splice(start,delCount,new1,new2...)</code>往数组索引为 start 位置删除 delCont 个元素，并从该位置加入 new 新元素</li><li><code>sort()</code>排序</li><li><code>reverse()</code>倒序,返回新数组<br>es6</li><li><code>copyWithin(target,start,end)</code>拷贝数组中索引从 start 到 end（end）的元素添加至 target</li><li><code>fill(value,start,end)</code>将数组中索引 start 到 end（不含）的位置填充为 value 元素</li></ul><h2 id="非变异方法"><a href="#非变异方法" class="headerlink" title="非变异方法"></a>非变异方法</h2><ul><li><code>slice(start,end)</code>潜拷贝，返回索引从 start 到 end（不含）的元素组成新数组</li><li><code>join()</code>指定分隔符将数字元素连成字符串</li><li><code>concat()</code>合并数组</li><li><code>indexOf()/lastIndexOf()</code>查找元素索引,可传入起始位置</li><li><code>includes()</code>查找是否包含元素返回Boolean,可传入起始位置</li><li><code>...</code>展开运算符</li></ul><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p>  遍历数组的方法回调mapFn包含自动传入的参数(currentValue,currentIndex,thisArr)</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">解释了[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>].map(<span class="hljs-built_in">parseInt</span>)=  <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-number">0</span>),<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-number">1</span>),<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-number">2</span>)=  <span class="hljs-number">1</span>,<span class="hljs-literal">NaN</span>,<span class="hljs-literal">NaN</span></code></pre></div><ul><li><p><code>map()</code>创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果</p></li><li><p><code>flatmap()</code>使用映射函数映射每个元素，然后将结果压缩成一个新数组</p></li><li><p><code>some()</code>方法测试是否至少有一个元素可以通过被提供的函数方法。该方法返回一个 Boolean 类型的值</p></li><li><p><code>every()</code>检测数组所有元素是否都符合判断条件,<br>如果数组中检测到有一个元素不满足, 则整个表达式返回 false,且停止遍历</p></li><li><p><code>forEach()</code>对数组的每个元素执行一次提供的函数。*<em>无法中途退出循环</em>*  </p></li><li><p><code>filter()</code>返回过滤后的数组</p></li><li><p><code>find()</code>返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined</p></li><li><p><code>findIndex()</code>返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1</p></li><li><p><code>reduce()和reduceRight()</code>累加器,累加函数的 return 作为下一次累加的 pre 值，并可指定初始值</p></li><li><p><code>flat(deepth)</code>按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回（<em>会移除数组中的空项</em>）</p></li><li><p><code>keys()</code></p></li><li><p><code>values()</code></p></li><li><p><code>entries()</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index <span class="hljs-keyword">of</span> [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>].keys()) &#123;  <span class="hljs-built_in">console</span>.log(index);&#125;<span class="hljs-comment">// 0</span><span class="hljs-comment">// 1</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> elem <span class="hljs-keyword">of</span> [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>].values()) &#123;  <span class="hljs-built_in">console</span>.log(elem);&#125;<span class="hljs-comment">// &#x27;a&#x27;</span><span class="hljs-comment">// &#x27;b&#x27;</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [index, elem] <span class="hljs-keyword">of</span> [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>].entries()) &#123;  <span class="hljs-built_in">console</span>.log(index, elem);&#125;<span class="hljs-comment">// 0 &quot;a&quot;</span><span class="hljs-comment">// 1 &quot;b&quot;</span></code></pre></div></li></ul><h2 id="判断数组"><a href="#判断数组" class="headerlink" title="判断数组"></a>判断数组</h2><ol><li><code>arr.constructor===Array</code></li><li><code>arr instanceof Array</code></li><li><code>Array.prototype.isPrototypeOf(arr)</code><br>  查找原型的方法，如果手动更改对象的原型也可欺骗过检测</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [];<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.prototype.isPrototypeOf(arr));<span class="hljs-built_in">console</span>.log(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>);<span class="hljs-built_in">console</span>.log(arr.constructor === <span class="hljs-built_in">Array</span>);arr = &#123;  __proto__: <span class="hljs-built_in">Array</span>.prototype,&#125;;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.prototype.isPrototypeOf(arr));<span class="hljs-built_in">console</span>.log(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>);<span class="hljs-built_in">console</span>.log(arr.constructor === <span class="hljs-built_in">Array</span>);</code></pre></div><ol><li><code>Object.prototype.toString.call(arr)===&#39;[object Array]&#39;</code></li><li><code>Array.isArray()</code></li></ol><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>];<span class="hljs-comment">// 1</span><span class="hljs-keyword">let</span> uni1 = <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr));<span class="hljs-comment">// 2</span><span class="hljs-keyword">let</span> uni2 = [...new <span class="hljs-built_in">Set</span>(arr)];<span class="hljs-comment">// 3</span><span class="hljs-keyword">let</span> uni3 = arr.sort().reduce((init, cur) =  &#123;  <span class="hljs-keyword">if</span> (init.length === <span class="hljs-number">0</span> || init[init.length - <span class="hljs-number">1</span>] !== cur) &#123;    init.push(cur);  &#125;  <span class="hljs-keyword">return</span> init;&#125;, []);<span class="hljs-comment">// 4</span><span class="hljs-keyword">let</span> uni4 = arr.filter((item,index)= &#123;  <span class="hljs-keyword">return</span> arr.indexOf(item) === index&#125;)</code></pre></div><h2 id="计算数组中元素出现的次数"><a href="#计算数组中元素出现的次数" class="headerlink" title="计算数组中元素出现的次数"></a>计算数组中元素出现的次数</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>];<span class="hljs-comment">//reduce</span><span class="hljs-keyword">let</span> countArr = arr.reduce((obj, i) =  &#123;  <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> obj) &#123;    obj[i]++;  &#125; <span class="hljs-keyword">else</span> &#123;    obj[i] = <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">return</span> obj;&#125;, &#123;&#125;);<span class="hljs-comment">// &#123; &#x27;1&#x27;: 2, &#x27;2&#x27;: 2, &#x27;3&#x27;: 2, &#x27;4&#x27;: 4 &#125;</span><span class="hljs-comment">// 循环</span><span class="hljs-keyword">let</span> obj = &#123;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> arr) &#123;  <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> obj) &#123;    obj[i]++;  &#125; <span class="hljs-keyword">else</span> &#123;    obj[i] = <span class="hljs-number">1</span>;  &#125;&#125;</code></pre></div><h2 id="对于-obj-按照属性分类"><a href="#对于-obj-按照属性分类" class="headerlink" title="对于 obj 按照属性分类"></a>对于 obj 按照属性分类</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 面试题教你归类json</span><span class="hljs-comment">// JSON.parse(jsonStr)</span><span class="hljs-keyword">let</span> person = [  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">21</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">21</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Hank&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Jery&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">19</span> &#125;,];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">groupBy</span>(<span class="hljs-params">objArr, prop</span>) </span>&#123;  <span class="hljs-keyword">return</span> objArr.reduce((acc, obj) =  &#123;    <span class="hljs-keyword">let</span> key = obj[prop];    <span class="hljs-keyword">if</span> (!acc[key]) &#123;      acc[key] = [];    &#125;    acc[key].push(obj);    <span class="hljs-keyword">return</span> acc;  &#125;, &#123;&#125;);&#125;<span class="hljs-keyword">let</span> res = groupBy(person, <span class="hljs-string">&quot;age&quot;</span>);</code></pre></div><h2 id="扁平化数组"><a href="#扁平化数组" class="headerlink" title="扁平化数组"></a>扁平化数组</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1 reduce</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat1</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">return</span> arr.reduce((res, item) =  &#123;    <span class="hljs-keyword">return</span> res.concat(<span class="hljs-built_in">Array</span>.isArray(item) ? flat1(item) : item);  &#125;, []);&#125;<span class="hljs-comment">//2 递归</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat2</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">let</span> res = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr) &#123;    <span class="hljs-built_in">Array</span>.isArray(item) ? (res = res.concat.flat2(item)) : res.push(item);  &#125;  <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 3 展开运算符</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat3</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">while</span> (arr.some((item) =  <span class="hljs-built_in">Array</span>.isArray(item))) &#123;    arr = [].concat(...arr);  &#125;  <span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-comment">// 4 toString</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat4</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">return</span> arr    .toString()    .split(<span class="hljs-string">&quot;,&quot;</span>)    .map((item) =  <span class="hljs-built_in">Number</span>(item));&#125;<span class="hljs-comment">// 5 join</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat5</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">return</span> arr    .join(<span class="hljs-string">&quot;,&quot;</span>)    .split(<span class="hljs-string">&quot;,&quot;</span>)    .map((item) =  <span class="hljs-built_in">Number</span>(item));&#125;<span class="hljs-comment">// 6 flat()</span>flat(<span class="hljs-literal">Infinity</span>);</code></pre></div><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><h3 id="V8中的sort"><a href="#V8中的sort" class="headerlink" title="V8中的sort()"></a>V8中的sort()</h3><ul><li>7.0之前 arr.length =10【插入排序】， 10【快速排序】</li><li>7.0之后 【timesort】 <h3 id="手写排序方法"><a href="#手写排序方法" class="headerlink" title="手写排序方法"></a>手写排序方法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><blockquote><p>O(n^2)</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">const</span> len = arr.length;  <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len-<span class="hljs-number">1</span> ; i++) &#123;    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 提前退出标识</span>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++) &#123;      <span class="hljs-keyword">if</span> (arr[j] &gt;  arr[j + <span class="hljs-number">1</span>]) &#123;        [arr[j], arr[j + <span class="hljs-number">1</span>]] = [arr[j + <span class="hljs-number">1</span>], arr[j]];        flag = <span class="hljs-literal">true</span>;      &#125;    &#125;    <span class="hljs-keyword">if</span> (!flag) <span class="hljs-keyword">break</span>;  &#125;  <span class="hljs-keyword">return</span> arr;&#125;</code></pre></div></li></ul><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><blockquote><p>O(n^2)</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertSort1</span>(<span class="hljs-params">arr</span>)</span>&#123;  <span class="hljs-keyword">const</span> len = arr.length  <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span> ;i&lt;len ;i++)&#123;    <span class="hljs-keyword">const</span> temp = arr[i]    <span class="hljs-keyword">let</span> j = i    <span class="hljs-keyword">if</span>(arr[j-<span class="hljs-number">1</span>]&gt;temp)&#123;      <span class="hljs-keyword">while</span>(arr[j-<span class="hljs-number">1</span>]&gt;temp &amp;&amp; j&gt;<span class="hljs-number">0</span>)&#123;        arr[j] = arr[j-<span class="hljs-number">1</span>]        j--      &#125;    &#125;    <span class="hljs-comment">// 将元素插入正确位置</span>    arr[j] = temp  &#125;  <span class="hljs-keyword">return</span> arr&#125;<span class="hljs-comment">// 交换[低效率]</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertSort2</span>(<span class="hljs-params">arr</span>)</span>&#123;  <span class="hljs-keyword">const</span> len = arr.length  <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span> ;i &lt; len ;i++)&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i ;j &gt; <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt;arr[j-<span class="hljs-number">1</span>];j--)&#123;      <span class="hljs-comment">// 依次移动i指针</span>      <span class="hljs-comment">// 循环比较将i位置顺序插入到i的左边</span>      <span class="hljs-comment">// 依次往前冒泡到合理位置</span>      [arr[j],arr[j-<span class="hljs-number">1</span>]] = [arr[j-<span class="hljs-number">1</span>],arr[j]]    &#125;  &#125;  <span class="hljs-keyword">return</span> arr&#125;</code></pre></div><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><blockquote><p>平均O(n log 2n) 最坏O(n^2)</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 希尔排序相当于有间隔得进行插入排序</span><span class="hljs-comment">// 移动</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shellSort1</span>(<span class="hljs-params">arr</span>)</span>&#123;  <span class="hljs-keyword">const</span> len = arr.length  <span class="hljs-keyword">if</span>(len&lt;<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr  <span class="hljs-keyword">let</span> gap = <span class="hljs-built_in">Math</span>.floor(len/<span class="hljs-number">2</span>)  <span class="hljs-keyword">for</span>(;gap&gt;<span class="hljs-number">0</span>;gap = <span class="hljs-built_in">Math</span>.floor(gap/<span class="hljs-number">2</span>))&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = gap;i&lt;len;i++)&#123;      <span class="hljs-keyword">const</span> temp = arr[i]      <span class="hljs-keyword">let</span> j = i      <span class="hljs-keyword">if</span>(arr[j-gap]&gt;temp)&#123;        <span class="hljs-keyword">while</span>(arr[j-gap]&gt;temp &amp;&amp; j-gap&gt;=<span class="hljs-number">0</span>)&#123;          arr[j] = arr[j-gap]          j-=gap        &#125;      &#125;      arr[j] = temp    &#125;  &#125;  <span class="hljs-keyword">return</span> arr&#125;<span class="hljs-comment">// 交换[低效率]</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shellSort2</span>(<span class="hljs-params">arr</span>)</span>&#123;  <span class="hljs-keyword">const</span> len = arr.length  <span class="hljs-keyword">let</span> gap = <span class="hljs-built_in">Math</span>.floor(len/<span class="hljs-number">2</span>)  <span class="hljs-keyword">for</span>(;gap&gt;<span class="hljs-number">0</span>;gap = <span class="hljs-built_in">Math</span>.floor(gap/<span class="hljs-number">2</span>))&#123;    <span class="hljs-comment">// 不断缩小间隔的长度</span>    <span class="hljs-comment">// 最终会为1</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = gap ; i&lt;len ;i++)&#123;      <span class="hljs-comment">// i指针</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i;j-gap&gt;=<span class="hljs-number">0</span> &amp;&amp; arr[j-gap] &gt; arr[j];j-=gap)&#123;        <span class="hljs-comment">// 比较指针左边与指针位置相距gap的元素</span>        <span class="hljs-comment">// 冒泡到该位置</span>        [arr[j],arr[j-gap]] = [arr[j-gap],arr[j]]      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> arr&#125;</code></pre></div><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><blockquote><p>时间O(n^2)</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectionSort</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">var</span> len = arr.length;  <span class="hljs-keyword">var</span> minIndex;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;    minIndex = i;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;      <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;        <span class="hljs-comment">// 寻找i右边最小的数</span>        minIndex = j; <span class="hljs-comment">// 将最小数的索引保存</span>      &#125;    &#125;    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];  &#125;  <span class="hljs-keyword">return</span> arr;&#125;</code></pre></div><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><blockquote><p>平均 O(n log n)</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> quickSort = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">if</span> (arr.length &lt; <span class="hljs-number">2</span>) &#123;    <span class="hljs-keyword">return</span> arr;  &#125; <span class="hljs-comment">//一直排序到区间内只有一个数</span>  <span class="hljs-keyword">var</span> pivotIndex = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>); <span class="hljs-comment">//基准位置（可任意选取）</span>  <span class="hljs-keyword">var</span> pivot = arr.splice(pivotIndex, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]; <span class="hljs-comment">//找出基准数并把它从原数组删除</span>  <span class="hljs-keyword">var</span> left = [];  <span class="hljs-comment">// 空间复杂度O(n)</span>  <span class="hljs-keyword">var</span> right = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;    <span class="hljs-keyword">if</span> (arr[i] &lt; pivot) &#123;      left.push(arr[i]);    &#125; <span class="hljs-keyword">else</span> &#123;      right.push(arr[i]);    &#125;  &#125;  <span class="hljs-keyword">return</span> [...quickSort(left), pivot, ...quickSort(right)]; <span class="hljs-comment">// 不使用额外空间</span>  <span class="hljs-comment">// 随机选取基准，数组分成基准左右两部分</span>  <span class="hljs-comment">// 将比基准大的移动基准右边，比基准小的移动到基准左边</span>  <span class="hljs-comment">// 递归分割排序</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr</span>) </span>&#123;    quick(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quick</span>(<span class="hljs-params">arr, left, right</span>) </span>&#123;      <span class="hljs-keyword">if</span>(left&gt;=right) <span class="hljs-keyword">return</span>         <span class="hljs-keyword">const</span> index = partition(arr, left, right);        <span class="hljs-comment">// 选出一个随机值，并把它移动到正确位置</span>        <span class="hljs-comment">// 根据该位置切割递归</span>        <span class="hljs-keyword">if</span> (left &lt; index - <span class="hljs-number">1</span>) &#123;          <span class="hljs-comment">//排序左边</span>          quick(arr, left, index - <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">if</span> (index &lt; right) &#123;          <span class="hljs-comment">// 排序右边</span>          quick(arr, index+<span class="hljs-number">1</span>, right);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partition</span>(<span class="hljs-params">arr, left, right</span>) </span>&#123;      <span class="hljs-keyword">const</span> base = arr[<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (right - left + <span class="hljs-number">1</span>)) + left];      <span class="hljs-comment">// 随机选</span>      <span class="hljs-keyword">let</span> L = left,        R = right;        <span class="hljs-comment">// 左右指针</span>      <span class="hljs-keyword">while</span> (L &lt; R) &#123;        <span class="hljs-keyword">while</span> (arr[L] &lt; base) &#123;          L++;          <span class="hljs-comment">// 左指针向右查找比基准大</span>        &#125;        <span class="hljs-keyword">while</span> (arr[R] &gt; base) &#123;          R--;          <span class="hljs-comment">//右指针向左查找比基准小</span>        &#125;        <span class="hljs-keyword">if</span> (L &lt; R) &#123;          [arr[L], arr[R]] = [arr[R], arr[L]];          <span class="hljs-comment">//交换位置</span>        &#125;        <span class="hljs-keyword">if</span>(arr[L]===arr[R] &amp;&amp; L!==R)&#123;          <span class="hljs-comment">//重复元素</span>          L++        &#125;      &#125;      <span class="hljs-comment">//最后输出两个指针相遇位置</span>      <span class="hljs-comment">//返回这个位置</span>      <span class="hljs-keyword">return</span> L;    &#125;    <span class="hljs-keyword">return</span> arr  &#125;  quickSort([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>]);  <span class="hljs-comment">//[(1, 2, 3, 4, 5, 6, 7, 8)];</span></code></pre></div><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 建立大顶堆</span><span class="hljs-comment">// 依次将末尾元素与heap[1]交换位置并调整堆，同时缩小堆的大小（排除最后的大数）</span><span class="hljs-comment">// heap[2]和heap[1]交换完成后就是升序排序</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapSort</span>(<span class="hljs-params">arr</span>)</span>&#123;  <span class="hljs-keyword">const</span> heap = [,...arr]  <span class="hljs-keyword">let</span> heapSize = arr.length  buildHeap(heap,heapSize)  <span class="hljs-comment">// 开始交换头尾</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> k = heapSize;k&gt;<span class="hljs-number">1</span>;k--)&#123;    [heap[k],heap[<span class="hljs-number">1</span>]] = [heap[<span class="hljs-number">1</span>],heap[k]]    heapify(heap,--heapSize,<span class="hljs-number">1</span>)  &#125;  heap.shift()  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildHeap</span>(<span class="hljs-params">heap,size</span>)</span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(size/<span class="hljs-number">2</span>);i&gt;=<span class="hljs-number">1</span>;i--)&#123;      heapify(heap,size,i)    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">heap,heapSize,i</span>)</span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;      <span class="hljs-keyword">let</span> maxIndex = i      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i &lt;= heapSize &amp;&amp; heap[<span class="hljs-number">2</span>*i] &gt; heap[i]) maxIndex = <span class="hljs-number">2</span> * i       <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;=heapSize &amp;&amp; heap[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>] &gt; heap[maxIndex]) maxIndex = <span class="hljs-number">2</span> * i +<span class="hljs-number">1</span>      <span class="hljs-keyword">if</span>(maxIndex === i) <span class="hljs-keyword">break</span>      [heap[maxIndex],heap[i]] = [heap[i],heap[maxIndex]]      i = maxIndex    &#125;  &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise</title>
    <link href="/2021/04/13/Promise/"/>
    <url>/2021/04/13/Promise/</url>
    
    <content type="html"><![CDATA[<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>Promise 对象用于处理异步操作，它表示一个尚未完成且预计在未来完成的异步操作。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>解决回调地狱</li><li>统一的 API 接口处理异步任务</li><li>链式调用</li><li>返回值穿透</li><li>错误冒泡</li></ul><h2 id="Promise-对象有以下两个特点"><a href="#Promise-对象有以下两个特点" class="headerlink" title="Promise 对象有以下两个特点"></a>Promise 对象有以下两个特点</h2><ol><li><p>对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p></li><li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p></li></ol><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><ul><li>为 Promise 实例添加状态改变时的回调函数</li><li>then 方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数</li><li>then 方法返回的是一个新的 Promise 实例,可以 then 方法后面再调用另一个 then 方法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">getJSON(<span class="hljs-string">&quot;/post/1.json&quot;</span>)  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">post</span>) </span>&#123;    <span class="hljs-keyword">return</span> getJSON(post.commentURL);  &#125;)  .then(    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">funcA</span>(<span class="hljs-params">comments</span>) </span>&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;resolved: &quot;</span>, comments);    &#125;,    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">funcB</span>(<span class="hljs-params">err</span>) </span>&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;rejected: &quot;</span>, err);    &#125;  );<span class="hljs-comment">// 第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。</span></code></pre></div><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><ul><li><p>指定发生错误时的回调函数</p></li><li><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。</span><span class="hljs-comment">// bad</span>promise.then(  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;    <span class="hljs-comment">// success</span>  &#125;,  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;    <span class="hljs-comment">// error</span>  &#125;);<span class="hljs-comment">// good</span>promise  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;    <span class="hljs-comment">//cb</span>    <span class="hljs-comment">// success</span>  &#125;)  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;    <span class="hljs-comment">// error</span>  &#125;);</code></pre></div><ul><li><p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应</p></li><li><p>catch 方法返回的还是一个 Promise 对象，因此后面还可以接着调用 then 方法</p></li></ul><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><ul><li><p>finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作</p></li><li><p>finally 方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是 fulfilled 还是 rejected。这表明，finally 方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p></li></ul><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><ul><li>Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例</li></ul><p><code>const p = Promise.all([p1, p2, p3]);</code></p><ul><li>p 的状态由 p1、p2、p3 决定，分成两种情况。</li></ul><ol><li><p>只有 p1、p2、p3 的状态都变成<code>fulfilled</code>，p 的状态才会变成<code>fulfilled</code>，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。</p></li><li><p>只要 p1、p2、p3 之中有一个被<code>rejected</code>，p 的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给 p 的回调函数</p></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// example</span><span class="hljs-keyword">const</span> databasePromise = connectDatabase();<span class="hljs-keyword">const</span> booksPromise = databasePromise.then(findAllBooks);<span class="hljs-keyword">const</span> userPromise = databasePromise.then(getCurrentUser);<span class="hljs-built_in">Promise</span>.all([booksPromise, userPromise]).then(<span class="hljs-function">(<span class="hljs-params">[books, user]</span>) =&gt;</span>  pickTopRecommendations(books, user));</code></pre></div><ul><li>如果作为参数的 Promise 实例，自己定义了 catch 方法，那么它一旦被 rejected，并不会触发 Promise.all()的 catch 方法</li></ul><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><p><code>const p = Promise.race([p1, p2, p3]);</code></p><p>上面代码中，只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//example</span><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.race([  fetch(<span class="hljs-string">&quot;/resource-that-may-take-a-while&quot;</span>),  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;request timeout&quot;</span>)), <span class="hljs-number">5000</span>);  &#125;), <span class="hljs-comment">// 5s内请求不resolve则抛出错误</span>]);p.then(<span class="hljs-built_in">console</span>.log).catch(<span class="hljs-built_in">console</span>.error);</code></pre></div><h3 id="promise-try"><a href="#promise-try" class="headerlink" title="promise.try()"></a>promise.try()</h3><p>不想区分，函数 f 是同步函数还是异步操作，但是想用 Promise 来处理它</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;  database.users.get(&#123;<span class="hljs-attr">id</span>: userId&#125;)  .then(...)  .catch(...) <span class="hljs-comment">// promise错误</span>&#125; <span class="hljs-keyword">catch</span> (e) &#123; <span class="hljs-comment">// 同步错误</span>  <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// try catch捕获同步错误</span><span class="hljs-comment">// 用promise.try改写</span><span class="hljs-built_in">Promise</span>.try(<span class="hljs-function">() =&gt;</span> database.users.get(&#123;<span class="hljs-attr">id</span>: userId&#125;))  .then(...)  .catch(...)</code></pre></div><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ul><li>立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行</li></ul><blockquote><p>Promise.resolve()方法允许调用时不带参数，直接返回一个 resolved 状态的 Promise 对象。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;three&quot;</span>);&#125;, <span class="hljs-number">0</span>);<span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;two&quot;</span>);&#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;one&quot;</span>);<span class="hljs-comment">// one</span><span class="hljs-comment">// two</span><span class="hljs-comment">// three</span></code></pre></div><ul><li><p><code>Promise.reject()</code>方法的参数，会原封不动地作为 reject 的理由，变成后续方法的参数</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> thenable = &#123;  <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">resolve, reject</span>)</span> &#123;    reject(<span class="hljs-string">&quot;出错了&quot;</span>);  &#125;,&#125;;<span class="hljs-built_in">Promise</span>.reject(thenable).catch(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(e);&#125;);<span class="hljs-comment">// catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。</span></code></pre></div></li></ul><h2 id="手写一个-Promise"><a href="#手写一个-Promise" class="headerlink" title="手写一个 Promise"></a>手写一个 Promise</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 符合A+规范的promise</span><span class="hljs-comment">// promises-aplus-tests</span><span class="hljs-keyword">const</span> isComplex = <span class="hljs-function">(<span class="hljs-params">o</span>) =&gt;</span>  o !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">&quot;function&quot;</span> || <span class="hljs-keyword">typeof</span> o === <span class="hljs-string">&quot;object&quot;</span>);  <span class="hljs-comment">//解析then的执行结果</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) </span>&#123;  <span class="hljs-keyword">if</span> (promise2 === x) &#123;    <span class="hljs-comment">// 循环引用</span>    <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;cycle quotes detected&quot;</span>));  &#125;  <span class="hljs-keyword">if</span> (isComplex(x)) &#123;    <span class="hljs-comment">// x是function或者object</span>    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>;    <span class="hljs-comment">// 只return第一个</span>    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">let</span> then = x.then;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&quot;function&quot;</span>) &#123; <span class="hljs-comment">//如果x是promise</span>        then.call(          x,          (y) =&gt; &#123;            <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span>;            flag = <span class="hljs-literal">true</span>;            <span class="hljs-comment">//递归解析</span>            <span class="hljs-keyword">return</span> resolvePromise(promise2, y, resolve, reject);          &#125;,          (r) =&gt; &#123;            <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span>;            flag = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">return</span> reject(r);          &#125;        );      &#125; <span class="hljs-keyword">else</span> &#123;        resolve(x);<span class="hljs-comment">// x是对象</span>      &#125;    &#125; <span class="hljs-keyword">catch</span> (e) &#123;      <span class="hljs-comment">//有异常reject异常</span>      <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span>;      flag = <span class="hljs-literal">true</span>;      <span class="hljs-keyword">return</span> reject(e);    &#125;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 简单类型直接作为resolve的值</span>    resolve(x);  &#125;&#125;<span class="hljs-comment">//</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">executor</span>) </span>&#123;  <span class="hljs-built_in">this</span>.status = <span class="hljs-string">&quot;pending&quot;</span>;  <span class="hljs-built_in">this</span>.data = <span class="hljs-literal">null</span>;  <span class="hljs-built_in">this</span>.onResolvedCallback = [];  <span class="hljs-built_in">this</span>.onRejectedCallback = [];  <span class="hljs-keyword">const</span> resolve = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;      <span class="hljs-keyword">return</span> value.then(resolve, reject);    &#125;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-string">&quot;pending&quot;</span>) &#123;        <span class="hljs-built_in">this</span>.status = <span class="hljs-string">&quot;resolved&quot;</span>;        <span class="hljs-built_in">this</span>.data = value;        <span class="hljs-built_in">this</span>.onResolvedCallback.forEach(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> cb(value));      &#125;    &#125;);  &#125;;  <span class="hljs-keyword">const</span> reject = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-string">&quot;pending&quot;</span>) &#123;        <span class="hljs-built_in">this</span>.status = <span class="hljs-string">&quot;rejected&quot;</span>;        <span class="hljs-built_in">this</span>.data = reason;        <span class="hljs-built_in">this</span>.onRejectedCallback.forEach(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> cb(reason));      &#125;    &#125;);  &#125;;  <span class="hljs-comment">// 传入立即执行</span>  <span class="hljs-keyword">try</span> &#123;    executor(resolve, reject);  &#125; <span class="hljs-keyword">catch</span> (e) &#123;    reject(e);  &#125;&#125;<span class="hljs-comment">// 原型链上的then，可调用多次</span><span class="hljs-built_in">Promise</span>.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onResolved, onRejected</span>) </span>&#123;  <span class="hljs-comment">// onResolved如果是个值则作为上个promise的resolve结果</span>  onResolved = <span class="hljs-keyword">typeof</span> onResolved === <span class="hljs-string">&quot;function&quot;</span> ? onResolved : <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> value;  <span class="hljs-comment">// onResolved如果是个值则作为上个promise的reject错误</span>  onRejected =    <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span>      ? onRejected      : <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;          <span class="hljs-keyword">throw</span> err;        &#125;;  <span class="hljs-comment">// then根据promise的状态返回不同的promise2</span>  <span class="hljs-keyword">let</span> promise2;  <span class="hljs-comment">// 如果调用 then 时，promise已经resolve，则执行 onFulfilled，并将promise的值作为参数传递进去</span>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-string">&quot;resolved&quot;</span>) &#123;    promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">let</span> x = onResolved(<span class="hljs-built_in">this</span>.data);          resolvePromise(promise2, x, resolve, reject);        &#125; <span class="hljs-keyword">catch</span> (e) &#123;          reject(e);        &#125;      &#125;);    &#125;)  &#125;  <span class="hljs-comment">// 如果调用 then 时，promise已经reject，则执行 onRejected，并将promise的值作为参数传递进去</span>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-string">&quot;rejected&quot;</span>) &#123;    promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">let</span> x = onRejected(<span class="hljs-built_in">this</span>.data);          resolvePromise(promise2, x, resolve, reject);        &#125; <span class="hljs-keyword">catch</span> (e) &#123;          reject(e);        &#125;      &#125;);    &#125;)  &#125;  <span class="hljs-comment">// promise状态还买改变则将两个回调分别加入数组</span>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-string">&quot;pending&quot;</span>) &#123;    promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-built_in">this</span>.onResolvedCallback.push(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">let</span> x = onResolved(<span class="hljs-built_in">this</span>.data);          resolvePromise(promise2, x, resolve, reject);        &#125; <span class="hljs-keyword">catch</span> (e) &#123;          reject(e);        &#125;      &#125;);      <span class="hljs-built_in">this</span>.onRejectedCallback.push(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">let</span> x = onRejected(<span class="hljs-built_in">this</span>.data);          resolvePromise(promise2, x, resolve, reject);        &#125; <span class="hljs-keyword">catch</span> (e) &#123;          reject(e);        &#125;      &#125;);    &#125;)  &#125;  <span class="hljs-keyword">return</span> promise2&#125;;<span class="hljs-built_in">Promise</span>.prototype.catch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onRejected</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">null</span>, onRejected);&#125;;<span class="hljs-built_in">Promise</span>.promise.finally = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(    (value) =&gt; &#123;      <span class="hljs-built_in">Promise</span>.resolve(callback()).then(<span class="hljs-function">() =&gt;</span> value);    &#125;,    (reason) =&gt; &#123;      <span class="hljs-built_in">Promise</span>.resolve(callback()).then(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">throw</span> reason;      &#125;);    &#125;  );&#125;;<span class="hljs-built_in">Promise</span>.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;      <span class="hljs-keyword">return</span> value.then(resolve, reject);    &#125; <span class="hljs-keyword">else</span> &#123;      resolve(value);    &#125;  &#125;);&#125;;<span class="hljs-built_in">Promise</span>.reject = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    reject(reason);  &#125;);&#125;;<span class="hljs-built_in">Promise</span>.race = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    arr.forEach(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> p.then(resolve, reject));  &#125;);&#125;;<span class="hljs-built_in">Promise</span>.any = <span class="hljs-function"><span class="hljs-params">promises</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;    <span class="hljs-keyword">let</span> len = promises.length    <span class="hljs-keyword">if</span>(!len) <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> AggregateError([]))    <span class="hljs-keyword">const</span> res = []    promises.forEach(<span class="hljs-function">(<span class="hljs-params">pItem,index</span>)=&gt;</span>&#123;      pItem.then(<span class="hljs-function"><span class="hljs-params">v</span>=&gt;</span>&#123;        <span class="hljs-keyword">return</span> resolve(v)      &#125;,<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span>&#123;        res.push(e)        <span class="hljs-keyword">if</span>(--len===<span class="hljs-number">0</span>)&#123;          <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> AggregateError(res))        &#125;      &#125;)    &#125;)  &#125;)&#125;<span class="hljs-built_in">Promise</span>.all = <span class="hljs-function"><span class="hljs-params">promises</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>    <span class="hljs-keyword">let</span> len = promises.length    <span class="hljs-keyword">if</span>(!len)<span class="hljs-keyword">return</span> resolve([])    <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">Array</span>(len)    promises.forEach(<span class="hljs-function">(<span class="hljs-params">pItem,index</span>)=&gt;</span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(pItem).then(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;        res[index] = value        <span class="hljs-keyword">if</span>(++count===len)&#123;          <span class="hljs-keyword">return</span> resolve(res)        &#125;      &#125;,<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;        <span class="hljs-keyword">return</span> reject(err)      &#125;)    &#125;)  &#125;)&#125;<span class="hljs-built_in">Promise</span>.allSettled = <span class="hljs-function"><span class="hljs-params">promises</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;    <span class="hljs-keyword">const</span> len = promises.length    <span class="hljs-keyword">if</span>(!len)    <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">Array</span>(len)    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>    promises.forEach(<span class="hljs-function">(<span class="hljs-params">pItem,index</span>)=&gt;</span>resolvePromise(pItem,index))    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span>(<span class="hljs-params">p,i</span>)</span>&#123;      <span class="hljs-keyword">if</span>(p <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>)&#123;        p.then(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;          res[i] = &#123;<span class="hljs-attr">status</span>:<span class="hljs-string">&#x27;resolved&#x27;</span>,<span class="hljs-attr">value</span>:value&#125;          <span class="hljs-keyword">if</span>(++count===len)&#123;            <span class="hljs-keyword">return</span> resolve(res)          &#125;        &#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;          res[i] = &#123;<span class="hljs-attr">status</span>:<span class="hljs-string">&#x27;rejected&#x27;</span>,<span class="hljs-attr">reason</span>:reason&#125;          <span class="hljs-keyword">if</span>(++count===len)&#123;            <span class="hljs-keyword">return</span> resolve(res)          &#125;        &#125;)      &#125;<span class="hljs-keyword">else</span>&#123;        res[i] = &#123;<span class="hljs-attr">status</span>:<span class="hljs-string">&#x27;resolved&#x27;</span>,<span class="hljs-attr">value</span>:p&#125;        <span class="hljs-keyword">if</span>(++count===len)&#123;          <span class="hljs-keyword">return</span> resolve(res)        &#125;      &#125;    &#125;  &#125;)&#125;</code></pre></div><h2 id="同步函数-promise-化"><a href="#同步函数-promise-化" class="headerlink" title="同步函数 promise 化"></a>同步函数 promise 化</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promisify = <span class="hljs-function">(<span class="hljs-params">func</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    args.push(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, value</span>) </span>&#123;      <span class="hljs-keyword">if</span> (err) reject(err);      <span class="hljs-keyword">else</span> resolve(value);    &#125;);    func.apply(<span class="hljs-literal">null</span>, args);  &#125;);</code></pre></div><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;  <span class="hljs-comment">// ...</span>&#125;);<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;  <span class="hljs-comment">// ...</span>  resolve(p1);&#125;);<span class="hljs-comment">//p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。</span><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;fail&quot;</span>)), <span class="hljs-number">3000</span>);&#125;);<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(p1), <span class="hljs-number">1000</span>);&#125;);p2.then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(result)).catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(error));<span class="hljs-comment">// Error: fail</span><span class="hljs-comment">// 上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>es6</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络分层模型</title>
    <link href="/2021/04/13/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/04/13/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h1><p><code>OSI参考模型（OSI/RM）</code>的全称是开放系统互连参考模型<code>（Open System Interconnection Reference Model，OSI/RM）</code>，它是由国际标准化组织（International Standard Organization，ISO）提出的一个网络系统互连模型。</p><ul><li><p>在这个 OSI 七层模型中，每一层都为其上一层提供服务、并为其上一层提供一个访问接口或界面。</p></li><li><p>不同主机之间的相同层次称为<strong>对等层</strong>。如主机 A 中的表示层和主机 B 中的表示层互为对等层、主机 A 中的会话层和主机 B 中的会话层互为对等层等。</p></li><li><p>对等层之间互相通信需要遵守一定的规则，如通信的内容、通信的方式，我们将其称为<strong>协议</strong>（Protocol）。</p></li><li><p>我们将某个主机上运行的某种协议的集合称为<strong>协议栈</strong>。主机正是利用这个协议栈来接收和发送数据的。</p></li><li><p>OSI 参考模型通过将协议栈划分为不同的层次，可以简化问题的分析、处理过程以及网络系统设计的复杂性。</p></li></ul><h2 id="OSI-参考模型中各层的作用"><a href="#OSI-参考模型中各层的作用" class="headerlink" title="OSI 参考模型中各层的作用"></a>OSI 参考模型中各层的作用</h2><h3 id="物理层Physical-Layer"><a href="#物理层Physical-Layer" class="headerlink" title="物理层Physical Layer"></a>物理层<code>Physical Layer</code></h3><ul><li>利用传输介质为数据链路层提供物理连接，传输二进制数据</li><li>数据的单位称为比特<code>bit</code></li></ul><h3 id="数据链路层Data-Link-Layer"><a href="#数据链路层Data-Link-Layer" class="headerlink" title="数据链路层Data Link Layer"></a>数据链路层<code>Data Link Layer</code></h3><ul><li>物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</li><li>数据的单位称为帧<code>frame</code></li><li><code>ARP</code>（Address Resolution Protocol，地址解析协议）</li><li><code>RARP</code>（Reverse Address Resolution Protocol，逆地址解析协议）</li></ul><h3 id="网络层Network-Layer"><a href="#网络层Network-Layer" class="headerlink" title="网络层Network Layer"></a>网络层<code>Network Layer</code></h3><ul><li>数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，传送到另一个网络设备。</li><li>数据的单位称为包<code>packet</code></li><li><code>IP</code> 协议（Internet Protocol，网际协议）</li><li><code>ICMP</code> 协议（Internet Control Message Protocol，网际控制报文协议）</li><li><code>IGMP</code> 协议（Internet Group Management Protocol，网际组管理协议）</li></ul><h3 id="传输层Transport-Layer"><a href="#传输层Transport-Layer" class="headerlink" title="传输层Transport Layer"></a>传输层<code>Transport Layer</code></h3><ul><li><p>提供端对端的接口</p></li><li><p>数据的单位称为数据段<code>segment</code></p></li><li><p><code>TCP</code>面向连接，可靠传输，流量控制和拥塞机制，一对一通信，头部较大</p></li><li><p><code>UDP</code>面向报文，不可靠传输，一对多多对一，头部较小</p></li></ul><h3 id="会话层Session-Layer"><a href="#会话层Session-Layer" class="headerlink" title="会话层Session Layer"></a>会话层<code>Session Layer</code></h3><ul><li>管理表示层之间的连接（会话）</li><li>组织和协调两个会话进程之间的通信</li></ul><h3 id="表示层Presentation-Layer"><a href="#表示层Presentation-Layer" class="headerlink" title="表示层Presentation Layer"></a>表示层<code>Presentation Layer</code></h3><ul><li>处理数据编码、数据格式转换和加密解密</li></ul><h3 id="应用层Application-Layer"><a href="#应用层Application-Layer" class="headerlink" title="应用层Application Layer"></a>应用层<code>Application Layer</code></h3><ul><li><p>应用程序访问网络服务的接口</p></li><li><p><code>HTTP</code>、<code>FTP</code>、<code>SMTP</code>、<code>POP3</code>、<code>IMAP4</code></p></li></ul><hr><h1 id="TCP-IP-分层模型"><a href="#TCP-IP-分层模型" class="headerlink" title="TCP/IP 分层模型"></a>TCP/IP 分层模型</h1><ul><li>TCP/IP 分层模型（TCP/IP Layering Model）被称作因特网分层模型(Internet Layering Model)、因特网参考模型(Internet Reference Model)</li></ul><h2 id="TCP-IP-中各层的作用"><a href="#TCP-IP-中各层的作用" class="headerlink" title="TCP/IP 中各层的作用"></a>TCP/IP 中各层的作用</h2><h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><blockquote><p>对应着 OSI/RM 的数据链路层和物理层</p></blockquote><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ul><li><p><code>FTP</code>（File Transfer Protocol，文件传输协议）,</p></li><li><p><code>DNS</code>（Domain Name System，域名系统）,</p></li><li><p><code>HTTP</code>（Hyper Text Transfer Protocol，超文本传输协议）,</p></li><li><p><code>SMTP</code>（Simple Mail Transfer Protocol，简单邮件传输协议）</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js数据类型的判断与转换</title>
    <link href="/2021/04/13/js%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2021/04/13/js%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="ECAMScript-中不能自定义数据类型，只能为下列-7-种"><a href="#ECAMScript-中不能自定义数据类型，只能为下列-7-种" class="headerlink" title="ECAMScript 中不能自定义数据类型，只能为下列 7 种"></a>ECAMScript 中不能自定义数据类型，只能为下列 7 种</h1><h2 id="简单数据类型（原始类型）"><a href="#简单数据类型（原始类型）" class="headerlink" title="简单数据类型（原始类型）"></a>简单数据类型（原始类型）</h2><ul><li><p><code>String</code></p></li><li><p><code>Number</code></p><ul><li>特殊的<code>NaN</code><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">NaN</span> === <span class="hljs-string">&#x27;number&#x27;</span>唯一一个自相反的值<span class="hljs-literal">NaN</span> !== <span class="hljs-literal">NaN</span></code></pre></div></li></ul></li><li><p><code>Boolean</code></p><ul><li>在条件判断时，除了 <code>undefined</code>， <code>null</code>， <code>false</code>， <code>NaN</code>， <code>&#39;&#39;</code>， <code>0</code>， <code>-0</code>，其他所有值都转为 true，包括所有对象。</li><li>布尔值与其他类型比较都会转为数字</li></ul></li><li><p><code>Null</code></p><ul><li><code>typeof null = object</code>,<em>null 表示一个空对象指针</em></li><li>null 必须手动设置，常用于作为参数传入，说明该参数不是对象</li><li>设置为 null 的变量或者对象会被内存收集器回收</li><li>null 转为数字类型值为 0</li><li>Null 和 Undefined</li><li>if 为 false</li></ul></li><li><p><code>Undefined</code></p><ul><li>调用一个值而它本身没有赋值</li><li><code>undefined == null</code> 两个等号</li><li>undefined 转为数字类型为 NaN</li><li>if 为 false</li></ul></li><li><p><code>Symbol</code>[ES6 新增]</p><ul><li>表示独一无二的值</li></ul></li></ul><h2 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h2><p><code>Object</code></p><ul><li>引用类型的值是指向保存在堆中的对象的指针</li><li>使用时要先从栈中读取内存地址，再沿着指针找到堆中的对象</li><li>Object</li><li>Array<ul><li>数组的每一项可以用来保存任何类型的数据</li></ul></li><li>Function<ul><li>每个函数都是 Function 的实例</li></ul></li></ul><h1 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h1><h2 id="typeOf"><a href="#typeOf" class="headerlink" title="typeOf"></a><code>typeOf</code></h2><ul><li>对未声明的变量，只能执行一个有用的操作，就是对它调用<code>typeof</code>,不报错，return <code>undefined</code></li><li>特殊的几个</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// &#x27;undefined&#x27;</span><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span>(); <span class="hljs-comment">// &#x27;symbol&#x27;</span><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// &#x27;object&#x27;</span><span class="hljs-keyword">typeof</span> <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// number</span></code></pre></div><h2 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN"></a><code>isNaN</code></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">NaN</span>));    <span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-number">10</span>));     <span class="hljs-comment">//false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;10&quot;</span>));   <span class="hljs-comment">//  false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;blue&quot;</span>)); <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">true</span>));   <span class="hljs-comment">// false</span></code></pre></div><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h2><p><code>instanceof</code> 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性，但它不能检测<code>null</code> 和 <code>undefined</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript">[] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> <span class="hljs-comment">// true</span>&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span> <span class="hljs-comment">// true</span><span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>() <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span> <span class="hljs-comment">// true</span><span class="hljs-literal">null</span> <span class="hljs-keyword">instanceof</span> Null <span class="hljs-comment">// error</span><span class="hljs-literal">undefined</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-literal">undefined</span> <span class="hljs-comment">// error</span></code></pre></div><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><code>constructor</code></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [];<span class="hljs-keyword">const</span> obj = &#123;&#125;;<span class="hljs-built_in">console</span>.log(arr.constructor); <span class="hljs-comment">// [Function: Array]</span><span class="hljs-built_in">console</span>.log(obj.constructor); <span class="hljs-comment">// [Function: Object]</span></code></pre></div><h2 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a><code>Object.prototype.toString.call()</code></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.toString.call(); <span class="hljs-comment">// [object Undefined]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// [object String]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-number">1</span>); <span class="hljs-comment">// [object Number]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">true</span>); <span class="hljs-comment">// [object Boolean]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// [object Undefined]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">null</span>); <span class="hljs-comment">// [object Null]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>()); <span class="hljs-comment">// [object Function]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()); <span class="hljs-comment">// [object Date]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>()); <span class="hljs-comment">// [object RegExp]</span><span class="hljs-built_in">Object</span>.prototype.toString.call([]); <span class="hljs-comment">// [object Array]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(&#123;&#125;); <span class="hljs-comment">// [object Object]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>()); <span class="hljs-comment">// [object Error]</span></code></pre></div><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="转为数值"><a href="#转为数值" class="headerlink" title="转为数值"></a>转为数值</h2><h3 id="Number-适用于任何类型"><a href="#Number-适用于任何类型" class="headerlink" title="Number() 适用于任何类型"></a>Number() 适用于任何类型</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;Hello world!&quot;</span>);  <span class="hljs-comment">// NaN</span><span class="hljs-keyword">let</span> num2 = <span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 0</span><span class="hljs-keyword">let</span> num3 = <span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;000011&quot;</span>); <span class="hljs-comment">// 11</span><span class="hljs-keyword">let</span> num4 = <span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 1</span></code></pre></div><h3 id="parseInt-主要用于字符串"><a href="#parseInt-主要用于字符串" class="headerlink" title="parseInt() 主要用于字符串"></a>parseInt() 主要用于字符串</h3><ul><li>如果第一个字符不是数值字符、加号或减号，立即返回NaN<br>。这意味着空字符串也会返回 <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num2 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;&quot;</span>);  <span class="hljs-comment">// NaN</span><span class="hljs-keyword">let</span> num3 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;0xA&quot;</span>); <span class="hljs-comment">// 10</span><span class="hljs-keyword">let</span> num4 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-number">22.5</span>); <span class="hljs-comment">//22</span><span class="hljs-keyword">let</span> num5 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">// NaN</span><span class="hljs-keyword">let</span> num6 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;123abc&quot;</span>) <span class="hljs-comment">// 123</span></code></pre></div><h3 id="parseFloat-主要用于字符串"><a href="#parseFloat-主要用于字符串" class="headerlink" title="parseFloat() 主要用于字符串"></a>parseFloat() 主要用于字符串</h3></li><li>只解析十进制</li><li>忽略其次出现的小数点<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;1234blue&quot;</span>); <span class="hljs-comment">// 1234</span><span class="hljs-keyword">let</span> num2 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;0xA&quot;</span>); <span class="hljs-comment">// 0</span><span class="hljs-keyword">let</span> num3 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;22.5&quot;</span>); <span class="hljs-comment">// 22.5</span><span class="hljs-keyword">let</span> num4 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;22.34.5&quot;</span>); <span class="hljs-comment">// 22.34</span><span class="hljs-keyword">let</span> num5 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;0908.5&quot;</span>);  <span class="hljs-comment">//908.5</span><span class="hljs-keyword">let</span> num6 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;3.125e7&quot;</span>); <span class="hljs-comment">// 31250000</span></code></pre></div></li></ul><h2 id="转为字符串"><a href="#转为字符串" class="headerlink" title="转为字符串"></a>转为字符串</h2><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><ul><li>null和undefined没有toString()方法<br>String()<h3 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h3></li><li><em>优先调用toString()</em></li><li>null 转换为 ‘null’</li><li>undefined 转换为 ‘undefined’</li></ul><h2 id="转为布尔值"><a href="#转为布尔值" class="headerlink" title="转为布尔值"></a>转为布尔值</h2><ul><li>Boolean()<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//除了以下六个转为 false 其他全部都为 true</span><span class="hljs-literal">undefined</span><span class="hljs-literal">null</span><span class="hljs-number">0</span><span class="hljs-literal">NaN</span><span class="hljs-string">&#x27;&#x27;</span></code></pre></div></li></ul><h1 id="隐式转换介绍"><a href="#隐式转换介绍" class="headerlink" title="隐式转换介绍"></a>隐式转换介绍</h1><ul><li>在 js 中，当运算符在运算时，如果两边数据不统一，CPU 就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算</li><li>这种无需程序员手动转换，而由编译器自动转换的方式就称为隐式转换</li><li>例如 1 &gt; “0”这行代码在 js 中并不会报错，编译器在运算符时会先把右边的”0”转成数字 0`然后在比较大小</li></ul><h2 id="隐式转换规则"><a href="#隐式转换规则" class="headerlink" title="隐式转换规则"></a>隐式转换规则</h2><ul><li>转成 string 类型： +（字符串连接符）</li><li>转成 number 类型：++/–(自增自减运算符) + - * / %(算术运算符) &gt; &lt; &gt;= &lt;= == != === !=== (关系运算符)</li><li>转成 boolean 类型：!（逻辑非运算符）</li></ul><h2 id="字符串连接符与算术运算符隐式转换规则混淆"><a href="#字符串连接符与算术运算符隐式转换规则混淆" class="headerlink" title="字符串连接符与算术运算符隐式转换规则混淆"></a>字符串连接符与算术运算符隐式转换规则混淆</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 常见面试题如下</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-string">&quot;true&quot;</span>); <span class="hljs-comment">// ‘1true‘’</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-literal">true</span>); <span class="hljs-comment">//2</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-literal">undefined</span>); <span class="hljs-comment">//   NaN</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-literal">null</span>); <span class="hljs-comment">//1</span></code></pre></div><ol><li>字符串连接符+：会把其他数据类型调用 String()方法转成字符串然后拼接</li><li>算术运算符+ ：会把其他数据类型调用 Number（）方法转成数字然后做加法计算</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//+是字符串连接符： String(1) + &#x27;true&#x27; = &#x27;1true&#x27;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-string">&quot;true&quot;</span>); <span class="hljs-comment">//1true</span><span class="hljs-comment">//+是算术运算符 ： 1 + Number(true) = 1 + 1 = 2</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-literal">true</span>); <span class="hljs-comment">//2</span><span class="hljs-comment">// +是算术运算符 ： 1 + Number(undefined) = 1 + NaN = NaN</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-literal">undefined</span>); <span class="hljs-comment">//   NaN</span><span class="hljs-comment">// +是算术运算符 ： 1 + Number(null) = 1 + 0 = 1</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-literal">null</span>); <span class="hljs-comment">//1</span><span class="hljs-comment">//</span></code></pre></div><h2 id="关系运算符：会把其他数据类型转换成-number-之后再比较关系"><a href="#关系运算符：会把其他数据类型转换成-number-之后再比较关系" class="headerlink" title="关系运算符：会把其他数据类型转换成 number 之后再比较关系"></a>关系运算符：会把其他数据类型转换成 number 之后再比较关系</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 常见面试题如下</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> &gt; <span class="hljs-number">10</span>); <span class="hljs-comment">//false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> &gt; <span class="hljs-string">&quot;10&quot;</span>); <span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;abc&quot;</span> &gt; <span class="hljs-string">&quot;b&quot;</span>); <span class="hljs-comment">//false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;abc&quot;</span> &gt; <span class="hljs-string">&quot;aad&quot;</span>); <span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">NaN</span> == <span class="hljs-literal">NaN</span>); <span class="hljs-comment">//false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-literal">null</span>); <span class="hljs-comment">//true</span></code></pre></div><ol><li>当关系运算符两边有一边是字符串的时候，会将其他数据类型使用 Number()转换，然后比较关系<br><code>console.log ( &quot;2&quot; &gt; 10 );//false Number(&#39;2&#39;) &gt; 10 = 2 &gt; 10 = false</code></li><li>当关系运算符两边都是字符串的时候，此时同时转成 number 然后比较关系<br><em>此时并不是按照 Number()的形式转成数字，而是按照字符串对应的 unicode 编码来转成数字</em><blockquote><p>使用这个方法可以查看字符的 unicode 编码： 字符串.charCodeAt(字符下标，默认为 0)</p></blockquote></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> &gt; <span class="hljs-string">&quot;10&quot;</span>); <span class="hljs-comment">//true     &#x27;2&#x27;.charCodeAt() &gt; &#x27;10&#x27;.charCodeAt() = 50 &gt; 49 = true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span>.charCodeAt()); <span class="hljs-comment">//数字50</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;10&quot;</span>.charCodeAt()); <span class="hljs-comment">//数字49（默认返回第一个字符的编码，如果想要查询第二个字符可以传参下标）</span><span class="hljs-comment">//多个字符从左往右依次比较</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;abc&quot;</span> &gt; <span class="hljs-string">&quot;b&quot;</span>); <span class="hljs-comment">//false     先比较&#x27;a&#x27; 和 &#x27;b&#x27;， &#x27;a&#x27; 与 &#x27;b&#x27;不等，则直接得出结果</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;abc&quot;</span> &gt; <span class="hljs-string">&quot;aad&quot;</span>); <span class="hljs-comment">//true     先比较&#x27;a&#x27;和&#x27;a&#x27;，两者相等，继续比较第二个字符 &#x27;b&#x27; 与 &#x27;a&#x27; ,得出结果</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a&quot;</span>.charCodeAt()); <span class="hljs-comment">//数字97</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;b&quot;</span>.charCodeAt()); <span class="hljs-comment">//数字98</span><span class="hljs-comment">//2.3 特殊情况(无视规则)：如果数据类型是undefined与null，，得出固定的结果</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-literal">undefined</span>); <span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-literal">null</span>); <span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">null</span>); <span class="hljs-comment">//true</span><span class="hljs-comment">//2.4 特殊情况（无视规则）：NaN与任何数据比较都是NaN</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">NaN</span> == <span class="hljs-literal">NaN</span>); <span class="hljs-comment">//false</span></code></pre></div><h2 id="复杂数据类型在隐式转换时会先转成-String，然后再转成-Number-运算"><a href="#复杂数据类型在隐式转换时会先转成-String，然后再转成-Number-运算" class="headerlink" title="复杂数据类型在隐式转换时会先转成 String，然后再转成 Number 运算"></a>复杂数据类型在隐式转换时会先转成 String，然后再转成 Number 运算</h2><p>复杂数据类型转 number 顺序如下</p><ol><li>先使用<code>valueOf()</code>方法获取其原始值，如果原始值不是<code>number</code>类型，则使用 <code>toString()</code>方法转成<code>string</code></li><li>再将 string 转成 number 运算</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] == <span class="hljs-string">&quot;1,2&quot;</span>); <span class="hljs-comment">//true     先将左边数组转成string，然后右边也是string则转成unicode编码运算</span><span class="hljs-built_in">console</span>.log([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].valueOf()); <span class="hljs-comment">// [1,2]</span><span class="hljs-built_in">console</span>.log([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].toString()); <span class="hljs-comment">// &#x27;1,2&#x27;</span><span class="hljs-keyword">var</span> a = &#123;&#125;;<span class="hljs-built_in">console</span>.log(a == <span class="hljs-string">&quot;[object Object]&quot;</span>); <span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(a.valueOf().toString()); <span class="hljs-comment">//[object Object]</span><span class="hljs-comment">//分析：逻辑与运算一假则假，要想if分支语句小括号条件成立，则必须要让a的值同时等于1 且 等于 2 且等于3乍看之下，好像根本不可能实现，但是复杂数据类型会先调用valueOf()方法,然后转成number运算而对象的</span></code></pre></div><h2 id="逻辑非隐式转换与关系运算符隐式转换搞混淆"><a href="#逻辑非隐式转换与关系运算符隐式转换搞混淆" class="headerlink" title="逻辑非隐式转换与关系运算符隐式转换搞混淆"></a>逻辑非隐式转换与关系运算符隐式转换搞混淆</h2><ul><li>空数组的 toString()方法会得到空字符串，而空对象的 toString()方法会得到字符串<code>[object Object]</code> （注意第一个小写 o，第二个大写 O 哟）</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>([])); <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(![])); <span class="hljs-comment">// false</span><span class="hljs-comment">//大坑</span><span class="hljs-built_in">console</span>.log([] == <span class="hljs-number">0</span>); <span class="hljs-comment">//true []转数字为0</span><span class="hljs-built_in">console</span>.log(![] == <span class="hljs-number">0</span>); <span class="hljs-comment">//true  ![]转布尔false，转数字为0</span><span class="hljs-comment">//神坑</span><span class="hljs-built_in">console</span>.log([] == ![]); <span class="hljs-comment">//true</span><span class="hljs-comment">// [object Object] == false</span><span class="hljs-built_in">console</span>.log([] == []); <span class="hljs-comment">//false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(!&#123;&#125;)); <span class="hljs-comment">// false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(&#123;&#125;)); <span class="hljs-comment">//  true</span><span class="hljs-comment">//史诗级坑</span><span class="hljs-built_in">console</span>.log(&#123;&#125; == !&#123;&#125;); <span class="hljs-comment">//false</span><span class="hljs-comment">// [object Object] == false</span><span class="hljs-built_in">console</span>.log(&#123;&#125; == &#123;&#125;); <span class="hljs-comment">//false</span></code></pre></div><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><ol><li><p>关系运算符：将其他数据类型转成数字</p></li><li><p>逻辑非：将其他数据类型使用<code>Boolean()</code>转成布尔类型</p></li><li><p>以下八种情况转换为布尔类型会得到 false</p><p><code>0 、-0、NaN、undefined、null、&#39;&#39;(空字符串)、false、document.all()</code></p></li><li><p>除以上八种情况之外所有数据都会得到 true</p></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript">[].valueOf().toString(); <span class="hljs-comment">// 得到空字符串</span><span class="hljs-comment">// Number(&#x27;&#x27;) == 0 成立</span><span class="hljs-built_in">console</span>.log([] == <span class="hljs-number">0</span>); <span class="hljs-comment">//true</span>------------------------------------------------<span class="hljs-comment">// 原理 :本质是 `![]` 逻辑非表达式结果 与   0 比较关系</span><span class="hljs-comment">// (1)逻辑非优先级高于关系运算符</span>![] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 空数组转布尔得到true，然后取反得到false</span><span class="hljs-comment">// (2)false == 0 成立</span><span class="hljs-built_in">console</span>.log(![] == <span class="hljs-number">0</span>); <span class="hljs-comment">//true</span>------------------------------------------------<span class="hljs-comment">// 原理 ：本质其实是 `空对象&#123;&#125;`   与   `!&#123;&#125;`   这个逻辑非表达式结果做比较</span>&#123;&#125;.valueOf().toString(); <span class="hljs-comment">// &#x27;[object Object]&#x27;</span>!&#123;&#125; = <span class="hljs-literal">false</span>;<span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;[object Object]&quot;</span>) == <span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>);<span class="hljs-built_in">console</span>.log(&#123;&#125; == !&#123;&#125;); <span class="hljs-comment">//false</span>------------------------------------------------<span class="hljs-comment">// 引用类型数据存在堆中，栈中存储的是地址，所以他们的结果是false</span><span class="hljs-built_in">console</span>.log(&#123;&#125; == &#123;&#125;); <span class="hljs-comment">//false</span>------------------------------------------------<span class="hljs-comment">// 原理：本质是 `空数组[]`与 `![]` 这个逻辑非表达式结果做比较</span>[].valueOf().toString(); <span class="hljs-comment">// &#x27;&#x27;</span>![] = <span class="hljs-literal">false</span>;<span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;&quot;</span>) == <span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 0 == 0</span><span class="hljs-built_in">console</span>.log([] == ![]); <span class="hljs-comment">//true</span>------------------------------------------------<span class="hljs-comment">// 引用类型数据存在堆中，栈中存储的是地址，所以他们的结果是false</span><span class="hljs-built_in">console</span>.log([] == []); <span class="hljs-comment">//false</span>------------------------------------------------<span class="hljs-built_in">console</span>.log(  &#123;&#125;.valueOf().toString()); <span class="hljs-comment">//[object Object]</span><span class="hljs-built_in">console</span>.log([].valueOf().toString()); <span class="hljs-comment">//&#x27;&#x27; 空字符串</span></code></pre></div><h1 id="类型转换的场景"><a href="#类型转换的场景" class="headerlink" title="类型转换的场景"></a>类型转换的场景</h1><h3 id="转换为-String-的场景"><a href="#转换为-String-的场景" class="headerlink" title="转换为 String 的场景"></a>转换为 String 的场景</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">//21</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> + <span class="hljs-literal">true</span>); <span class="hljs-comment">// 2true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> + <span class="hljs-literal">null</span>); <span class="hljs-comment">// 2null</span><span class="hljs-keyword">var</span> obj2 = &#123;  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a&quot;</span>;  &#125;,&#125;;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> + obj2); <span class="hljs-comment">// 2a</span><span class="hljs-keyword">var</span> obj1 = &#123;  a: <span class="hljs-number">1</span>,  b: <span class="hljs-number">2</span>,&#125;;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> + obj1); <span class="hljs-comment">//2obj1</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> + &#123;&#125;); <span class="hljs-comment">// 2[object Object]</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> + []); <span class="hljs-comment">// 2[object Object]</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> + <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;); <span class="hljs-comment">// 2</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> + [<span class="hljs-string">&quot;msy&quot;</span>, <span class="hljs-number">123</span>]); <span class="hljs-comment">// 2msy,123</span></code></pre></div><h3 id="转换为-Number-的场景"><a href="#转换为-Number-的场景" class="headerlink" title="转换为 Number 的场景"></a>转换为 Number 的场景</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>)); <span class="hljs-comment">// 0</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>)); <span class="hljs-comment">// 1</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 2</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> + <span class="hljs-string">&quot;5&quot;</span>); <span class="hljs-comment">// 25</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> - <span class="hljs-number">6</span>); <span class="hljs-comment">// -6</span><span class="hljs-built_in">console</span>.log([] * <span class="hljs-number">6</span>); <span class="hljs-comment">// 0</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> / <span class="hljs-string">&quot;5&quot;</span>); <span class="hljs-comment">// 0.2</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> / <span class="hljs-number">5</span>); <span class="hljs-comment">// 0.2</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> / <span class="hljs-number">5</span>); <span class="hljs-comment">// 0</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;abc&quot;</span>)); <span class="hljs-comment">// NaN</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>)); <span class="hljs-comment">// 0</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// NaN</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-literal">true</span>); <span class="hljs-comment">//abctrue</span></code></pre></div><h3 id=""><a href="#" class="headerlink" title="[]"></a>[]</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">[] == ![]; <span class="hljs-comment">// true</span><span class="hljs-comment">// &#x27;&#x27; == 0</span><span class="hljs-built_in">console</span>.log(![]); <span class="hljs-comment">// false</span><span class="hljs-built_in">console</span>.log([]); <span class="hljs-comment">// []</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(![])); <span class="hljs-comment">// 0</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([])); <span class="hljs-comment">// 0</span></code></pre></div><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>什么时候返回 NaN （开篇第二道题也得到解决）</p><ul><li>无穷大除以无穷大</li><li>给任意负数做开方运算</li><li>算数运算符与不是数字或无法转换为数字的操作数一起使用</li><li>字符串解析成数字</li><li>一元运算符</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(+<span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">// NaN</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;abc&quot;</span>);</code></pre></div><h3 id="String-和-toString"><a href="#String-和-toString" class="headerlink" title="String 和 toString"></a>String 和 toString</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// toString()可以将数据都转为字符串，但是null和undefined不可以转换。</span><span class="hljs-comment">// 可以转进制</span><span class="hljs-literal">null</span>.toString(); <span class="hljs-comment">//报错</span><span class="hljs-literal">undefined</span>.toString(); <span class="hljs-comment">//报错</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// String()可以将null和undefined转换为字符串，但是没法转进制字符串</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>(<span class="hljs-literal">null</span>));<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>(<span class="hljs-literal">undefined</span>));</code></pre></div><h2 id="值的比较"><a href="#值的比较" class="headerlink" title="值的比较"></a>值的比较</h2><h3 id="es6-新增Object-is-判断"><a href="#es6-新增Object-is-判断" class="headerlink" title="es6 新增Object.is()判断"></a>es6 新增<code>Object.is()</code>判断</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// true</span><span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span><span class="hljs-built_in">Object</span>.is(<span class="hljs-number">0</span>, -<span class="hljs-number">0</span>); <span class="hljs-comment">// false</span><span class="hljs-built_in">Object</span>.is(<span class="hljs-number">0</span>, +<span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><span class="hljs-built_in">Object</span>.is(-<span class="hljs-number">0</span>, -<span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">NaN</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// false</span><span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">NaN</span>, <span class="hljs-number">0</span> / <span class="hljs-number">0</span>); <span class="hljs-comment">// true</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_Object</span>.<span class="hljs-title">is</span>(<span class="hljs-params">x,y</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Object</span>.is)&#123;    <span class="hljs-keyword">if</span>(x===y)&#123;      <span class="hljs-keyword">return</span> x!==<span class="hljs-number">0</span> || <span class="hljs-number">1</span>/x === <span class="hljs-number">1</span>/y    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-keyword">return</span> x!==x &amp;&amp; y!== y    &#125;  &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>地址中输入URL回车后发生了什么</title>
    <link href="/2021/04/13/URL%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/"/>
    <url>/2021/04/13/URL%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="分析请求资源"><a href="#分析请求资源" class="headerlink" title="分析请求资源"></a>分析请求资源</h2><ul><li>不同浏览器对资源优先级分类</li><li>安全策略检查 </li></ul><blockquote><p>网页安全政策（Content Security Policy，缩写 CSP）   是由浏览器提供的一种白名单制度。发者通过配置，来告诉浏   览器各类外部资源的加载和执行限制，来提高网页的安全性。一种最常用应用就是通过限制非信任域名脚本的加载来预防XSS攻击。</p></blockquote><p>可以通过两种方式来配置CSP：</p><ol><li>HTTP请求头的<code>Content-Security-Policy</code></li><li><code>meta</code>标签 <div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;meta http-equiv=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> content=<span class="hljs-string">&quot;script-src &#x27;self&#x27;;style-src nos.netease.com kaola.com;&quot;</span>&gt;</code></pre></div></li></ol><ul><li>资源优先级计算<ol><li><code>html,font,css</code></li><li><code>preload</code></li><li><code>img,pic,video</code></li><li><code>prefetch</code></li></ol></li><li>顺序调整<ol><li>同步XHR请求优先级调整到最高</li><li>图片根据是否出现在可视区域</li><li><code>async/defer</code>的<code>script</code>标签请求优先级降低</li></ol></li></ul><h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><ol><li>查找本地DNS缓存(浏览器，系统，路由器)</li><li>查找系统HOST文件</li><li>DNS服务器进行DNS查询<ul><li>DNS查询过程<ol><li>DNS服务器缓存</li><li>DNS服务器向根域名服务器发送请求，根域名服务器返回顶级域名服务器的地址<code>.xxx.com</code></li><li>DNS服务器向顶级域名服务器发送请求，顶级域名返回二级域名的服务器地址<code>.baidu.com</code></li><li>DNS服务器向二级域名服务器发送请求，得到主机地址，存入自身缓存并返回客户</li></ol></li></ul></li></ol><h2 id="TCP握手"><a href="#TCP握手" class="headerlink" title="TCP握手"></a>TCP握手</h2><p>对应IP地址，端口建立TCP连接，构造HTTP请求并与服务器握手后发送tcp数据包</p><p>  TCP三次握手</p><ol><li>client 发送<code>SYN</code>报文，指明自己的初始化序列号<code>ISN(c)</code></li><li>server 收到后，将client发送的<code>ISN(c)</code>+1作为<code>ACK</code>字符，并且也生成自己的`ISN(s)送回【确认客户端和服务端的发送能力】</li><li>client 收到后，同样将<code>ISN(s)</code>+1作为<code>ACK</code>字符发送给server【确认客户端和客户端的能力】</li></ol><h2 id="应用缓存策略"><a href="#应用缓存策略" class="headerlink" title="应用缓存策略"></a>应用缓存策略</h2><ul><li>强缓存</li><li>协商缓存</li></ul><h2 id="服务器响应请求返回资源"><a href="#服务器响应请求返回资源" class="headerlink" title="服务器响应请求返回资源"></a>服务器响应请求返回资源</h2><h2 id="DOM-Tree"><a href="#DOM-Tree" class="headerlink" title="DOM Tree"></a>DOM Tree</h2><ul><li>处理html标记，生成DOM树，所有标签都会包含在内</li><li>解析完一个节点的所有子元素才会解析他的兄弟元素</li><li>构建过程中遇到js则执行js，暂停构建</li></ul><h2 id="CSSOM-Tree"><a href="#CSSOM-Tree" class="headerlink" title="CSSOM Tree"></a>CSSOM Tree</h2><ul><li>构建过程中遇到js，js要等待CSSOM构建完才会执行</li><li>CSS阻塞渲染<blockquote><p>由于CSSOM负责存储渲染信息，浏览器必须保证在合成渲染树之前，CSSOM是完整的，这种完备是指所有的CSS（内联、内部和外部）都已经下载完，并解析完，只有CSSOM和DOM的解析完全结束，浏览器才会进入下一步的渲染，这就是传说中的CSS阻塞渲染。</p></blockquote></li></ul><h2 id="Render-Tree"><a href="#Render-Tree" class="headerlink" title="Render Tree"></a>Render Tree</h2><ul><li>只包含DOM树中的可见元素(忽略像<code>display：none/&lt;header&gt;</code>)</li><li>找到与其匹配的CSSOM规则并应用</li></ul><h2 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h2><p>浏览器依据Render树和设备屏幕信息<strong>重排</strong>一次，计算出每个节点的尺寸和在屏幕上的位置</p><h2 id="Paint"><a href="#Paint" class="headerlink" title="Paint"></a>Paint</h2><p>根据上一步得到的像素信息<strong>重绘</strong>页面</p><h2 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h2><p>GPU合成各图层，显示在屏幕上</p><hr><h1 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h1><h2 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h2><ul><li>从 <code>&lt;html&gt;标签</code> 开始递归往下，依次计算所有的节点几何尺寸和位置</li><li>有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow，而是会把这样的操作积攒一批，然后做一次 处理，这又叫异步 reflow 或增量异步 reflow。但是在有些情况下，比如resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。</li><li>除了渲染树的直接变化，当获取一些需要计算的属性时，浏览器为取得 正确的值也会触发重排。这样就使得浏览器的优化失效了。</li><li>这些属性包括：<code>offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、 clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。</code></li><li>重排必定触发重绘</li></ul><h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><p>改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重绘，但是元素的几何尺寸没有变。</p><h2 id="合成层"><a href="#合成层" class="headerlink" title="合成层"></a>合成层</h2><p>区别于一般的图层，合成层【composite】使用GPU线程进行处理</p><h3 id="CSS3动画"><a href="#CSS3动画" class="headerlink" title="CSS3动画"></a>CSS3动画</h3><ul><li>动画提升到合成层处理，不占用 JS 主线程</li><li>浏览器对CSS3动画有优化</li><li>不触发重绘和重排<blockquote><p>如果两张图层内部没有发生改变，浏览器就不再进行布局和绘制，直接使用GPU的缓存来绘制，GPU只负责将各个图层合成来实现动画，这就可以充分利用GPU的资源和优势，减轻CPU的负载，可以使动画更流畅。</p></blockquote></li></ul><h3 id="提升到合成层的条件"><a href="#提升到合成层的条件" class="headerlink" title="提升到合成层的条件"></a>提升到合成层的条件</h3><ul><li>3D<code>transform</code></li><li><code>opacity</code></li><li><code>filter</code></li><li><code>will-change</code></li><li><code>&lt;video&gt;,&lt;audio&gt;,&lt;canvas&gt;</code></li><li><code>position:fixed</code></li></ul><h2 id="优化页面性能"><a href="#优化页面性能" class="headerlink" title="优化页面性能"></a>优化页面性能</h2><ol><li>CSS阻塞优化，配合媒体查询，分割首屏CSS文件，余下使用link引入样式</li><li>DOM样式通过class修改</li><li>DOM离线后修改（<code>display:none</code>,<code>Document Fragment</code>）或者使用虚拟DOM</li><li>减少获取DOM位置信息像offsetHeight（导致立即重排），或者加入循环。。。</li><li>table布局会疯狂触发重排</li><li>合理使用GPU加速<ul><li> <code>translate</code>代替修改几何信息<code>left,top...</code></li><li> <code>opacity</code>代替<code>visibility</code></li><li> 动画元素脱离文档流<code>position:absolute/fixed</code></li><li> <code>will-change</code>属性</li></ul></li></ol><h2 id="解析URL参数"><a href="#解析URL参数" class="headerlink" title="解析URL参数"></a>解析URL参数</h2><ol><li><p>正则解析</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> rule = <span class="hljs-regexp">/([^?=&amp;]+)=([^&amp;#]*)/g</span>&lt;!-- (匹配非[?=&amp;]且出现多次的字符) --&gt;&lt;!-- = --&gt;&lt;!-- (匹配出现<span class="hljs-number">0</span>次或多次的非[&amp;]的字符) --&gt;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseURL</span>(<span class="hljs-params">url</span>)</span>&#123;  <span class="hljs-keyword">return</span> url.match(rule).reduce(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>&#123;    <span class="hljs-keyword">let</span> [key,value] = b.split(<span class="hljs-string">&#x27;=&#x27;</span>)    key = <span class="hljs-built_in">decodeURIComponent</span>(key)    value = <span class="hljs-built_in">decodeURIComponent</span>(value)    <span class="hljs-keyword">if</span>(!a.hasOwnProperty(key))&#123;      a[key] = value    &#125;<span class="hljs-keyword">else</span>&#123;      a[key] = [].concat(value,a[key])    &#125;    <span class="hljs-keyword">return</span> a  &#125;,&#123;&#125;)&#125;</code></pre></div></li><li><p>API解析</p><p> URLSearchParams<br> <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams">https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams</a></p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseURL</span>(<span class="hljs-params">url</span>)</span>&#123;  <span class="hljs-keyword">const</span> urlObj = <span class="hljs-keyword">new</span> URLSearchParams(url.slice(url.indexOf(<span class="hljs-string">&#x27;?&#x27;</span>)))  <span class="hljs-keyword">const</span> res = []  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> urlObj.keys())&#123;    res[key] = urlObj.getAll(key)  &#125;  <span class="hljs-keyword">return</span> res&#125;</code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件夹内批量映射为模块</title>
    <link href="/2021/04/06/%E6%89%B9%E9%87%8F%E6%98%A0%E5%B0%84%E6%A8%A1%E5%9D%97/"/>
    <url>/2021/04/06/%E6%89%B9%E9%87%8F%E6%98%A0%E5%B0%84%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript">./controllers中controllerA.jscontrollerB.jscontrollerC.js</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript">./controllers/index.js<span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>)<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-comment">/**</span><span class="hljs-comment"> * 映射文件夹下的文件为模块</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> mapDir = <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> tree = &#123;&#125;    <span class="hljs-comment">// 获得当前文件夹下的所有的文件夹和文件</span>    <span class="hljs-keyword">const</span> [dirs, files] = _(fs.readdirSync(d))        .partition(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> fs.statSync(path.join(d, p)).isDirectory())    <span class="hljs-comment">// _(value)</span>    <span class="hljs-comment">// 创建一个经 lodash 包装后的对象会启用隐式链。返回的数组、集合、方法相互之间能够链式调用</span>        <span class="hljs-comment">// 递归映射文件夹</span>    dirs.forEach(<span class="hljs-function"><span class="hljs-params">dir</span> =&gt;</span> &#123;        tree[dir] = mapDir(path.join(d, dir))    &#125;)    <span class="hljs-comment">// 映射文件</span>    files.forEach(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (path.extname(file) === <span class="hljs-string">&#x27;.js&#x27;</span>) &#123;            tree[path.basename(file, <span class="hljs-string">&#x27;.js&#x27;</span>)] = <span class="hljs-built_in">require</span>(path.join(d, file))        &#125;    &#125;)    <span class="hljs-keyword">return</span> tree&#125;<span class="hljs-comment">// 默认导出当前文件夹下的映射</span><span class="hljs-built_in">module</span>.exports = mapDir(path.join(__dirname))</code></pre></div><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> controllers = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../controllers&quot;</span>);router.get(<span class="hljs-string">&#x27;/A&#x27;</span>,controllers.controllerA)router.post(<span class="hljs-string">&#x27;/B&#x27;</span>,controllers.controllerB)router.post(<span class="hljs-string">&#x27;/C&#x27;</span>,controllers.controllerC)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>div高度为高度一半</title>
    <link href="/2021/04/04/div%E9%AB%98%E5%BA%A6%E4%B8%BA%E9%AB%98%E5%BA%A6%E4%B8%80%E5%8D%8A/"/>
    <url>/2021/04/04/div%E9%AB%98%E5%BA%A6%E4%B8%BA%E9%AB%98%E5%BA%A6%E4%B8%80%E5%8D%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="position属性"><a href="#position属性" class="headerlink" title="position属性"></a>position属性</h2><ul><li><code>static</code><ul><li>正常流，默认值</li><li>top, right, bottom, left 和 z-index 属性无效。</li></ul></li><li><code>relative</code><ul><li>相对正常流偏移</li><li>原位置有预留空间</li></ul></li><li><code>absolute</code><ul><li>移出正常文档流</li><li>相对于最近的非 static 定位祖先元素偏移</li><li>不为元素预留空间</li></ul></li><li><code>fixed</code><ul><li>移出正常文档流</li><li>相对于屏幕视口（viewport）的位置来指定元素位置</li><li>不为元素预留空间<blockquote><p>当元素祖先的 transform, perspective 或 filter 属性非 none 时，容器由视口改为该祖先。</p></blockquote></li></ul></li><li><code>sticky</code><ul><li>相对定位和固定定位的混合</li><li>须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</li><li>跨越特定阈值前为相对定位，之后为固定定位</li></ul></li></ul><h2 id="包含块"><a href="#包含块" class="headerlink" title="包含块"></a>包含块</h2><h3 id="包含块的作用"><a href="#包含块的作用" class="headerlink" title="包含块的作用"></a>包含块的作用</h3><p>  元素的尺寸及位置，常常会受它的包含块所影响。对于一些属性，例如 width,height, padding, margin，绝对定位元素的偏移值 （比如 position 被置为 absolute 或 fixed），当我们对其赋予百分比值时，这些值的计算值就是通过元素的包含块计算得来</p><h3 id="确定包含块"><a href="#确定包含块" class="headerlink" title="确定包含块"></a>确定包含块</h3><blockquote><p>一个元素的包含块并不一定父元素的内容区</p></blockquote><p>元素的包含块由其<code>position</code>决定：</p><ul><li><code>static 、 relative 或 sticky </code>，包含块可能由它的最近的祖先块元素（比如说inline-block, block 或 list-item元素）的内容区的边缘组成<code>content</code></li><li><code>absolute</code> ，包含块就是由它的最近的 <code>position 的值不是 static</code> （也就是值为fixed, absolute, relative 或 sticky）的祖先元素的内边距区的边缘组成<code>content+padding</code></li><li><code>fixed</code>，在连续媒体的情况下(continuous media)包含块是 viewport ,在分页媒体(paged media)下的情况下包含块是分页区域(page area)。<blockquote><p>当元素祖先的 transform, perspective 或 filter 属性非 none 时,包含块是这个元素的内边距区 content+padding</p></blockquote></li></ul><h3 id="根据包含块计算"><a href="#根据包含块计算" class="headerlink" title="根据包含块计算"></a>根据包含块计算</h3><ul><li>要计算 <code>height</code> <code>top</code> 及 <code>bottom</code> 中的百分值，是通过包含块的 <code>height</code> 的值</li><li>要计算 <code>width</code>, <code>left</code>, <code>right</code>, <strong><code>padding</code>!, <code>margin</code></strong> 这些属性由包含块的 <code>width</code> 属性的值来计算它的百分值。</li></ul><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ol><li><p>实现一个div垂直水平居中高度为宽度的一半自适应</p><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 外层wrapper */</span><span class="hljs-selector-class">.outer-wrapper</span>&#123;  <span class="hljs-attribute">height</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">display</span>:flex;  <span class="hljs-comment">/* flex默认行排列，所以这里设置侧轴对齐 */</span>  <span class="hljs-attribute">align-items</span>:center&#125;<span class="hljs-comment">/* 内层wrapper */</span><span class="hljs-selector-class">.inner-wrapper</span>&#123;  <span class="hljs-attribute">position</span>:relative;  <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">padding-bottom</span>:<span class="hljs-number">50%</span>;  <span class="hljs-comment">/* padding,margin值的百分比是相较于父元素width */</span>&#125;<span class="hljs-selector-class">.div</span>&#123;  <span class="hljs-attribute">position</span>:absolute;  <span class="hljs-comment">/* 两个position设置都是为了确定包含块 */</span>  <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">100%</span>;  <span class="hljs-comment">/* 这里的高度就=inner-wrapper[height+padding] */</span>&#125;</code></pre></div></li><li><p>实现div正方形大小自适应</p></li></ol><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span>&#123;  <span class="hljs-attribute">position</span>:relative;  <span class="hljs-attribute">padding-top</span>:<span class="hljs-number">50%</span>;  <span class="hljs-attribute">width</span>:<span class="hljs-number">50%</span>;  <span class="hljs-comment">/* 同样相较于包含块的尺寸百分比 */</span>&#125;<span class="hljs-selector-class">.div</span>&#123;  <span class="hljs-attribute">position</span>:absolute;  <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;  <span class="hljs-comment">/* 偏移到wrapper位置 */</span>  <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">100%</span>;&#125;<span class="hljs-comment">/* 也可使用伪元素撑开高度 */</span><span class="hljs-selector-class">.div</span>&#123;  <span class="hljs-attribute">width</span>:<span class="hljs-number">50%</span>;  <span class="hljs-comment">/* 触发BFC避免塌陷 */</span>  <span class="hljs-comment">/* overflow不为visible */</span>  <span class="hljs-comment">/* position为fixed,absolute[绝对定位] */</span>  <span class="hljs-comment">/* float不为none[浮动元素] */</span>  <span class="hljs-comment">/* flex/grid/table */</span>  <span class="hljs-attribute">display</span>:flow-root&#125;<span class="hljs-selector-class">.div</span><span class="hljs-selector-pseudo">::after</span>&#123;  <span class="hljs-attribute">content</span>:<span class="hljs-string">&#x27;&#x27;</span>;  <span class="hljs-attribute">margin-top</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">display</span>:block&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axios</title>
    <link href="/2021/01/27/axios/"/>
    <url>/2021/01/27/axios/</url>
    
    <content type="html"><![CDATA[<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><ul><li><p>拦截器中可以修改config和response</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">axios.interceptors.request.use(  (config) =&gt; &#123;    &lt;!-- 加入参数 --&gt;    config.params = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">666</span>&#125;    <span class="hljs-keyword">return</span> config  &#125;,  (err) =&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(err)  &#125;);</code></pre></div></li><li><p>执行顺序</p><ul><li>请求拦截器 后面的拦截器先执行</li><li>响应拦截器 前面的拦截器先执行</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">axios.interceptors.request.use(<span class="hljs-function"><span class="hljs-params">config</span>=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;request1&#x27;</span>)&#125;,<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;err1&#x27;</span>)&#125;)axios.interceptors.request.use(<span class="hljs-function"><span class="hljs-params">config</span>=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;request2&#x27;</span>)&#125;,<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;err2&#x27;</span>)&#125;)axios.interceptors.response.use(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;response1&#x27;</span>)&#125;，err=&gt;&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;resErr1&#x27;</span>)&#125;)axios.interceptors.response.use(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;response2&#x27;</span>)&#125;，err=&gt;&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;resErr2&#x27;</span>)&#125;)&lt;!-- <span class="hljs-built_in">console</span> --&gt;request2request1response1response2</code></pre></div></li><li><p>取消请求</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> CancelToken = axios.CancelToken;<span class="hljs-keyword">let</span> cancel = <span class="hljs-literal">null</span>btn.onclick = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">if</span>(cancel !== <span class="hljs-literal">null</span>) cancel()  &lt;!-- 执行取消函数 --&gt;  axios(&#123;    method:<span class="hljs-string">&#x27;GET&#x27;</span>,    url:<span class="hljs-string">&#x27;http://xxxxxxx&#x27;</span>,    &lt;!--  --&gt;    cancelToken : <span class="hljs-keyword">new</span> CancelToken(<span class="hljs-function"><span class="hljs-params">c</span>=&gt;</span>&#123;      cancel = c      &lt;!-- cancelToken --&gt;    &#125;)  &#125;)&#125;.then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;  cancel = <span class="hljs-literal">null</span>&#125;)</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打包优化</title>
    <link href="/2020/11/30/%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/"/>
    <url>/2020/11/30/%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><ul><li>静态模块打包工具</li><li>高效处理开发过程中的各种类型资源</li><li>管理模块依赖，输出优化后的静态文件</li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li><code>Entry</code>  加载入口资源，分析其依赖关系并建立依赖图</li><li><code>Loader</code> webpack自己只能处理js文件，loader提供了处理其他文件类型的能力<ul><li>css预处理器</li><li>babel转译</li></ul></li><li><code>Plugin</code> 打包过程中不同阶段可使用插件执行特定操作，为webpack增加不同功能<ul><li>devserver</li><li>热更新</li><li>代码分割</li><li>代码压缩</li></ul></li><li><code>Output</code><br> 指定名称和位置输出打包结果<h1 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h1><h2 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h2><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Router(&#123;  routes: [    &#123;      path: <span class="hljs-string">&#x27;/home&#x27;</span>,      component: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/home&#x27;</span>),    &#125;,    &#123;      path: <span class="hljs-string">&#x27;/about&#x27;</span>,      component: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/home&#x27;</span>),    &#125;,  ],&#125;)</code></pre></div><h2 id="按需引入"><a href="#按需引入" class="headerlink" title="按需引入"></a>按需引入</h2><ol><li>elementui官网配置方法不适用</li><li>vuecli中babel配置文件为<code>babel.config.js</code></li><li>安装<code>babel-plugin-component</code></li><li>配置<code>babel.config.js</code></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;  presets: [    <span class="hljs-string">&#x27;@vue/cli-plugin-babel/preset&#x27;</span>  ],  plugins: [    [      <span class="hljs-string">&quot;component&quot;</span>,<span class="hljs-comment">// 插件位置</span>      &#123;        <span class="hljs-string">&quot;libraryName&quot;</span>: <span class="hljs-string">&quot;element-ui&quot;</span>,        <span class="hljs-string">&quot;styleLibraryName&quot;</span>: <span class="hljs-string">&quot;theme-chalk&quot;</span>      &#125;    ]  ]&#125;</code></pre></div><ul><li>修改<code>main.js</code><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; MenuItem,Container,Header,Aside,Main,Input,Footer,Avatar, Menu, Table, TableColumn, Pagination ,Button&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;element-ui&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> [MenuItem,Container,Header,Aside,Main,Input,Footer,Avatar, Menu, Table, TableColumn, Pagination,Button]) &#123;  Vue.use(item);&#125;</code></pre></div></li><li>也可以单独独立出自定义组件,二次封装<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// eleui.js</span><span class="hljs-keyword">import</span> &#123; MenuItem,Container,Header,Aside,Main,Input,Footer,Avatar, Menu, Table, TableColumn, Pagination ,Button&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;element-ui&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  install : <span class="hljs-function">(<span class="hljs-params">Vue</span>) =&gt;</span> &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> co <span class="hljs-keyword">of</span> [MenuItem,Container,Header,Aside,Main,Input,Footer,Avatar, Menu, Table, TableColumn, Pagination ,Button])&#123;      Vue.use(co)    &#125;  &#125;&#125;<span class="hljs-comment">// main.js</span><span class="hljs-keyword">import</span> eleUI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./eleUI.js&#x27;</span>Vue.use(eleUI)</code></pre></div><h2 id="抽离组件库-代码分割"><a href="#抽离组件库-代码分割" class="headerlink" title="抽离组件库(代码分割)"></a>抽离组件库(代码分割)</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;  chainWebpack: <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;      config.optimization.splitChunks(&#123;        chunks: <span class="hljs-string">&#x27;all&#x27;</span>,        cacheGroups: &#123;          vendors: &#123;            name: <span class="hljs-string">&#x27;chunk-vendors&#x27;</span>,            test: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,            priority: <span class="hljs-number">10</span>,            chunks: <span class="hljs-string">&#x27;initial&#x27;</span>          &#125;,          echarts: &#123;            name: <span class="hljs-string">&#x27;chunk-echarts&#x27;</span>,            priority: <span class="hljs-number">20</span>,            test: <span class="hljs-regexp">/[\\/]node_modules[\\/]_?echarts(.*)/</span>          &#125;        &#125;      &#125;)    &#125;&#125;</code></pre></div><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2></li></ul><ol><li>安装<code>html-webpack-plugin</code></li><li>修改<code>public/index.html</code><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    &lt;meta      name=&quot;viewport&quot;      content=&quot;width=device-width,initial-scale=1.0,user-scalable=no&quot;    /&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;</span> /&gt;</span>    <span class="hljs-comment">&lt;!-- 使用CDN的CSS文件 --&gt;</span>    &lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp;    htmlWebpackPlugin.options.cdn.css) &#123; %&gt;    &lt;link      href=&quot;&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot;      rel=&quot;preload&quot;      as=&quot;style&quot;    /&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> /&gt;</span>    &lt;% &#125; %&gt;    <span class="hljs-comment">&lt;!-- 使用CDN的CSS文件 --&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span>      &lt;strong        &gt;We&#x27;re sorry but moviapp doesn&#x27;t work properly without JavaScript        enabled. Please enable it to continue.&lt;/strong      &gt;    <span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- built files will be auto injected --&gt;</span>    <span class="hljs-comment">&lt;!-- 使用CDN的JS文件 --&gt;</span>    &lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp;    htmlWebpackPlugin.options.cdn.js) &#123; %&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&lt;%= htmlWebpackPlugin.options.cdn.js[i] %&gt;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    &lt;% &#125; %&gt;    <span class="hljs-comment">&lt;!-- 使用CDN的JS文件 --&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div></li></ol><ul><li>配置<code>vue.config.js</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 判断生产环境</span><span class="hljs-keyword">const</span> isProduction = process.env.NODE_ENV === <span class="hljs-string">&quot;production&quot;</span>;<span class="hljs-keyword">const</span> cdn = &#123;  <span class="hljs-comment">// 随便抓几个</span>  js: [    <span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.0/vue.runtime.esm.js&quot;</span>,    <span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/vue-router/3.1.3/vue-router.esm.js&quot;</span>  ],&#125;;<span class="hljs-built_in">module</span>.exports = &#123;  configureWebpack: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (isProduction) &#123;      config.externals = &#123;        <span class="hljs-comment">// 排除的依赖，不从bundle中引入的依赖</span>        <span class="hljs-string">&quot;vue&quot;</span>: <span class="hljs-string">&quot;Vue&quot;</span>,        <span class="hljs-string">&quot;vue-router&quot;</span>: <span class="hljs-string">&quot;VueRouter&quot;</span>      &#125;;    &#125;  &#125;,  chainWebpack: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (isProduction) &#123;      config.plugin(<span class="hljs-string">&quot;html&quot;</span>).tap(<span class="hljs-function">(<span class="hljs-params">args</span>) =&gt;</span> &#123;        <span class="hljs-comment">// 传递给 html-webpack-plugin&#x27;s 构造函数的新参数</span>        args[<span class="hljs-number">0</span>].cdn = cdn;        <span class="hljs-keyword">return</span> args;      &#125;);    &#125;  &#125;,&#125;;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue的diff算法</title>
    <link href="/2020/11/25/vue_diff%E7%AE%97%E6%B3%95/"/>
    <url>/2020/11/25/vue_diff%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>diff算法，包含渲染器如何对各种类型的vNode的属性，text，fragment进行patch更新，以及判断是patch vNode，还是新增还是删除</li><li>同级比较</li></ul><h3 id="基础的diff"><a href="#基础的diff" class="headerlink" title="基础的diff"></a>基础的diff</h3><ul><li>新节点没有子节点-&gt;删除久的</li><li>新节点只有一个子节点-&gt;删除旧的并添加新的</li></ul><h3 id="核心diff"><a href="#核心diff" class="headerlink" title="核心diff"></a>核心diff</h3><ul><li>新旧节点都有多个子节点</li></ul><h4 id="没有key"><a href="#没有key" class="headerlink" title="没有key"></a>没有key</h4><ul><li>就地更新<h4 id="key的作用"><a href="#key的作用" class="headerlink" title="key的作用"></a>key的作用</h4></li><li>vNode中的唯一标识符</li><li>用于保存新旧vNode的映射关系</li><li>找到可复用的vNode</li><li>用移动节点达到更新目的⭐️</li></ul><h4 id="React-最大索引值k"><a href="#React-最大索引值k" class="headerlink" title="React 最大索引值k"></a>React 最大索引值k</h4><ul><li>两次循环，遍历新node去旧node中寻找新vnode位置</li><li>如果索引呈现递增趋势<div class="hljs code-wrapper"><pre><code class="hljs javascript">old: key1 key2 key3<span class="hljs-keyword">new</span>: key1 key2 key3</code></pre></div>（newA-&gt;oldA=&gt;0,newB-&gt;oldB=&gt;1,newC-&gt;oldC=&gt;2）则说明新旧 children 中节点顺序相同，不需要移动操作。相反的，如果在寻找的过程中遇到的索引值不呈现递增趋势，则说明需要移动操作</li><li>如果匹配过程中递增规律被打破</li></ul>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">old: key2 key3 key1<span class="hljs-keyword">new</span>: key1 key2 key3k = <span class="hljs-number">2</span> 之前的所有节点都需要移动</code></pre></div><p>  <code>k</code>为在旧 children 中所遇到的最大索引值，则后续匹配的索引小于这个值意味着都需要移动</p><h3 id="Vue-双端比较-snabbdom"><a href="#Vue-双端比较-snabbdom" class="headerlink" title="Vue 双端比较 snabbdom"></a>Vue 双端比较 snabbdom</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">(oStart)               [oEnd] oldA   oldB   oldC    oldD newB   newC   newD    newA(nStart)               [nEnd]<span class="hljs-comment">// oStart与nEnd匹配上了key，将oldA的DOM移动到新dom最后</span>      (oStart)        [oEnd] oldA   oldB   oldC    oldD ｜  ----------------------&gt;                        ｜ newB   newC   newD    newA(nStart)      [nEnd]</code></pre></div><ul><li><p>vue同时从新旧children的两端开始比较</p></li><li><p>四个指针，分别查找是否key相同</p></li><li><p>匹配到了相同的key，则将真实dom移动,同时四个指针对撞移动</p></li><li><p>如果第一轮四次匹配不上，则遍历旧node寻找<code>nStart</code></p></li><li><p>if 找到将其真实DOM移动到<code>oStart</code>之前，并在原vnode位置置空undefined，后序比较会跳过他</p></li><li><p>else 找不到则添加新增新元素<code>nStart</code>到<code>oStart</code>之前</p></li><li><p>匹配结束后<code>oEnd&lt;oStart</code>,新增<code>nStart到nEnd</code>新元素到<code>oStart</code>之前</p></li><li><p>匹配结束后<code>nStart&gt;nEnd</code>,删除<code>oStart到oEnd</code>之间元素</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isUndef</span> (<span class="hljs-params">v</span>) </span>&#123;  <span class="hljs-keyword">return</span> v === <span class="hljs-literal">undefined</span> || v === <span class="hljs-literal">null</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isDef</span> (<span class="hljs-params">v</span>) </span>&#123;  <span class="hljs-keyword">return</span> v !== <span class="hljs-literal">undefined</span> &amp;&amp; v !== <span class="hljs-literal">null</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sameVnode</span> (<span class="hljs-params">a, b</span>) </span>&#123;  <span class="hljs-keyword">return</span> (    a.key === b.key &amp;&amp; (      (        a.tag === b.tag &amp;&amp;        a.isComment === b.isComment &amp;&amp;        isDef(a.data) === isDef(b.data) &amp;&amp;        !childrenIgnored(a) &amp;&amp; !childrenIgnored(b) &amp;&amp;        sameInputType(a, b)      ) || (        isTrue(a.isAsyncPlaceholder) &amp;&amp;        a.asyncFactory === b.asyncFactory &amp;&amp;        isUndef(b.asyncFactory.error)      )    )  )&#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateChildren</span> (<span class="hljs-params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;    <span class="hljs-keyword">let</span> oldStartIdx = <span class="hljs-number">0</span>    <span class="hljs-keyword">let</span> newStartIdx = <span class="hljs-number">0</span>    <span class="hljs-keyword">let</span> oldEndIdx = oldCh.length - <span class="hljs-number">1</span>    <span class="hljs-keyword">let</span> oldStartVnode = oldCh[<span class="hljs-number">0</span>]    <span class="hljs-keyword">let</span> oldEndVnode = oldCh[oldEndIdx]    <span class="hljs-keyword">let</span> newEndIdx = newCh.length - <span class="hljs-number">1</span>    <span class="hljs-keyword">let</span> newStartVnode = newCh[<span class="hljs-number">0</span>]    <span class="hljs-keyword">let</span> newEndVnode = newCh[newEndIdx]    <span class="hljs-keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm    <span class="hljs-keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;      <span class="hljs-keyword">if</span> (isUndef(oldStartVnode)) &#123;        oldStartVnode = oldCh[++oldStartIdx] <span class="hljs-comment">// Vnode has been moved left</span>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isUndef(oldEndVnode)) &#123;        oldEndVnode = oldCh[--oldEndIdx]      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)        oldStartVnode = oldCh[++oldStartIdx]        newStartVnode = newCh[++newStartIdx]      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)        oldEndVnode = oldCh[--oldEndIdx]        newEndVnode = newCh[--newEndIdx]      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="hljs-comment">// Vnode moved right</span>      <span class="hljs-comment">// 说明oldStartVnode节点更新后要移动去末尾位置</span>        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))        oldStartVnode = oldCh[++oldStartIdx]        newEndVnode = newCh[--newEndIdx]      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="hljs-comment">// Vnode moved left</span>      <span class="hljs-comment">// 说明oldEndVnode节点更新后要移动到最前方</span>        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)        oldEndVnode = oldCh[--oldEndIdx]        newStartVnode = newCh[++newStartIdx]      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)        <span class="hljs-comment">// oldKeyToIndex是旧节点的key2index映射map</span>        idxInOld = isDef(newStartVnode.key)          ? oldKeyToIdx[newStartVnode.key]          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)          <span class="hljs-comment">// 去旧节点中寻找newStartVnode</span>        <span class="hljs-keyword">if</span> (isUndef(idxInOld)) &#123; <span class="hljs-comment">// 找不到则新增newStartVnode元素到oldStart之前</span>          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="hljs-literal">false</span>, newCh, newStartIdx)        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 找得到则进行移动</span>          vnodeToMove = oldCh[idxInOld]          <span class="hljs-keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)            oldCh[idxInOld] = <span class="hljs-literal">undefined</span>            <span class="hljs-comment">// 将旧节点中匹配到的位置置空，以后的查找会跳过</span>            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)            <span class="hljs-comment">// 匹配到的节点移动到oldStart之前</span>          &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// key相同但不是同一种元素</span>            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="hljs-literal">false</span>, newCh, newStartIdx)          &#125;        &#125;        newStartVnode = newCh[++newStartIdx]      &#125;    &#125;    <span class="hljs-comment">// 跳出匹配后</span>    <span class="hljs-keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;      refElm = isUndef(newCh[newEndIdx + <span class="hljs-number">1</span>]) ? <span class="hljs-literal">null</span> : newCh[newEndIdx + <span class="hljs-number">1</span>].elm      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)    &#125;  &#125;</code></pre></div><h3 id="Vue3的inferno"><a href="#Vue3的inferno" class="headerlink" title="Vue3的inferno"></a>Vue3的inferno</h3></li><li><p>排除相同的前置和后置元素</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">[j]   [preEnd] |       | a   b   c |       |-------------- |           | a   e   b   c |           |   [j]       [nextEnd][j][preEnd] |   | a   b   c |   |---------------- |         | a  【e】   b   c |         |   [j]     [nextEnd]</code></pre></div><ul><li>分别从新旧节点的头和尾出发</li><li>依次遍历到key值不一样时停止 </li><li>这样匹配成功后剩下的部分就是需要新增/删除的vNode</li></ul></li><li><p>使用剩余新children的长度建立source索引数组</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">oldChildren = [b,c,d,f]newChildren = [c,d,b,g]  <span class="hljs-comment">// 默认全为-1</span>source = [-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>]<span class="hljs-comment">//为新vnode建立key，index索引表</span>keyIndex = &#123;<span class="hljs-attr">c</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">d</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">g</span>:<span class="hljs-number">3</span>&#125;<span class="hljs-comment">// 遍历旧children中key去keyIndex中查找，有这个key则把该位置的-1改为旧vNode的索引，并且patch该节点  </span>source = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>]</code></pre></div></li><li><p>判断是否需要移动</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">source = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>]<span class="hljs-comment">//source中，最大索引为2，2之后有小于2的索引，说明需要移动</span></code></pre></div></li><li><p>根据source数组求出最长递增子序列</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">LIS = [<span class="hljs-number">0</span>，<span class="hljs-number">1</span>]<span class="hljs-comment">// LIS中存储的是source索引</span><span class="hljs-comment">// 表示新旧children中这几个节点递增</span></code></pre></div></li><li><p>根据LIS得出不进行移动的节点</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">newChildren[LIS] = [c,d]</code></pre></div></li><li><p>从LIS和新children尾处建立指针处理余下节点</p></li></ul><blockquote><p>最长上升子序列</p></blockquote><ul><li>子序列：不要求连续</li><li>字串：要求连续</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 动态规划</span><span class="hljs-keyword">const</span> longestChildSequence = <span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> &#123;  <span class="hljs-keyword">let</span> len = arr.length  <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>  <span class="hljs-keyword">const</span> dp = <span class="hljs-built_in">Array</span>(len).fill(<span class="hljs-number">1</span>)  <span class="hljs-comment">// dp[i]代表原始数组该位置的最长子序列长度</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span> ; i &lt; len ; i++)&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span> ; j &lt; i ; j++)&#123;      <span class="hljs-comment">// j遍历之前遍历过的所有元素</span>      <span class="hljs-comment">// 可能存在大小不一的递增序列，使用max取得最大值</span>      <span class="hljs-keyword">if</span>(arr[i] &gt; arr [j])&#123;        dp[i] = <span class="hljs-built_in">Math</span>.max(dp[i],dp[j]+<span class="hljs-number">1</span>)        <span class="hljs-comment">// [1,2,3,4,1,2,5]</span>        <span class="hljs-comment">// 如果只使用dp[j]+1 ，dp[6]会在[1,2,5]中得出结果3</span>        <span class="hljs-comment">// 使用max比较之前更长的序列[1，2，3，4，5]得到5</span>      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(...dp)&#125;<span class="hljs-comment">// 贪心+二分</span><span class="hljs-keyword">const</span> longestChildSequence = <span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> &#123;  <span class="hljs-keyword">let</span> len = arr.length  <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>  <span class="hljs-keyword">const</span> res = [arr[<span class="hljs-number">0</span>]]  <span class="hljs-comment">//将arr中后续元素arr[i]与res末尾元素比较</span>  <span class="hljs-comment">//大于则push进res</span>  <span class="hljs-comment">//小于则查找res中第一个比arr[i]大的元素并替换</span>  <span class="hljs-comment">//由于存在替换，子序列值不一定正确，但长度是正确的</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i&lt; len ;i++)&#123;    <span class="hljs-keyword">if</span>(arr[i]&gt;res[res.length-<span class="hljs-number">1</span>])&#123;      res.push(arr[i])    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">// res中左右指针的index</span>      <span class="hljs-comment">// 二分查找</span>      <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>      <span class="hljs-keyword">let</span> right = res.length - <span class="hljs-number">1</span>      <span class="hljs-keyword">while</span>(left&lt;right)&#123;        <span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">Math</span>.floor((left+right)/<span class="hljs-number">2</span>)        <span class="hljs-comment">// let mid = ((left+right)/2) | 0</span>        <span class="hljs-comment">// 浮点小数向下求整</span>        <span class="hljs-keyword">if</span>(arr[i]&gt;res[mid])&#123;          left = mid + <span class="hljs-number">1</span>        &#125;<span class="hljs-keyword">else</span>&#123;          right = mid        &#125;      &#125;      res[left] = arr[i]    &#125;  &#125;  <span class="hljs-keyword">return</span> res.length &#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>vue</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node下单文件模块批量映射到处</title>
    <link href="/2020/11/20/node%E4%B8%8B%E7%9A%84%E6%89%B9%E9%87%8F%E6%98%A0%E5%B0%84/"/>
    <url>/2020/11/20/node%E4%B8%8B%E7%9A%84%E6%89%B9%E9%87%8F%E6%98%A0%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<p><img src="../images/controllers.png" alt="controllers"></p><ul><li><p>以koa为例</p></li><li><p>controllers写成单文件</p></li><li><p>使用index.js批量映射</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//index.js</span><span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>)<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-comment">/**</span><span class="hljs-comment"> * 映射文件夹下的文件为模块</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> mapDir = <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> tree = &#123;&#125;    <span class="hljs-comment">// 获得当前文件夹下的所有的文件夹和文件</span>    <span class="hljs-keyword">const</span> [dirs, files] = _(fs.readdirSync(d))        .partition(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> fs.statSync(path.join(d, p)).isDirectory())    <span class="hljs-comment">// _( ...)</span>    <span class="hljs-comment">// 创建一个经 lodash 包装后的对象会启用隐式链。返回的数组、集合、方法相互之间能够链式调用</span>        <span class="hljs-comment">// 递归映射文件夹</span>    dirs.forEach(<span class="hljs-function"><span class="hljs-params">dir</span> =&gt;</span> &#123;        tree[dir] = mapDir(path.join(d, dir))    &#125;)    <span class="hljs-comment">// 映射文件</span>    files.forEach(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (path.extname(file) === <span class="hljs-string">&#x27;.js&#x27;</span>) &#123;            tree[path.basename(file, <span class="hljs-string">&#x27;.js&#x27;</span>)] = <span class="hljs-built_in">require</span>(path.join(d, file))        &#125;    &#125;)    <span class="hljs-keyword">return</span> tree&#125;<span class="hljs-built_in">module</span>.exports = mapDir(path.join(__dirname<span class="hljs-comment">//当前文件夹目录))</span></code></pre></div></li><li><p>使用时候只需require(index.js)后.[module]即可</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> controllers = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../controllers&quot;</span>);router.get(<span class="hljs-string">&quot;/&quot;</span>, controllers.admin);router.get(<span class="hljs-string">&#x27;/userList&#x27;</span>,controllers.adminUser)router.post(<span class="hljs-string">&#x27;/userFreeze&#x27;</span>,controllers.adminFreeze)router.post(<span class="hljs-string">&#x27;/userDelete&#x27;</span>,controllers.adminDelete)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列算法题</title>
    <link href="/2020/09/29/%E9%98%9F%E5%88%97/"/>
    <url>/2020/09/29/%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="队列结构，先进先出"><a href="#队列结构，先进先出" class="headerlink" title="队列结构，先进先出"></a>队列结构，先进先出</h2><ul><li><p>用数组实现-顺序队列</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ArrayQueue</span>(<span class="hljs-params">len</span>)</span>&#123;  <span class="hljs-built_in">this</span>.items = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len)  <span class="hljs-built_in">this</span>.n = len  <span class="hljs-built_in">this</span>.head = <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>.tail = <span class="hljs-number">0</span>&#125;ArrayQueue.prototype.enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.tail === <span class="hljs-built_in">this</span>.n)&#123;<span class="hljs-comment">// tail后没有空余空间</span>    <span class="hljs-keyword">if</span>(head === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><span class="hljs-comment">// head也在0位，表示都是满的</span>    <span class="hljs-comment">//出队后head不在0了</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = head;i&lt;<span class="hljs-built_in">this</span>.tail;i++)&#123;      <span class="hljs-built_in">this</span>.items[i-head] = <span class="hljs-built_in">this</span>.items[i]    &#125;<span class="hljs-comment">// 往前搬移</span>    tail = tail-head    head = <span class="hljs-number">0</span>  &#125;  <span class="hljs-built_in">this</span>.items[<span class="hljs-built_in">this</span>.tail] = item  <span class="hljs-built_in">this</span>.tail ++  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;ArrayQueue.prototype.dequeue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">if</span>(head === tail) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  <span class="hljs-keyword">const</span> ret = items.shift()  head ++  <span class="hljs-keyword">return</span> ret&#125;</code></pre></div></li><li><p>!循环队列</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 避免了顺序队列中的数据搬移操作</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CircularQueue</span>(<span class="hljs-params">len</span>)</span>&#123;  <span class="hljs-built_in">this</span>.items = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len)  <span class="hljs-built_in">this</span>.n = len  <span class="hljs-built_in">this</span>.head = <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>.tail = <span class="hljs-number">0</span>&#125;CircularQueue.prototype = &#123;  enqueue:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>&#123;    <span class="hljs-keyword">if</span>((<span class="hljs-built_in">this</span>.tail+<span class="hljs-number">1</span>)%n===<span class="hljs-built_in">this</span>.head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    <span class="hljs-built_in">this</span>.items[<span class="hljs-built_in">this</span>.tail] = item    <span class="hljs-built_in">this</span>.tail = (<span class="hljs-built_in">this</span>.tail+<span class="hljs-number">1</span>)%n    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  &#125;,  dequeue:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.head===<span class="hljs-built_in">this</span>.tail) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>    <span class="hljs-keyword">const</span> ret = <span class="hljs-built_in">this</span>.items[head]    <span class="hljs-built_in">this</span>.head = (<span class="hljs-built_in">this</span>.head+<span class="hljs-number">1</span>)%n    <span class="hljs-keyword">return</span> ret  &#125;&#125;</code></pre></div></li><li><p>用链表实现-链式队列</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">val</span>)</span>&#123;  <span class="hljs-built_in">this</span>.val = val  <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LinkedListQueue</span>(<span class="hljs-params">len</span>)</span>&#123;  <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span>  <span class="hljs-built_in">this</span>.tail = <span class="hljs-literal">null</span>  <span class="hljs-built_in">this</span>.curLen = <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>.maxLen = len&#125;LinkedListQueue.prototype = &#123;  enqueue: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>)</span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.head===<span class="hljs-literal">null</span>)&#123;      <span class="hljs-built_in">this</span>.head = node      <span class="hljs-built_in">this</span>.tail = node      <span class="hljs-built_in">this</span>.curLen = <span class="hljs-number">1</span>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.curLen &gt;= <span class="hljs-built_in">this</span>.len) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head    <span class="hljs-keyword">while</span>(cur.next)&#123;      cur = cur.next    &#125;    cur.next = node    <span class="hljs-built_in">this</span>.tail = node    <span class="hljs-built_in">this</span>.curLen ++    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  &#125;,  dequeue : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head    <span class="hljs-built_in">this</span>.head = cur.next    <span class="hljs-built_in">this</span>.curLen --    <span class="hljs-keyword">return</span> cur  &#125;&#125;</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>topK问题</title>
    <link href="/2020/09/24/topK/"/>
    <url>/2020/09/24/topK/</url>
    
    <content type="html"><![CDATA[<h2 id="最大-小的-K-个数，第-K-个最大-最小值"><a href="#最大-小的-K-个数，第-K-个最大-最小值" class="headerlink" title="最大/小的 K 个数，第 K 个最大/最小值"></a>最大/小的 K 个数，第 K 个最大/最小值</h2><ul><li><p>局部冒泡<br>！！输出结果无序</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr, k</span>) </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>;    <span class="hljs-comment">// 冒泡执行k次</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = arr.length - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span> + i; j--) &#123;      <span class="hljs-keyword">if</span> (arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) &#123;        [arr[j], arr[j - <span class="hljs-number">1</span>]] = [arr[j - <span class="hljs-number">1</span>], arr[j]];        flag = <span class="hljs-literal">true</span>;      &#125;    &#125;    <span class="hljs-keyword">if</span> (!flag) <span class="hljs-keyword">break</span>;  &#125;&#125;<span class="hljs-comment">// K相当于冒泡次数</span><span class="hljs-comment">//前k个小值</span>data.slice(<span class="hljs-number">0</span>, k);<span class="hljs-comment">//第k小的值</span>data[k - <span class="hljs-number">1</span>];</code></pre></div></li><li><p>堆排序</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// topk</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapObj</span>(<span class="hljs-params">items,k</span>)</span>&#123;  <span class="hljs-keyword">const</span> heap = [,...items.slice(<span class="hljs-number">0</span>,k)]  <span class="hljs-keyword">const</span> heapSize = k  buildHeap(heap,heapSize)  <span class="hljs-comment">// 求大值，建立最小堆</span>  <span class="hljs-comment">// 后续与最小堆堆顶比较</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = k ; j &lt; items.length ; j++)&#123;    <span class="hljs-keyword">if</span>(heap[<span class="hljs-number">1</span>] &lt; items[j])&#123;      <span class="hljs-comment">// 如果大于最小</span>      <span class="hljs-comment">// 作为堆顶的新值，调整堆</span>      heap[<span class="hljs-number">1</span>] = items[j]      heapify(heap,heapSize,<span class="hljs-number">1</span>)    &#125;  &#125;  <span class="hljs-keyword">return</span> heap.slice(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 前k个大值</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildHeap</span>(<span class="hljs-params">items,heapSize</span>)</span>&#123;  <span class="hljs-keyword">if</span>(heapSize === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(heapSize/<span class="hljs-number">2</span>) ; i &gt; <span class="hljs-number">0</span> ; i --)&#123;    heapify(items,heapSize,i)  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">items,heapSize,i</span>)</span>&#123;  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;    <span class="hljs-keyword">let</span> minIndex = i    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i &lt;= heapSize &amp;&amp; items[<span class="hljs-number">2</span>*i] &lt; items[i]) minIndex = <span class="hljs-number">2</span>*i    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; items[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>] &lt; items[minIndex]) minIndex = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>    <span class="hljs-keyword">if</span>(minIndex===i) <span class="hljs-keyword">break</span>    [items[i],items[minIndex]] = [items[minIndex],items[i]]    i = minIndex  &#125;&#125;</code></pre></div><ul><li>快速排序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//分割出来的索引位置，与k的索引位置比较</span><span class="hljs-comment">//第k大的值，小到大排序后就是 [nums.length - k] 索引的位置</span><span class="hljs-comment">//减少操作次数，不用完全排序一遍</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findK</span>(<span class="hljs-params">nums, k</span>) </span>&#123;  <span class="hljs-keyword">return</span> quickSelect(nums, nums.length - k);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSelect</span>(<span class="hljs-params">arr, k</span>) </span>&#123;  <span class="hljs-keyword">return</span> quick(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, k);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quick</span>(<span class="hljs-params">arr, left, right, k</span>) </span>&#123;  <span class="hljs-keyword">let</span> index;  <span class="hljs-keyword">if</span> (left &lt; right) &#123;    index = partition(arr, left, right);    <span class="hljs-keyword">if</span> (k === index) &#123;      <span class="hljs-keyword">return</span> arr[index];    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &lt; index) &#123;      <span class="hljs-keyword">return</span> quick(arr, left, index - <span class="hljs-number">1</span>, k);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> quick(arr, index + <span class="hljs-number">1</span>, right, k);    &#125;  &#125;  <span class="hljs-keyword">return</span> arr[left];&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partition</span>(<span class="hljs-params">arr, left, right</span>) </span>&#123;  <span class="hljs-keyword">let</span> base = arr[<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (right - left + <span class="hljs-number">1</span>)) + left];  <span class="hljs-keyword">let</span> L = left,    R = right;  <span class="hljs-keyword">while</span> (L &lt; R) &#123;    <span class="hljs-keyword">while</span> (arr[L] &lt; base) &#123;      L++;    &#125;    <span class="hljs-keyword">while</span> (arr[R] &gt; base) &#123;      R--;    &#125;    <span class="hljs-keyword">if</span> (L &lt; R) [arr[L], arr[R]] = [arr[R], arr[L]];    <span class="hljs-keyword">if</span> (arr[L] === arr[R] &amp;&amp; L !== R) L++;  &#125;  <span class="hljs-keyword">return</span> L;&#125;</code></pre></div><h2 id="出现最多-最少的-K-个元素"><a href="#出现最多-最少的-K-个元素" class="headerlink" title="出现最多/最少的 K 个元素"></a>出现最多/最少的 K 个元素</h2><ul><li>傻瓜 map 映射一个 arr 进行排序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMost</span>(<span class="hljs-params">arr, k</span>) </span>&#123;  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();  <span class="hljs-keyword">const</span> ret = [...new <span class="hljs-built_in">Set</span>(arr)];  arr.map(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (map.has(num)) &#123;      map.set(num, map.get(num) + <span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      map.set(num, <span class="hljs-number">1</span>);    &#125;  &#125;);  ret.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> map.get(b) - map.get(a));  <span class="hljs-keyword">return</span> ret.slice(<span class="hljs-number">0</span>, k);&#125;</code></pre></div><ul><li>map 映射堆排序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMost</span>(<span class="hljs-params">arr, k</span>) </span>&#123;  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();  <span class="hljs-keyword">const</span> heap = [,];  arr.map(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (map.has(num)) &#123;      map.set(num, map.get(num) + <span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      map.set(num, <span class="hljs-number">1</span>);    &#125;  &#125;);  <span class="hljs-keyword">if</span> (map.size &lt;= k) <span class="hljs-keyword">return</span> [...map.keys()];  <span class="hljs-comment">//k大于元素数，直接输出</span>  <span class="hljs-keyword">let</span> times = <span class="hljs-number">1</span>;  <span class="hljs-comment">//记数器</span>  <span class="hljs-comment">//小于k的部分直接建立堆，大于的部分开始与堆top比较</span>  map.forEach(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (times &lt;= k) &#123;      heap.push(key);      <span class="hljs-keyword">if</span> (times === k) &#123;        <span class="hljs-comment">//堆化</span>        buildHeap(heap, map, k);      &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.get(heap[<span class="hljs-number">1</span>]) &lt; value) &#123;      <span class="hljs-comment">// 与小顶堆顶交换</span>      heap[<span class="hljs-number">1</span>] = key;      heapify(heap, map, k, <span class="hljs-number">1</span>);    &#125;    times++;  &#125;);  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildHeap</span>(<span class="hljs-params">heap, map, heapSize</span>) </span>&#123;    <span class="hljs-keyword">if</span> (k === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(heapSize / <span class="hljs-number">2</span>); i &gt;= <span class="hljs-number">1</span>; i--) &#123;      heapify(heap, map, heapSize, i);    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">heap, map, heapSize, i</span>) </span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;      <span class="hljs-keyword">let</span> minIndex = i;      <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * i &lt;= heapSize &amp;&amp; map.get(heap[<span class="hljs-number">2</span> * i]) &lt; map.get(heap[minIndex]))        minIndex = <span class="hljs-number">2</span> * i;      <span class="hljs-keyword">if</span> (        <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span> &lt;= heapSize &amp;&amp;        map.get(heap[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>]) &lt; map.get(heap[minIndex])      )        minIndex = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;      <span class="hljs-keyword">if</span> (minIndex === i) <span class="hljs-keyword">break</span>;      swap(heap, minIndex, i);      i = minIndex;    &#125;  &#125;  heap.shift();  <span class="hljs-keyword">return</span> heap;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">data, l, r</span>) </span>&#123;  <span class="hljs-keyword">let</span> temp = data[l];  data[l] = data[r];  data[r] = temp;&#125;</code></pre></div><ul><li>桶排序<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMost</span>(<span class="hljs-params">arr,k</span>)</span>&#123;  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()  arr.map(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (map.has(num)) &#123;      map.set(num, map.get(num) + <span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      map.set(num, <span class="hljs-number">1</span>);    &#125;  &#125;);  <span class="hljs-keyword">if</span>(map.size&lt;=k) <span class="hljs-keyword">return</span> [...map.keys()]  <span class="hljs-keyword">return</span> buckerSort(map,k)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buckerSort</span>(<span class="hljs-params">map,k</span>)</span>&#123;  <span class="hljs-keyword">let</span> arr = []  <span class="hljs-keyword">let</span> res = []  map.forEach(<span class="hljs-function">(<span class="hljs-params">value,key</span>)=&gt;</span>&#123;    <span class="hljs-keyword">if</span>(!arr[value])&#123;      arr[value] = [key]    &#125;<span class="hljs-keyword">else</span>&#123;      arr[value].push(key)    &#125;  &#125;)  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = arr.length - <span class="hljs-number">1</span> ; i&gt;=<span class="hljs-number">0</span> &amp;&amp; res.length &lt; k ; i--)&#123;    <span class="hljs-keyword">if</span>(arr[i])&#123;      res.push(...arr[i])    &#125;  &#125;  <span class="hljs-keyword">return</span> res&#125;</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器缓存策略</title>
    <link href="/2020/09/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    <url>/2020/09/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><ul><li> 浏览器直接验证本地资源看是否过期，如果没过期直接使用本地缓存，并返回<code>200</code></li><li> 验证两种字段<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a><code>Expires</code></h3></li></ul><ol><li>http 1.0</li><li>时间戳格式<code>Expires: Wed, 22 Oct 2018 08:41:00 GMT</code></li><li>使用本地时间验证，与服务器时间之间的误差或者本地时间的修改都后会造成缓存失效</li></ol><h3 id="Cache-control"><a href="#Cache-control" class="headerlink" title="Cache-control"></a><code>Cache-control</code></h3><ol><li><p>http 1.1</p></li><li><p>可选参数：</p><ul><li><code>max-age</code><ul><li>单位为毫秒，表示多长时间后过期</li><li>可设置为 <strong>0</strong> 立即请求新资源</li></ul></li><li><code>public</code>,<code>private</code><ul><li><code>public</code> 表示该资源可以被所有客户端和代理服务器缓存</li><li><code>private</code> 表示该资源仅能客户端缓存[<em>默认值</em>]</li><li>当设置了 <code>s-maxage</code> 的时候表示允许代理服务器缓存，相当于 <code>public</code></li></ul></li><li><code>no-cache</code>,<code>no-store</code><ul><li><code>no-cache</code> 会缓存资源，但要协商缓存验证</li><li><code>no-store</code> 不缓存</li><li>两个字段存在时忽略<code>max-age</code>长度和<code>Expire</code>时间戳</li></ul></li></ul></li></ol><h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a><code>Pragma</code></h3><p><code>Pragma = no-cache</code>与<code>Cache-Control: no-cache</code>效果一致</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><code>pragma -&gt; cache-control -&gt; expires</code></p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><ul><li>浏览器携带缓存标识向服务器发起请求，询问服务器缓存有效性</li><li>协商缓存生效，返回<code>304</code>和<code>Not Modified</code></li><li>协商缓存失效，返回<code>200</code>和请求结果<h3 id="Last-modified-If-Modified-Since"><a href="#Last-modified-If-Modified-Since" class="headerlink" title="Last-modified + If-Modified-Since"></a><code>Last-modified + If-Modified-Since</code></h3></li></ul><ol><li><p>服务器返回资源的同时在<code>response header</code>中添加 <code>Last-Modified</code>，值是这个资源在服务器上的最后修改时间<br> <code>Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT</code></p></li><li><p>再次请求该资源时，浏览器检测到资源中存在 <code>Last-Modified</code>字段，则会将这个时间戳作为<code>If-Modified-Since</code>的值加入请求头中发送给服务器</p></li><li><p>服务器根据自身资源的修改时间和来自请求的时间戳判断资源是否更新，返回相对应的结果</p></li></ol><h4 id="优劣"><a href="#优劣" class="headerlink" title="@优劣"></a>@优劣</h4><ul><li>本地打开缓存文件，即使没有对文件进行修改，但还是会造成 <code>Last-Modified</code> 被修改</li><li><code>Last-Modified</code> 只能以秒计时，如果在不可感知的时间内修改完成文件，则不能体现被修改过</li></ul><h3 id="ETag-If-Not-Match"><a href="#ETag-If-Not-Match" class="headerlink" title="ETag + If-Not-Match"></a><code>ETag + If-Not-Match</code></h3><ol><li>服务器为资源进行hash计算生成唯一的标识符<code>Etag</code>加入返回头，资源的修改会导致标识改变</li><li>浏览器请求时将资源自带的标识作为<code>If-None-Match</code>的值加入请求头中发送给服务器</li><li>服务器根据同一资源标识是否一致返回相应结果</li></ol><h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><ol><li><p>先判断<code>Cache-Control</code>，在<code>Cache-Control</code>的<code>max-age</code>之内，直接返回<code>200 from cache</code>；</p></li><li><p>没有<code>Cache-Control</code>再判断<code>Expires</code>，在<code>Expires</code>之内，直接返回<code>200 from cache</code></p></li><li><p><code>Cache-Control=no-cache</code>或者不符合<code>Expires</code>，浏览器向服务器发送请求</p></li><li><p> 服务器判断<code>If-Modified-Since</code>和<code>If-None-Match</code>，两者同时出现时会忽略<code>If-Modified-Since</code>，有效则返回<code>304</code>，失效则返回新资源。</p></li></ol><h2 id="用户行为的影响"><a href="#用户行为的影响" class="headerlink" title="用户行为的影响"></a>用户行为的影响</h2><ol><li><em>地址栏</em>访问，链接跳转是正常用户行为，将会触发浏览器缓存机制；</li><li><em>F5</em>刷新，浏览器会设置max-age=0，强缓存失效，进行协商缓存判断；</li><li><em>ctrl+F5</em>刷新，跳过强缓存和协商缓存，直接从服务器拉取资源。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3proxy</title>
    <link href="/2020/09/07/vue3/"/>
    <url>/2020/09/07/vue3/</url>
    
    <content type="html"><![CDATA[<h1 id="VUE冲冲冲"><a href="#VUE冲冲冲" class="headerlink" title="VUE冲冲冲"></a>VUE冲冲冲</h1><h2 id="代替defineProperty的Proxy"><a href="#代替defineProperty的Proxy" class="headerlink" title="代替defineProperty的Proxy"></a>代替defineProperty的Proxy</h2><h3 id="vue2-X存在的缺陷"><a href="#vue2-X存在的缺陷" class="headerlink" title="vue2.X存在的缺陷"></a>vue2.X存在的缺陷</h3><ul><li><p>无法检测对象中 <code>property</code> 的添加或移除</p></li><li><p>通过下标操作数组，例如：<code>vm.items[indexOfItem] = newValue （性能考虑放弃）</code></p></li><li><p>修改数组的长度时，例如：<code>vm.items.length = newLength</code></p></li><li><p>变通</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// Object新增元素</span>Vue.set(object, propertyName, value)<span class="hljs-comment">// or</span><span class="hljs-built_in">this</span>.$set(<span class="hljs-built_in">this</span>.someObject,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">2</span>)<span class="hljs-comment">// 下标修改数组</span>Vue.set(vm.array1, indexOfItem, newValue)<span class="hljs-comment">// or</span><span class="hljs-built_in">this</span>.$set(<span class="hljs-built_in">this</span>.array1, indexOfItem, newValue)<span class="hljs-comment">// or</span><span class="hljs-built_in">this</span>.array1.splice(indexOfItem, <span class="hljs-number">1</span>, newValue)<span class="hljs-comment">// 修改数组长度</span><span class="hljs-built_in">this</span>.array1.splice(newLength)</code></pre></div></li><li><p>包裹数组部分方法以支持响应式</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">pop()push()shift()unshift()splice()sort()reverse()</code></pre></div><h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a><code>defineProperty</code></h3></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.defineProperty(obj<span class="hljs-comment">/* 对象*/</span>, prop<span class="hljs-comment">/* 属性*/</span>, descriptor<span class="hljs-comment">/*描述符*/</span>)&#123;  <span class="hljs-comment">//对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。</span>  <span class="hljs-comment">//数据描述符是一个具有值的属性，该值可以是可写的，也可以是不可写的。</span>  <span class="hljs-comment">//存取描述符是由 getter 函数和 setter 函数所描述的属性。</span>  <span class="hljs-comment">//一个描述符只能是这两者其中之一；不能同时是两者。</span>  configurable: <span class="hljs-literal">true</span>,  <span class="hljs-comment">//configurable 特性表示对象的属性是否可以被删除，以及除 value 和 writable 特性外的其他特性是否可以被修改。</span>  enumerable: <span class="hljs-literal">true</span>,  <span class="hljs-comment">//enumerable 定义了对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举。</span>  value: <span class="hljs-literal">true</span>,  writable: <span class="hljs-literal">true</span>,  <span class="hljs-comment">//当 writable 属性设置为 false 时，该属性被称为“不可写的”。它不能被重新赋值。</span>  <span class="hljs-comment">//</span>  <span class="hljs-comment">// 或者</span>  <span class="hljs-comment">//</span>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123; ... &#125;,  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newValue</span>)</span> &#123; ... &#125;,  enumerable : <span class="hljs-literal">true</span>,  configurable : <span class="hljs-literal">true</span>&#125;</code></pre></div><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol><li>兼容<code>IE9</code></li><li>劫持了对象上的<code>属性</code></li><li>数据结构越复杂初始性能会越差,需要递归遍历绑定<code>defineProperty</code></li><li>为保持响应式还需要为新增数据再次绑定<code>defineProperty</code></li><li>原数据的修改即可触发拦截器</li></ol><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a><code>proxy</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler)handler.getPrototypeOf()<span class="hljs-comment">//Object.getPrototypeOf 方法的捕捉器。</span>handler.setPrototypeOf()<span class="hljs-comment">//Object.setPrototypeOf 方法的捕捉器。</span>handler.isExtensible()<span class="hljs-comment">//Object.isExtensible 方法的捕捉器。</span>handler.preventExtensions()<span class="hljs-comment">//Object.preventExtensions 方法的捕捉器。</span>handler.getOwnPropertyDescriptor()<span class="hljs-comment">//Object.getOwnPropertyDescriptor 方法的捕捉器。</span>handler.defineProperty()<span class="hljs-comment">//Object.defineProperty 方法的捕捉器。</span>handler.has()<span class="hljs-comment">//in 操作符的捕捉器。</span>handler.get()<span class="hljs-comment">//属性读取操作的捕捉器。</span>handler.set()<span class="hljs-comment">//属性设置操作的捕捉器。</span>handler.deleteProperty()<span class="hljs-comment">//delete 操作符的捕捉器。</span>handler.ownKeys()<span class="hljs-comment">//Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。</span>handler.apply()<span class="hljs-comment">//函数调用操作的捕捉器。</span>handler.construct()<span class="hljs-comment">//new 操作符的捕捉器。</span></code></pre></div><ol><li>不兼容<code>IE</code></li><li>劫持<code>整个对象</code>，无需对对象本体的变化作出修改</li><li>拦截器响应的是<code>proxy</code>生成的代理对象，原数据的修改将不会触发拦截器</li><li>拦截器种类繁多</li></ol><h2 id="简单实现reactive"><a href="#简单实现reactive" class="headerlink" title="简单实现reactive"></a>简单实现reactive</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// monkeyVersionReactivity.js猴版响应式框架</span><span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();<span class="hljs-keyword">const</span> effectStack = [];<span class="hljs-keyword">const</span> isObject = <span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> obj !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;object&quot;</span>;<span class="hljs-keyword">const</span> baseHandler = &#123;  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, key</span>)</span> &#123;    <span class="hljs-keyword">const</span> ret = <span class="hljs-built_in">Reflect</span>.get(target, key);    track(target, key);    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ret === <span class="hljs-string">&quot;object&quot;</span>) &#123;      <span class="hljs-keyword">return</span> reactive(ret);    &#125;    <span class="hljs-keyword">return</span> ret;  &#125;,  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">target, key, val</span>)</span> &#123;    <span class="hljs-built_in">Reflect</span>.set(target, key, val);    trigger(target, key, val);  &#125;,&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">track</span>(<span class="hljs-params">target, key</span>) </span>&#123;  <span class="hljs-keyword">let</span> activeEffect = effectStack[effectStack.length - <span class="hljs-number">1</span>];  <span class="hljs-keyword">if</span> (!activeEffect) <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">let</span> depsMap = targetMap.get(target);  <span class="hljs-keyword">if</span> (!depsMap) &#123;    targetMap.set(target, (depsMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()));  &#125;  <span class="hljs-keyword">let</span> dep = depsMap.get(key);  <span class="hljs-keyword">if</span> (!dep) &#123;    depsMap.set(key, (dep = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()));  &#125;  <span class="hljs-keyword">if</span> (!dep.has(activeEffect)) &#123;    dep.add(activeEffect);    <span class="hljs-comment">// TODO</span>    activeEffect.deps.push(dep);  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trigger</span>(<span class="hljs-params">target, key, val</span>) </span>&#123;  <span class="hljs-keyword">const</span> depsMap = targetMap.get(target);  <span class="hljs-keyword">if</span> (!depsMap) &#123;    <span class="hljs-comment">// never been tracked</span>    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-keyword">const</span> effects = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();  <span class="hljs-keyword">if</span> (key) &#123;    <span class="hljs-keyword">const</span> dep = depsMap.get(key);    dep.forEach(<span class="hljs-function">(<span class="hljs-params">effect</span>) =&gt;</span> &#123;      effects.add(effect);    &#125;);  &#125;  effects.forEach(<span class="hljs-function">(<span class="hljs-params">ef</span>) =&gt;</span> ef());&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createReactiveEffect</span>(<span class="hljs-params">fn,options</span>)</span>&#123;  <span class="hljs-keyword">const</span> effect = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveEffect</span>(<span class="hljs-params"></span>)</span>&#123;      <span class="hljs-keyword">try</span> &#123;        effectStack.push(effect)        <span class="hljs-keyword">return</span> fn()      &#125; <span class="hljs-keyword">finally</span> &#123;        effectStack.pop()      &#125;  &#125;  effect.deps = []  effect.options = options  <span class="hljs-keyword">return</span> effect&#125;<span class="hljs-comment">// ---------</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactive</span>(<span class="hljs-params">target</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, baseHandler);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">effect</span>(<span class="hljs-params">fn, options=&#123;&#125;</span>) </span>&#123;  <span class="hljs-keyword">const</span> effect = createReactiveEffect(fn, options);  <span class="hljs-keyword">if</span> (!options.lazy) &#123;    effect();  &#125;  <span class="hljs-keyword">return</span> effect;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computed</span>(<span class="hljs-params">fn</span>)</span>&#123;  <span class="hljs-keyword">const</span> runner = effect(fn,&#123;<span class="hljs-attr">computed</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">lazy</span>:<span class="hljs-literal">true</span>&#125;)  <span class="hljs-keyword">return</span> &#123;    effect:runner,    <span class="hljs-keyword">get</span> <span class="hljs-title">val</span>()&#123;      <span class="hljs-keyword">return</span> runner()    &#125;  &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>require.context()</title>
    <link href="/2020/09/03/require.context%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/09/03/require.context%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<ul><li><p>自动化注册组件</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// global.js</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> upperFirst <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash/upperFirst&#x27;</span><span class="hljs-keyword">import</span> camelCase <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash/camelCase&#x27;</span><span class="hljs-keyword">const</span> requireComponent = <span class="hljs-built_in">require</span>.context(  <span class="hljs-comment">// 其组件目录的相对路径</span>  <span class="hljs-comment">// 全局注册的目录</span>  .,  <span class="hljs-comment">// 是否查询其子目录</span>  <span class="hljs-literal">false</span>,  <span class="hljs-comment">// 匹配基础组件文件名的正则表达式</span>  <span class="hljs-comment">// /Base[A-Z]\w+\.(vue|js)$/</span>  /\.vue$/)requireComponent.keys().forEach(<span class="hljs-function"><span class="hljs-params">fileName</span> =&gt;</span> &#123;  <span class="hljs-comment">// 获取组件配置</span>  <span class="hljs-keyword">const</span> componentConfig = requireComponent(fileName)  <span class="hljs-comment">// 获取组件的 PascalCase 命名</span>  <span class="hljs-keyword">const</span> componentName = upperFirst(    camelCase(      <span class="hljs-comment">// 获取和目录深度无关的文件名</span>      fileName        <span class="hljs-comment">// .split(&#x27;/&#x27;)</span>        <span class="hljs-comment">// .pop()</span>        .replace(<span class="hljs-regexp">/^\.\//</span>,<span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-comment">// ‘./ComA.vue’ =&gt; &#x27;ComA.vue&#x27;</span>        .replace(<span class="hljs-regexp">/\.\w+$/</span>, <span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-comment">// =&gt; &#x27;ComA&#x27;</span>    )  )  <span class="hljs-comment">// 全局注册组件</span>  Vue.component(    componentName,    <span class="hljs-comment">// 如果这个组件选项是通过 `export default` 导出的，</span>    <span class="hljs-comment">// 那么就会优先使用 `.default`，</span>    <span class="hljs-comment">// 否则回退到使用模块的根。</span>    componentConfig.default || componentConfig  )&#125;)</code></pre></div></li><li><p>自动化注册路由</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// router.js</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>Vue.use(Router)<span class="hljs-keyword">const</span> routerList = []<span class="hljs-keyword">const</span> importAllRouter = <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;  r.keys().forEach(<span class="hljs-function"><span class="hljs-params">key</span>=&gt;</span>&#123;    routerList.push(r[key].default  <span class="hljs-comment">/*export default*/</span>)  &#125;)&#125;importAllRouter(<span class="hljs-built_in">require</span>.context(.<span class="hljs-comment">/* 查询目录*/</span>,<span class="hljs-literal">true</span><span class="hljs-comment">/*是否包含子目录*/</span>,<span class="hljs-regexp">/\.router\.js/</span><span class="hljs-regexp">/*匹配正则*/</span>))<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Router(&#123;  ...routerList&#125;)</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆及相关算法</title>
    <link href="/2020/08/31/%E5%A0%86/"/>
    <url>/2020/08/31/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul><li><p>堆就是完全二叉树</p><div class="hljs code-wrapper"><pre><code>完全二叉树：除了深度最深的一层外所有层节点数都满员深度：从根节点到该节点经历的节点个数</code></pre></div></li><li><p>每一个节点都比左右子节点大–&gt;最大堆，最大值在根节点</p></li><li><p>每一个节点都比左右子节点小–&gt;最小堆，最小值在根节点</p></li><li><p>完全二叉树可以使用数组来存储</p></li></ul><h3 id="建立堆"><a href="#建立堆" class="headerlink" title="建立堆"></a>建立堆</h3><ul><li>将节点与父节点比较</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//小顶堆</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildHeap</span>(<span class="hljs-params">items,heapSize</span>)</span>&#123;  <span class="hljs-keyword">while</span>(heapSize&lt;items.length - <span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">// items 第一个是&lt;empty item&gt;</span>    heapSize++    heapify(items,heapSize)  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">items,i</span>)</span>&#123;  <span class="hljs-keyword">while</span>(<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>) &gt; <span class="hljs-number">0</span> &amp;&amp; items[i] &lt; items[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)])&#123;    [items[i],items[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)]] =  [items[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)],items[i]]    <span class="hljs-comment">// 交换位置</span>    i = <span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)  &#125; &#125;</code></pre></div><ul><li>将节点与子节点比较</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//大顶堆</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildHeap</span>(<span class="hljs-params">items</span>)</span>&#123;  <span class="hljs-keyword">const</span> heapSize = items.length - <span class="hljs-number">1</span>  <span class="hljs-comment">// &lt;-- items.length - 1 !</span>  <span class="hljs-comment">// 最后叶子节点的索引值</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(heapSize/<span class="hljs-number">2</span>) ; i &gt;= <span class="hljs-number">1</span> ; i--)&#123; <span class="hljs-comment">// &lt;-i&gt;=1 !</span>    <span class="hljs-comment">// i 为最后一个非 叶子 节点的索引，i还有子节点</span>    heapify(items,heapSize,i)  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">items, heapSize, i</span>) </span>&#123;  <span class="hljs-comment">// 自上而下式堆化</span>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;      <span class="hljs-keyword">var</span> maxIndex = i;      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i &lt;= heapSize &amp;&amp; items[maxIndex] &lt; items[i*<span class="hljs-number">2</span>] ) &#123;        <span class="hljs-comment">// 这里的等号意味着万一这个节点是最后的节点呢</span>          maxIndex = i*<span class="hljs-number">2</span>;      &#125;      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; items[maxIndex] &lt; items[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] ) &#123;          maxIndex = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;      &#125;      <span class="hljs-keyword">if</span> (maxIndex === i) <span class="hljs-keyword">break</span>;      [items[i],items[maxIndex]] = [items[maxIndex],items[i]]      i = maxIndex;   &#125;&#125;</code></pre></div><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ol><li>建立大顶堆/小顶堆</li><li>则索引1位置为当前堆的 最大值/最小值</li><li>循环将[1]与[末尾]交换位置，并且缩小堆的大小（相当于将上一次的最值移出堆）</li><li>一直堆化</li><li>大顶堆得到升序 / 小顶堆得到降序排列</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapSort</span>(<span class="hljs-params">arr</span>)</span>&#123;  <span class="hljs-comment">// 输入需要为[,]</span>  <span class="hljs-comment">// const heap = [,]</span>  <span class="hljs-comment">// let i = 0</span>  <span class="hljs-comment">// while(i&lt;arr.length)&#123;</span>  <span class="hljs-comment">//   heap.push(arr[i++])</span>  <span class="hljs-comment">// &#125;</span>  <span class="hljs-keyword">const</span> heapSize  =  arr.length - <span class="hljs-number">1</span>  buildHeap(arr,heapSize)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = heapSize ; i&gt;<span class="hljs-number">1</span> ;i--)&#123;    [arr[i],arr[<span class="hljs-number">1</span>]]=[arr[<span class="hljs-number">1</span>],arr[i]]    heapSize --    heapify(arr,heapSize,<span class="hljs-number">1</span>)  &#125;  <span class="hljs-keyword">return</span> arr&#125;</code></pre></div><h3 id="topK问题"><a href="#topK问题" class="headerlink" title="topK问题"></a>topK问题</h3><p>求出前k个最大/最小值，或者出现次数最多/最少的k个值</p><ul><li>求大值，建立最小堆</li><li>求小值，建立最大堆<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 比如求前k个最大值</span><span class="hljs-comment">// 先用前k个数据建立小顶堆</span><span class="hljs-comment">// 为什么求前k大建立小顶堆？？？</span><span class="hljs-comment">// 如果建立大顶堆，交换堆顶后，堆顶依然是最大的，依次比较之后的数据只会改变堆顶而已，收集不了别的值</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">topK</span>(<span class="hljs-params">data,k</span>)</span>&#123;  <span class="hljs-keyword">let</span> heap = [,...data]  <span class="hljs-keyword">const</span> heapSize = k  buildHeap(heap,heapSize)  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = k ; j &lt;data.length ;j++)&#123;    <span class="hljs-comment">// 将余下的数据依次与堆顶比较</span>    <span class="hljs-comment">// 比小顶堆的堆顶大则交换</span>    <span class="hljs-keyword">if</span>(heap[<span class="hljs-number">1</span>] &lt; data[j])&#123;      heap[<span class="hljs-number">1</span>] = data[j]      heapify(heap,k,<span class="hljs-number">1</span>)    &#125;  &#125;  heap.shift()  <span class="hljs-keyword">return</span> heap&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildHeap</span>(<span class="hljs-params">items ,heapSize</span>)</span>&#123;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(heapSize/<span class="hljs-number">2</span>) ; i &gt;= <span class="hljs-number">1</span> ; i--)&#123;    heapify(items,heapSize,i)  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">items,heapSize,i</span>)</span>&#123;  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;    <span class="hljs-keyword">let</span> minIndex = i    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i &lt;= heapSize &amp;&amp; items[minIndex] &gt; items[i*<span class="hljs-number">2</span>] ) &#123;        <span class="hljs-comment">// 这里的等号意味着万一这个节点是最后的节点呢</span>        minIndex = i*<span class="hljs-number">2</span>;      &#125;      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; items[minIndex] &gt; items[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] ) &#123;        minIndex = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;      &#125;      <span class="hljs-keyword">if</span> (minIndex === i) <span class="hljs-keyword">break</span>;      [items[i],items[minIndex]] = [items[minIndex],items[i]]      i = minIndex;   &#125;&#125;</code></pre></div></li></ul><h3 id="中位数问题"><a href="#中位数问题" class="headerlink" title="中位数问题"></a>中位数问题</h3><p><code>n</code>个数据中的中位数</p><div class="hljs code-wrapper"><pre><code>  [1,2,3] =&gt; 2  [1,2,3,4] =&gt; 2,3  当 n % 2 !== 0 时，中位数为：arr[(n-1)/2]  当 n % 2 === 0 时，中位数为：arr[n/2], arr[n/2 + 1]</code></pre></div><ul><li><p>将前<code>n/2//偶数</code>||<code>（Math.floor(n/2)）+ 1//奇数</code>堆化为大顶堆，后<code>Math.floor(n/2)</code>堆化为小顶堆。</p></li><li><p>结果分别为两个堆顶<code>偶数</code>/前面的堆顶<code>奇数</code></p></li><li><p>动态数组，则把插入的数据与堆顶比较</p><ul><li>【升序】大于大顶堆的顶则加入小顶堆</li><li>【降序】小于小顶堆则加入大顶堆</li><li> 加入后再次堆化，如果堆大小不满足分割中位数要求则继续调整</li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Median</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.maxHeap = <span class="hljs-keyword">new</span> MaxHeap()  <span class="hljs-built_in">this</span>.minHeap = <span class="hljs-keyword">new</span> MinHeap()&#125;Median.prototype.addNum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>)</span>&#123;  <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-built_in">this</span>.maxHeap.getTop() || !<span class="hljs-built_in">this</span>.maxHeap.getSize())&#123;    <span class="hljs-built_in">this</span>.maxHeap.insert(num)  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-built_in">this</span>.minHeap.insert(num)  &#125;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.maxHeap.getSize() - <span class="hljs-built_in">this</span>.minHeap.getSize() &gt; <span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">//奇数分布</span>    <span class="hljs-comment">//大顶堆size比小顶堆大1</span>    <span class="hljs-built_in">this</span>.minHeap.insert(<span class="hljs-built_in">this</span>.maxHeap.rmTop())    <span class="hljs-comment">//不符合则大顶堆顶插入小顶堆</span>  &#125;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.minHeap.getSize() &gt; <span class="hljs-built_in">this</span>.maxHeap.getSize())&#123;    <span class="hljs-built_in">this</span>.maxHeap.insert(<span class="hljs-built_in">this</span>.minHeap.rmTop())    <span class="hljs-comment">// </span>  &#125;&#125;Median.prototype.getMedianNum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-comment">// return console.log(this.maxHeap.getSize());</span>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.maxHeap.getSize() &amp;&amp; <span class="hljs-built_in">this</span>.maxHeap.getSize() === <span class="hljs-built_in">this</span>.minHeap.getSize())&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.maxHeap.getTop() + <span class="hljs-built_in">this</span>.minHeap.getTop())/<span class="hljs-number">2</span>  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.maxHeap.getTop()&#125;<span class="hljs-comment">// 大顶堆</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MaxHeap</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">const</span> heap = [,]  <span class="hljs-built_in">this</span>.getSize = <span class="hljs-function">() =&gt;</span> heap.length - <span class="hljs-number">1</span>  <span class="hljs-built_in">this</span>.getTop = <span class="hljs-function">() =&gt;</span> heap.length &gt; <span class="hljs-number">1</span> ? heap[<span class="hljs-number">1</span>] : <span class="hljs-literal">null</span>  <span class="hljs-built_in">this</span>.insert = <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;    <span class="hljs-comment">//插入式建堆</span>    heap.push(num)    <span class="hljs-keyword">let</span> i = heap.length - <span class="hljs-number">1</span>    <span class="hljs-comment">// push 进去的索引</span>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)&gt;<span class="hljs-number">0</span> &amp;&amp; heap[i] &gt; heap[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)])&#123;      <span class="hljs-comment">// 大顶堆，与父节点比较，大于则交换</span>      [heap[i],heap[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)]] = [heap[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)],heap[i]]      i = <span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)    &#125;  &#125;  <span class="hljs-built_in">this</span>.rmTop = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(!heap.length &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>    <span class="hljs-keyword">if</span>(heap.length === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> heap.pop()    <span class="hljs-keyword">const</span> num = heap[<span class="hljs-number">1</span>]    heap[<span class="hljs-number">1</span>] = heap.pop()<span class="hljs-comment">// 拿走了top值，并用末尾节点填充</span>    heapify(<span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> num  &#125;  <span class="hljs-keyword">const</span> heapify = <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> &#123;    <span class="hljs-comment">// 堆化</span>    <span class="hljs-keyword">const</span> heapSize = heap.length - <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;      <span class="hljs-keyword">let</span> maxIndex = i      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; heap[<span class="hljs-number">2</span>*i] &gt; heap[i]) maxIndex = <span class="hljs-number">2</span>*i      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; heap[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>] &gt; heap[maxIndex]) maxIndex = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> <span class="hljs-comment">// !!!!!!</span>      <span class="hljs-keyword">if</span>(maxIndex === i) <span class="hljs-keyword">break</span>      [heap[i],heap[maxIndex]] = [heap[maxIndex],heap[i]]      <span class="hljs-comment">// 重新赋值i开始下级循环</span>      i = maxIndex    &#125;  &#125;&#125;<span class="hljs-comment">// 小顶堆</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MinHeap</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">const</span> heap = [,]  <span class="hljs-built_in">this</span>.getSize = <span class="hljs-function">() =&gt;</span> heap.length - <span class="hljs-number">1</span>  <span class="hljs-built_in">this</span>.getTop = <span class="hljs-function">() =&gt;</span> heap.length &gt; <span class="hljs-number">1</span> ? heap[<span class="hljs-number">1</span>] : <span class="hljs-literal">null</span>  <span class="hljs-built_in">this</span>.insert = <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;    heap.push(num)    <span class="hljs-keyword">let</span> i = heap.length - <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)&gt;<span class="hljs-number">0</span> &amp;&amp; heap[i] &lt; heap[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)])&#123;      <span class="hljs-comment">// 小顶堆，与父节点比较，小于则交换</span>      [heap[i],heap[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)]] = [heap[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)],heap[i]]      i = <span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)    &#125;  &#125;  <span class="hljs-built_in">this</span>.rmTop = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(!heap.length&gt;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>    <span class="hljs-keyword">if</span>(heap.length === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> heap.pop()    <span class="hljs-keyword">const</span> num = heap[<span class="hljs-number">1</span>]    heap[<span class="hljs-number">1</span>] = heap.pop()    heapify(<span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> num  &#125;  <span class="hljs-keyword">const</span> heapify = <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> heapSize = heap.length - <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;      <span class="hljs-keyword">let</span> minIndex = i      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; heap[<span class="hljs-number">2</span>*i] &lt; heap[i]) minIndex = <span class="hljs-number">2</span>*i      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; heap[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>] &lt; heap[minIndex]) minIndex = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>      <span class="hljs-keyword">if</span>(minIndex === i) <span class="hljs-keyword">break</span>      [heap[i],heap[minIndex]] = [heap[minIndex],heap[i]]      <span class="hljs-comment">// 重新赋值i开始下级循环</span>      i = minIndex    &#125;  &#125;&#125;<span class="hljs-comment">// 二分查找法</span><span class="hljs-keyword">const</span> MedianFinder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.data = []&#125;MedianFinder.prototype.addMun = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>)</span>&#123;  <span class="hljs-keyword">const</span> data = <span class="hljs-built_in">this</span>.data  <span class="hljs-keyword">if</span>(data.length&lt;<span class="hljs-number">1</span>)&#123;    data.push(num)    <span class="hljs-keyword">return</span>   &#125;  <span class="hljs-keyword">let</span> L = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> R = data.length - <span class="hljs-number">1</span>  <span class="hljs-keyword">while</span>(L&lt;=R)&#123;    <span class="hljs-keyword">let</span> M = <span class="hljs-built_in">Math</span>.floor((L+R)/<span class="hljs-number">2</span>)    <span class="hljs-keyword">if</span>(data[M]===num)&#123;      data.splice(M,<span class="hljs-number">0</span>,num)      <span class="hljs-keyword">return</span>     &#125;    <span class="hljs-keyword">if</span>(data[M]&lt;num)&#123;      L ++    &#125;<span class="hljs-keyword">else</span>&#123;      R --    &#125;  &#125;  data.splice(R+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,num)&#125;MedianFinder.prototype.findMedian = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> len = <span class="hljs-built_in">this</span>.data.length  <span class="hljs-keyword">if</span>(!len) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor((len-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>)  <span class="hljs-keyword">if</span>(len%<span class="hljs-number">2</span>===<span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.data[mid]+ <span class="hljs-built_in">this</span>.data[mid+<span class="hljs-number">1</span>])/<span class="hljs-number">2</span>  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.data[mid]  &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2020/08/28/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/08/28/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="树型结构"><a href="#树型结构" class="headerlink" title="树型结构"></a>树型结构</h2><ul><li><p>节点不能闭环</p></li><li><p>只有一个根节点</p></li><li><p>除了根节点，每个节点有且只有一个父节点</p></li><li><p>深度：节点到根节点的最长路径经过节点个数</p></li><li><p>高度：节点到叶节点最长路径经过节点个数</p></li><li><p>树的高度：根节点到叶节点的最长路径经过节点个数</p></li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>最多只有两个子节点的树结构</p><ul><li>平衡二叉树</li><li>满二叉树</li><li>完全二叉树</li><li>二叉搜索树【BST】：右子大于父大于左子<ul><li>二叉搜索树的中序遍历得到升序排列</li></ul></li></ul><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BinaryTree</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> Node = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;    <span class="hljs-built_in">this</span>.val = val;    <span class="hljs-built_in">this</span>.left = <span class="hljs-literal">null</span>;    <span class="hljs-built_in">this</span>.right = <span class="hljs-literal">null</span>;  &#125;;  <span class="hljs-keyword">let</span> root = <span class="hljs-literal">null</span>;&#125;</code></pre></div><ul><li>前序遍历<blockquote><p>root -&gt; left -&gt; right</p></blockquote></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preOrderTraverse</span>(<span class="hljs-params">node</span>) </span>&#123;  <span class="hljs-keyword">let</span> res = [];  <span class="hljs-keyword">let</span> stack = [];  <span class="hljs-keyword">if</span> (node) stack.push(node);  <span class="hljs-keyword">while</span> (stack.length &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">let</span> curNode = stack.pop();    res.push(curNode.val);    <span class="hljs-keyword">if</span> (curNode.right !== <span class="hljs-literal">null</span>) &#123;      stack.push(curNode.right);    &#125;    <span class="hljs-keyword">if</span> (curNode.left !== <span class="hljs-literal">null</span>) &#123;      stack.push(curNode.left);    &#125;  &#125;  <span class="hljs-keyword">return</span> res;&#125;</code></pre></div><ul><li>中序遍历<blockquote><p>left -&gt; root -&gt; right</p></blockquote></li><li>后序遍历<blockquote><p>left -&gt; right -&gt; root</p></blockquote></li></ul><h2 id="二叉树算法题"><a href="#二叉树算法题" class="headerlink" title="二叉树算法题"></a>二叉树算法题</h2><ul><li>计算路径</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 输入二叉树和一个值，求出按照二叉树路径求和等于该值的路径</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pathSum</span>(<span class="hljs-params">root,sum</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> []  <span class="hljs-keyword">if</span>(root.value===sum) <span class="hljs-keyword">return</span> [root.value]  <span class="hljs-keyword">const</span> paths = []  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">searchPath</span>(<span class="hljs-params">node,target,prePath</span>)</span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">    / <span class="hljs-doctag">@parma </span>target 与最终sum的差值</span><span class="hljs-comment">    / <span class="hljs-doctag">@parma </span>prePath 到此的路径</span><span class="hljs-comment">    */</span>    <span class="hljs-keyword">const</span>  = target-node.val    <span class="hljs-keyword">const</span> curPath = [...prePath,node.val]    <span class="hljs-keyword">if</span>(!node.left &amp;&amp; !node.right &amp;&amp; ===<span class="hljs-number">0</span>)&#123;      paths.push(curPath)    &#125;    <span class="hljs-keyword">if</span>(node.left)&#123;      searchPath(node.left,,curPath)    &#125;    <span class="hljs-keyword">if</span>(node.right)&#123;      searchPath(node.right,,curPath)    &#125;  &#125;&#125;</code></pre></div><ul><li>二叉树镜像</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 递归</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mirrorTree</span>(<span class="hljs-params">root</span>)</span>&#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mirror</span>(<span class="hljs-params">node</span>)</span>&#123;    <span class="hljs-keyword">if</span>(!node) <span class="hljs-keyword">return</span>    [node.left,node.right] = [node.right,node.left]    mirror(node.left)    mirror(node.right)  &#125;  mirror(root）  <span class="hljs-keyword">return</span> root&#125;<span class="hljs-comment">// stack</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mirrorTree</span>(<span class="hljs-params">root</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> root  <span class="hljs-keyword">const</span> swap = <span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> [node.left,node.right] = [node.right,node.left]  <span class="hljs-keyword">const</span> stack = [root]  <span class="hljs-keyword">while</span>(stack.length&gt;<span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">const</span> node = stack.pop()    swap(node)    node.left &amp;&amp; stack.push(node.left)    node.right &amp;&amp; stack.push(node.right)  &#125;  <span class="hljs-keyword">return</span> root&#125;</code></pre></div><ul><li>计算二叉树的最大深度</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 后序遍历</span><span class="hljs-comment">// DFS</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxDepth</span>(<span class="hljs-params">root</span>)</span>&#123;  <span class="hljs-keyword">return</span> root?<span class="hljs-built_in">Math</span>.max(maxDepth(root.left),maxDepth(root.right))+<span class="hljs-number">1</span>:<span class="hljs-number">0</span>  <span class="hljs-comment">// 递归深度加1</span>  <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>  <span class="hljs-keyword">const</span> left = maxDepth(root.left)  <span class="hljs-keyword">const</span> right = maxDepth(root.right)  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(left,right)+<span class="hljs-number">1</span>  )&#125;<span class="hljs-comment">// BFS</span><span class="hljs-comment">//递归实现</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxDepth</span>(<span class="hljs-params">root</span>)</span>&#123;  <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>  <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> max  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">search</span>(<span class="hljs-params">node,dep</span>)</span>&#123;    <span class="hljs-keyword">if</span>(!node) <span class="hljs-keyword">return</span>    max = <span class="hljs-built_in">Math</span>.max(max,++dep)    search(node.left)    search(node.right)  &#125;  search(root,<span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> max&#125;<span class="hljs-comment">// 栈实现</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxDepth</span>(<span class="hljs-params">root</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>  <span class="hljs-keyword">const</span> stack = [[root,<span class="hljs-number">0</span>]]  <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>  <span class="hljs-keyword">while</span>(stack.length&gt;<span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">const</span> [node,dep] = stack.pop()    max = <span class="hljs-built_in">Math</span>.max(max,dep+<span class="hljs-number">1</span>)    node.left &amp;&amp; stack.push(node.left,dep+<span class="hljs-number">1</span>)    node.right &amp;&amp; stack.push(node.right,dep+<span class="hljs-number">1</span>)  &#125;  <span class="hljs-keyword">return</span> max&#125;</code></pre></div><ul><li>二叉搜素树中第 k 大的值<blockquote><p>二叉搜索树 + 逆向中序遍历 =&gt; 降序排列 val</p></blockquote></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">kthLargest</span>(<span class="hljs-params">root, k</span>) </span>&#123;  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">let</span> kth;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DFS</span>(<span class="hljs-params">node</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;    DFS(node.right);    <span class="hljs-keyword">if</span> (--k === <span class="hljs-number">0</span>) &#123;      kth = node.val;      <span class="hljs-keyword">return</span>;    &#125;    DFS(node.right);  &#125;  <span class="hljs-keyword">return</span> kth;&#125;</code></pre></div><ul><li>二叉树的最近公共祖先</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lowestCommonAncestor</span>(<span class="hljs-params">root, p, q</span>) </span>&#123;  <span class="hljs-keyword">if</span> (!root || root.val === p || root.val === q) <span class="hljs-keyword">return</span> root;  <span class="hljs-keyword">const</span> l = lowerCommonAncestor(root.left, p, q);  <span class="hljs-keyword">const</span> r = lowerCommonAncestor(root.right, p, q);  <span class="hljs-keyword">if</span>(!l) <span class="hljs-keyword">return</span> r  <span class="hljs-keyword">if</span>(!r) <span class="hljs-keyword">return</span> l  <span class="hljs-keyword">return</span> root&#125;</code></pre></div><ul><li>二叉搜索树的最近公共祖先</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 递归</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lowestCommonAncestor</span>(<span class="hljs-params">root, p, q</span>) </span>&#123;  <span class="hljs-keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;    <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right, p, q);  &#125;  <span class="hljs-keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;    <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left, p, q);  &#125;  <span class="hljs-keyword">return</span> root;&#125;<span class="hljs-comment">// 迭代</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lowestCommonAncestor</span>(<span class="hljs-params">root, p, q</span>) </span>&#123;  <span class="hljs-keyword">while</span> (root) &#123;    <span class="hljs-keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;      root = root.right    &#125;    <span class="hljs-keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;      root = root.left    &#125;  &#125;  <span class="hljs-keyword">return</span> root;&#125;</code></pre></div><ul><li>二叉搜索树节点间最小差<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 中序排列后，最小差就是该数组中相邻元素最小差</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minDiffInBST</span>(<span class="hljs-params">root</span>)</span>&#123;  <span class="hljs-comment">// 使用辅助栈</span>  <span class="hljs-keyword">const</span> stack = []  <span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>  <span class="hljs-keyword">let</span> min = <span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER  <span class="hljs-keyword">while</span>(root || stack.length)&#123;    <span class="hljs-keyword">while</span>(root)&#123;      stack.push(root)      root = root.left    &#125;    root = stack.pop()    pre!==<span class="hljs-literal">null</span> &amp;&amp; min = <span class="hljs-built_in">Math</span>.min(min,root.val-pre)    pre = root.val    root = root.right  &#125;  <span class="hljs-keyword">return</span> min&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minDiffInBST</span>(<span class="hljs-params">root</span>)</span>&#123;  <span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>  <span class="hljs-keyword">let</span> min = MAX_SAFE_INTEGER  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DFS</span>(<span class="hljs-params">node</span>)</span>&#123;    <span class="hljs-keyword">if</span>(!node) <span class="hljs-keyword">return</span>    DFS(node.left)    <span class="hljs-keyword">if</span>(pre===<span class="hljs-literal">null</span>)&#123;      pre = node.val    &#125;<span class="hljs-keyword">else</span>&#123;      min = <span class="hljs-built_in">Math</span>.min(min,node.val-pre)      pre = node.val    &#125;    <span class="hljs-comment">// 中序列遍历，pre存储上一个值，由于BST特性，cur.val永远大于pre</span>    DFS(node.right)  &#125;&#125;</code></pre></div></li></ul><ul><li>从上到下打印二叉树<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printTree</span>(<span class="hljs-params">root</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> []  <span class="hljs-keyword">const</span> queue = [[root,<span class="hljs-number">0</span>]]  <span class="hljs-keyword">const</span> res = []  <span class="hljs-keyword">while</span>(queue.length&gt;<span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">const</span> [node,level] = queue.shift()    <span class="hljs-keyword">if</span>(res[level]) res[level] = []    res[level].push(node.val)    node.left &amp;&amp; queue.push([node.left,level+<span class="hljs-number">1</span>])    node.right &amp;&amp; queue.push(node.right,level+<span class="hljs-number">1</span>)  &#125;  <span class="hljs-keyword">return</span> res&#125;</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈算法题</title>
    <link href="/2020/08/27/%E6%A0%88%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2020/08/27/%E6%A0%88%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="栈结构，先进后出"><a href="#栈结构，先进后出" class="headerlink" title="栈结构，先进后出"></a>栈结构，先进后出</h2><ul><li><p>最小栈</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MinStack</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.stack = []  <span class="hljs-built_in">this</span>.min = [<span class="hljs-literal">Infinity</span>]&#125;MinStack.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>&#123;  <span class="hljs-built_in">this</span>.stack.push(item)  <span class="hljs-built_in">this</span>.min.push(<span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">this</span>.min[<span class="hljs-built_in">this</span>.min.length-<span class="hljs-number">1</span>],item))&#125;MinStack.prototype.pop = <span class="hljs-function"><span class="hljs-keyword">function</span></span>&#123;  <span class="hljs-built_in">this</span>.stack.pop()  <span class="hljs-built_in">this</span>.min.pop()&#125;MinStack.prototype.top = <span class="hljs-function"><span class="hljs-keyword">function</span></span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stack[<span class="hljs-built_in">this</span>.stack.length-<span class="hljs-number">1</span>]&#125;MinStack.prototype.min = <span class="hljs-function"><span class="hljs-keyword">function</span></span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.min[<span class="hljs-built_in">this</span>.min.length-<span class="hljs-number">1</span>]&#125;</code></pre></div></li><li><p>判断括号是否闭合</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// ()</span><span class="hljs-comment">// []</span><span class="hljs-comment">// &#123;&#125;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bracketCheck</span>(<span class="hljs-params">str</span>)</span>&#123;  <span class="hljs-keyword">const</span> brackets = &#123;    <span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-string">&#x27;)&#x27;</span>,    <span class="hljs-string">&#x27;&#123;&#x27;</span>:<span class="hljs-string">&#x27;&#125;&#x27;</span>,    <span class="hljs-string">&#x27;[&#x27;</span>:<span class="hljs-string">&#x27;]&#x27;</span>  &#125;  <span class="hljs-keyword">let</span> stack = []  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ;i&lt;str.length;i++)&#123;    <span class="hljs-keyword">if</span>(brackets[str[i]])&#123;      stack.push([str[i]])    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[i] !== brackets[stack.pop()])&#123;      <span class="hljs-comment">// 这个写法6⃣️啊</span>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;  &#125;  <span class="hljs-keyword">return</span> stack.length === <span class="hljs-number">0</span>&#125;</code></pre></div><ul><li>生成n对括号<br>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</li></ul><p>输入：n = 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateParenthesis</span>(<span class="hljs-params">n</span>)</span>&#123;  <span class="hljs-keyword">const</span> res = []  DFS(l,r,<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-keyword">return</span> res  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DFS</span>(<span class="hljs-params">l,r,str</span>)</span>&#123;    <span class="hljs-comment">// 考虑合理闭合的括号组合</span>    <span class="hljs-comment">// 生成过程中左右括号可使用的数量</span>    <span class="hljs-keyword">if</span>(str.length===<span class="hljs-number">2</span>*n)&#123;      <span class="hljs-keyword">return</span> res.push(str)    &#125;    <span class="hljs-keyword">if</span>(l&gt;<span class="hljs-number">0</span>)&#123;      <span class="hljs-comment">// 左括号有就能用</span>      DFS(l-<span class="hljs-number">1</span>,r,str+<span class="hljs-string">&#x27;(&#x27;</span>)    &#125;    <span class="hljs-keyword">if</span>(l&lt;r)&#123;      DFS(l,r-<span class="hljs-number">1</span>,str+<span class="hljs-string">&#x27;)&#x27;</span>)    &#125;  &#125;&#125;</code></pre></div><ul><li>删除字符串内相邻重复项<div class="hljs code-wrapper"><pre><code class="hljs javascript">给出由小写字母组成的字符串 S ，重复项删除操作 会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delDup</span>(<span class="hljs-params">S</span>)</span>&#123;  <span class="hljs-keyword">let</span> stack = [],pre = <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> c <span class="hljs-keyword">of</span> S)&#123;    pre = stack.pop()    <span class="hljs-keyword">if</span>(c !== pre)&#123;      stack.push(pre)      stack.push(c)    &#125;  &#125;  <span class="hljs-keyword">return</span> stack.join(<span class="hljs-string">&#x27;&#x27;</span>)&#125;</code></pre></div></li></ul><ul><li>滑动窗口最大值<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// k 为窗口大小</span><span class="hljs-comment">// window存储数组索引</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxInSlideWin</span>(<span class="hljs-params">arr,k</span>)</span>&#123;  <span class="hljs-keyword">let</span> res = []  <span class="hljs-keyword">let</span> <span class="hljs-built_in">window</span> = []  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; arr.length ; i++)&#123;    <span class="hljs-keyword">if</span>(i-<span class="hljs-built_in">window</span>[<span class="hljs-number">0</span>]&gt;=k)&#123;      <span class="hljs-comment">// 窗口大小超过限制</span>      <span class="hljs-built_in">window</span>.shift()    &#125;    <span class="hljs-keyword">while</span>(arr[<span class="hljs-built_in">window</span>[<span class="hljs-built_in">window</span>.length-<span class="hljs-number">1</span>]]&lt;=arr[i])&#123;      <span class="hljs-comment">// 用指针位置的值与窗口索引值比较</span>      <span class="hljs-comment">// 循环删除比指针小的值索引</span>      <span class="hljs-built_in">window</span>.pop()    &#125;    <span class="hljs-built_in">window</span>.push(i)    <span class="hljs-keyword">if</span>(i&gt;=k-<span class="hljs-number">1</span>)&#123;      res.push(arr[<span class="hljs-built_in">window</span>[<span class="hljs-number">0</span>]])      <span class="hljs-comment">// 保证窗口内最左值=边索引为最大值</span>    &#125;  &#125;  <span class="hljs-keyword">return</span> res&#125;</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作字符串算法题</title>
    <link href="/2020/08/27/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2020/08/27/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ul><li><p>寻找最长公公前缀</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><span class="hljs-comment">// 输出: &quot;fl&quot;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commonPrefix</span>(<span class="hljs-params">...strs</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!strs.length || strs.length===<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>  <span class="hljs-keyword">let</span> ref = strs[<span class="hljs-number">0</span>]  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;i&lt;strs.length;i++)&#123;    <span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span>(;j&lt;ref.length &amp;&amp; j&lt;strs[i].length;j++)&#123;      <span class="hljs-keyword">if</span>(ref.chartAt(j)!==strs[i].chartAt(j)) <span class="hljs-keyword">break</span>    &#125;    ref = ref.subString(<span class="hljs-number">0</span>,j)  &#125;  <span class="hljs-keyword">return</span> ref&#125;</code></pre></div></li><li><p>连字符转为驼峰</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hump</span>(<span class="hljs-params">str</span>)</span>&#123;  <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/-\w/g</span>,$<span class="hljs-number">1</span>=&gt;&#123;    <span class="hljs-keyword">return</span> $<span class="hljs-number">1.</span>slice(<span class="hljs-number">1</span>).toUpperCase()  &#125;)&#125;</code></pre></div></li></ul><ul><li>将字符串改为首字母大写<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//-i-hate -_you_</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Upper</span>(<span class="hljs-params">str</span>)</span>&#123;  <span class="hljs-keyword">let</span> rule = <span class="hljs-regexp">/\b_?(\w)/g</span>  <span class="hljs-keyword">return</span> str.replace(rule,($<span class="hljs-number">1</span>=&gt;&#123;    <span class="hljs-keyword">return</span> $<span class="hljs-number">1.</span>toUpperCase()  &#125;))&#125;</code></pre></div></li></ul><ul><li>反转句子<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//  正则</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseWords</span>(<span class="hljs-params">str</span>)</span>&#123;  <span class="hljs-keyword">return</span> str.trim().replace(<span class="hljs-regexp">/\s+/g</span>,<span class="hljs-string">&#x27; &#x27;</span>).split(<span class="hljs-string">&#x27; &#x27;</span>).reverse().join(<span class="hljs-string">&#x27; &#x27;</span>)  <span class="hljs-comment">// \s \s是指空白,包括空格、换行、tab缩进等所有的空白</span>  <span class="hljs-comment">// 去除单词之间多余的空白</span>&#125;<span class="hljs-comment">//</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseWords</span>(<span class="hljs-params">str</span>)</span>&#123;  <span class="hljs-keyword">let</span> arr = []  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> right = str.length-<span class="hljs-number">1</span>  <span class="hljs-keyword">let</span> word = <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-keyword">while</span>(str.charAt(left)===<span class="hljs-string">&#x27; &#x27;</span>) left++  <span class="hljs-keyword">while</span>(str.charAt(right)===<span class="hljs-string">&#x27; &#x27;</span>) right--  <span class="hljs-comment">// 去除头尾多余空格</span>  <span class="hljs-keyword">while</span>(left&lt;=right)&#123;    <span class="hljs-keyword">let</span> char = str.charAt(left)    <span class="hljs-keyword">if</span>(char===<span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; word)&#123;      arr.unshift(word)      word = <span class="hljs-string">&#x27;&#x27;</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(char!== <span class="hljs-string">&#x27; &#x27;</span>)&#123;      word += char    &#125;    left ++  &#125;  arr.unshift(word)  <span class="hljs-keyword">return</span> arr.join(<span class="hljs-string">&#x27; &#x27;</span>)&#125;</code></pre></div></li></ul><ul><li>检查回文</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseCheck</span>(<span class="hljs-params">str</span>)</span>&#123;  <span class="hljs-keyword">let</span> s = str.toLowerCase().replace(<span class="hljs-regexp">/[\W_]/g</span>,<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment">// 格式掉不是字母的别的玩意</span>  <span class="hljs-comment">// | `\W`   | 匹配任意不是字母，数字，下划线 |</span>  <span class="hljs-comment">// `[]` 字符串用中括号括起来，表示匹配其中的任一字符</span>  <span class="hljs-keyword">return</span> s === s.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>)&#125;</code></pre></div><ul><li>最长不重复子串长度</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">longest1</span>(<span class="hljs-params">str</span>) </span>&#123;  <span class="hljs-keyword">const</span> <span class="hljs-built_in">window</span> = [];  <span class="hljs-comment">// 滑动窗口</span>  <span class="hljs-keyword">let</span> maxLen = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;    <span class="hljs-keyword">const</span> index = <span class="hljs-built_in">window</span>.indexOf(str[i]);    <span class="hljs-keyword">if</span> (index !== -<span class="hljs-number">1</span>) &#123;      <span class="hljs-built_in">window</span>.splice(<span class="hljs-number">0</span>, index + <span class="hljs-number">1</span>);      <span class="hljs-comment">// 有重复值时缩小窗口</span>    &#125;    <span class="hljs-built_in">window</span>.push(str[i])    <span class="hljs-comment">// 无重复扩大窗口</span>    maxLen = <span class="hljs-built_in">Math</span>.max(maxLen, <span class="hljs-built_in">window</span>.length);  &#125;  <span class="hljs-keyword">return</span> maxLen;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">longest2</span>(<span class="hljs-params">str</span>)</span>&#123;  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()  <span class="hljs-keyword">let</span> maxLen = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>  <span class="hljs-comment">// 设 i 位置右侧字符无重复</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j =<span class="hljs-number">0</span>;j&lt;str.length;j++)&#123;    <span class="hljs-keyword">if</span>(map.has(str[j]))&#123;      i = <span class="hljs-built_in">Math</span>.max(map.get(str[j])+<span class="hljs-number">1</span>,i)      <span class="hljs-comment">// 检测到重复，更新i的位置，注意不一定是str[j]+1，str[j]+1不一定比上一个重复元素的查重位置更靠后</span>      <span class="hljs-comment">// [3,2,1,1,3,2] 3查重的位置明显小于1查重</span>    &#125;    map.set(str[j],j)    maxLen = <span class="hljs-built_in">Math</span>.max((j-i)+<span class="hljs-number">1</span>,maxLen)  &#125;&#125;</code></pre></div><ul><li><p>计算二进制数中1的个数</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// n 为32位二进制数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hammingWeight1</span>(<span class="hljs-params">n</span>)</span>&#123;  <span class="hljs-keyword">const</span> numStr = n.toString(<span class="hljs-number">2</span>).toString()  <span class="hljs-comment">// 呈现字符串或数组</span>  <span class="hljs-comment">//const numStr = n.toString(2).split(&#x27;’)</span>  <span class="hljs-comment">// 然后就是遍历判断</span>  <span class="hljs-keyword">let</span> showTimes = <span class="hljs-number">0</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i =<span class="hljs-number">0</span>;i&lt;numStr.length;i++)&#123;    <span class="hljs-keyword">if</span>(i===<span class="hljs-string">&#x27;1&#x27;</span>)&#123;      showTimes++    &#125;  &#125;  <span class="hljs-keyword">return</span> showTimes&#125;<span class="hljs-comment">// 位运算</span><span class="hljs-comment">// &gt;&gt;&gt; 无符号向右移</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hammingWeight2</span>(<span class="hljs-params">n</span>)</span>&#123;  <span class="hljs-keyword">let</span> showTimes = <span class="hljs-number">0</span>  <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">// 若n&amp;1=0 ，则 n 二进制 最右一位 为 0 ；</span><span class="hljs-comment">// 若n&amp;1=1 ，则 n 二进制 最右一位 为 1 。</span>    showTimes += n&amp;<span class="hljs-number">1</span>    n&gt;&gt;&gt;=<span class="hljs-number">1</span>  &#125;  <span class="hljs-keyword">return</span> showTimes&#125;<span class="hljs-comment">// 整体n &amp;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hammingWeight3</span>(<span class="hljs-params">n</span>)</span>&#123;  <span class="hljs-keyword">let</span> showTimes = <span class="hljs-number">0</span>  <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;    showTimes ++     n  = n &amp; (n-<span class="hljs-number">1</span>)    <span class="hljs-comment">// 二进制 - 中</span>    <span class="hljs-comment">// n-1 相当 于n把最右边的1变为0,其后面的0变为1</span>    <span class="hljs-comment">// n与n-1进行与运算,1&amp;1=1,即只改变了最右边第一个1</span>    <span class="hljs-comment">// 0001000</span>    <span class="hljs-comment">// 0000111</span>    <span class="hljs-comment">// 0000000</span>    <span class="hljs-comment">// 循环删除右边的1</span>  &#125;  <span class="hljs-keyword">return</span> showTimes&#125;</code></pre></div></li><li><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">numberCheck</span>(<span class="hljs-params">s</span>)</span>&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-regexp">/^\s$/</span>.test(s)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(s).toString() !== <span class="hljs-string">&#x27;NaN&#x27;</span>&#125;</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2020/08/27/%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/08/27/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>数组需要申请连续的内存空间，链表可以使用“零散的”内存空间</li><li>插入/删除时间复杂度<code>O(1)</code></li><li>随机访问时间复杂度<code>O(n)</code></li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul><li>零散的内存块称为<code>结点</code></li><li>记录下一个结点地址的指针叫做<code>后继指针next</code></li><li><code>headNode</code></li><li><code>tailNode.next = null</code></li></ul><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><ul><li>单链表</li><li>循环链表</li></ul><p>  <code>tailNode.next = headNode</code></p><p>  适合处理环状结构的数据</p><ul><li><p>双向链表</p><p>结点拥有两个指针<br><code>curNode.prev</code><br><code>curNode.next</code></p><p><code>O(1)</code>时间复杂度即可访问前序结点</p></li><li><p>双向循环链表</p><p><code>headNode.prev = tailNode</code><br><code>tailNode.next = headNode</code></p></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 单向链表</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">linkedList</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span>;    <span class="hljs-built_in">this</span>.length = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-comment">// 追加</span>  <span class="hljs-function"><span class="hljs-title">append</span>(<span class="hljs-params">element</span>)</span> &#123;    <span class="hljs-keyword">const</span> n = <span class="hljs-keyword">new</span> Node(element);    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head;    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.head) &#123;      <span class="hljs-built_in">this</span>.head = n;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">while</span> (cur.next) &#123;        cur = cur.next;      &#125;      cur.next = n;      <span class="hljs-built_in">this</span>.length++;    &#125;  &#125;  <span class="hljs-comment">// 查找</span>  <span class="hljs-function"><span class="hljs-title">search</span>(<span class="hljs-params">element</span>)</span> &#123;    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head;    <span class="hljs-keyword">if</span> (!cur) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">while</span> (cur) &#123;      <span class="hljs-keyword">if</span> (cur.element === element) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      &#125;      cur = cur.next;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// 插入</span>  <span class="hljs-comment">// position之前插入新node</span>  <span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">position, element</span>)</span> &#123;    <span class="hljs-keyword">if</span> (position &gt;= <span class="hljs-number">0</span> &amp;&amp; position &lt;= <span class="hljs-built_in">this</span>.length) &#123;      <span class="hljs-keyword">let</span> n = <span class="hljs-keyword">new</span> Node(element);      <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) &#123;        n.next = <span class="hljs-built_in">this</span>.head;        <span class="hljs-built_in">this</span>.head = n;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head,pre        <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (index &lt; position) &#123;          pre = cur;          cur = cur.next;          index++;        &#125;        pre.next = n;        n.next = cur;      &#125;      <span class="hljs-built_in">this</span>.length++;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;  &#125;  <span class="hljs-comment">// 删除</span>  <span class="hljs-function"><span class="hljs-title">remove</span>(<span class="hljs-params">element</span>)</span> &#123;    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head,      pre = <span class="hljs-built_in">this</span>.head    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    <span class="hljs-keyword">while</span> (cur) &#123;      <span class="hljs-keyword">if</span> (cur.element === element) &#123;        cur = cur.next;        pre.next = cur;        <span class="hljs-built_in">this</span>.length --       &#125;      pre = cur      cur = cur.next;    &#125;  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">element</span>)</span> &#123;    <span class="hljs-built_in">this</span>.element = element;    <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;  &#125;&#125;<span class="hljs-comment">// 双向链表</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DubLinkedList</span>(<span class="hljs-params">params</span>) </span>&#123;  <span class="hljs-keyword">const</span> Node = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>&#123;    <span class="hljs-built_in">this</span>.prev = <span class="hljs-literal">null</span>;    <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;    <span class="hljs-built_in">this</span>.element = element;  &#125;;  <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span>;  <span class="hljs-built_in">this</span>.tail = <span class="hljs-literal">null</span>;  <span class="hljs-built_in">this</span>.length = <span class="hljs-number">0</span>;  <span class="hljs-built_in">this</span>.append = <span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> newNode = <span class="hljs-keyword">new</span> Node(element);    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head;    <span class="hljs-keyword">if</span> (!cur) &#123;      <span class="hljs-built_in">this</span>.head = newNode;      <span class="hljs-built_in">this</span>.tail = newNode;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">while</span> (cur.next) &#123;        cur = cur.next;      &#125;      cur.next = newNode      newNode.prev = cur      <span class="hljs-built_in">this</span>.tail = newNode    &#125;    <span class="hljs-built_in">this</span>.length++;  &#125;  <span class="hljs-built_in">this</span>.insert = <span class="hljs-function">(<span class="hljs-params">position,element</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(position&gt;=<span class="hljs-number">0</span> &amp;&amp; position &lt;=<span class="hljs-built_in">this</span>.length)&#123;      <span class="hljs-keyword">let</span> newNode = <span class="hljs-keyword">new</span> Node(element)      <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head,pre      <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>      <span class="hljs-keyword">if</span>(position===<span class="hljs-number">0</span>)&#123;        <span class="hljs-comment">//头</span>        <span class="hljs-keyword">if</span>(!cur)&#123;          <span class="hljs-built_in">this</span>.head = newNode;          <span class="hljs-built_in">this</span>.tail = newNode;        &#125;<span class="hljs-keyword">else</span>&#123;          newNode.next = <span class="hljs-built_in">this</span>.head          cur.prev = newNode          <span class="hljs-built_in">this</span>.head = newNode        &#125;      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(position===<span class="hljs-built_in">this</span>.length)&#123;        <span class="hljs-comment">//尾巴</span>        cur = <span class="hljs-built_in">this</span>.tail        cur.prev = newNode        newNode.next = cur        <span class="hljs-built_in">this</span>.tail = newNode      &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">while</span>(index&lt;position)&#123;          pre = cur          cur = cur.next          index++        &#125;        cur.prev = newNode        pre.next = newNode        newNode.next = cur        newNode.prev = pre      &#125;      <span class="hljs-built_in">this</span>.length ++    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;  &#125;  <span class="hljs-built_in">this</span>.remove = <span class="hljs-function"><span class="hljs-params">position</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(position&gt;=<span class="hljs-number">0</span> &amp;&amp; position&lt;<span class="hljs-built_in">this</span>.length &amp;&amp; <span class="hljs-built_in">this</span>.length&gt;<span class="hljs-number">0</span>)&#123;      <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head,pre,index = <span class="hljs-number">0</span>      <span class="hljs-keyword">if</span>(position===<span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.length === <span class="hljs-number">1</span>)&#123;          <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span>          <span class="hljs-built_in">this</span>.tail = <span class="hljs-literal">null</span>        &#125;<span class="hljs-keyword">else</span>&#123;          cur = cur.next          cur.prev = <span class="hljs-literal">null</span>          <span class="hljs-built_in">this</span>.head = cur        &#125;      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(position===<span class="hljs-built_in">this</span>.length-<span class="hljs-number">1</span>)&#123;        cur = <span class="hljs-built_in">this</span>.tail        pre = cur.prev        pre.next = <span class="hljs-literal">null</span>        <span class="hljs-built_in">this</span>.tail = pre      &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">while</span>(index&lt;position)&#123;          pre = cur          cur = cur.next          index ++        &#125;        cur = cur.next        pre.next = cur        cur.prev = pre      &#125;      <span class="hljs-built_in">this</span>.length --      <span class="hljs-keyword">return</span> cur.element    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>    &#125;  &#125;  <span class="hljs-built_in">this</span>.search = <span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span>&#123;    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head    <span class="hljs-keyword">while</span>(cur)&#123;      <span class="hljs-keyword">if</span>(cur.element === element)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>      &#125;      cur = cur.next    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  &#125;&#125;</code></pre></div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="注意边界情况"><a href="#注意边界情况" class="headerlink" title="注意边界情况"></a>注意边界情况</h3><ul><li>链表为空</li><li>链表只有一个结点</li><li>链表只有两个结点</li><li>处理头部结点和尾部结点</li></ul><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul><li>单链表反转<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseLinkedList</span>(<span class="hljs-params">head</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!head.next) <span class="hljs-keyword">return</span> head  <span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>  <span class="hljs-keyword">let</span> cur = head  <span class="hljs-keyword">while</span>(cur)&#123;    <span class="hljs-keyword">const</span> n = cur.next    cur.next = pre    pre = cur    cur = n  &#125;  <span class="hljs-keyword">return</span> pre&#125;<span class="hljs-comment">// es6</span><span class="hljs-keyword">let</span> [pre,cur] = [<span class="hljs-literal">null</span>,head]<span class="hljs-keyword">while</span>(cur)&#123;  [cur.next,pre,cur] = [pre,cur,cur.next]&#125;<span class="hljs-keyword">return</span> pre</code></pre></div></li><li>检测链表是否循环<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//</span><span class="hljs-built_in">JSON</span>.stringify() <span class="hljs-comment">//不能序列化循环链表</span><span class="hljs-comment">//标记</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isLoop</span>(<span class="hljs-params">head</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-keyword">let</span> cur = head  <span class="hljs-keyword">while</span>(cur)&#123;    <span class="hljs-keyword">if</span>(cur.flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    cur.flag = <span class="hljs-literal">true</span>    cur = cur.next  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-comment">// 快慢指针</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isLoop2</span>(<span class="hljs-params">head</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!head || !head.next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-keyword">let</span> fast = head.next.next  <span class="hljs-keyword">let</span> slow = head.next  <span class="hljs-keyword">while</span>(slow!==fast)&#123;    <span class="hljs-keyword">if</span>(!fast || !fast.next)&#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    fast = fast.next.next    slow = slow.next  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre></div></li></ul><ul><li><p>实现LRU缓存淘汰策略</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">value</span>)</span>&#123;  <span class="hljs-built_in">this</span>.value = value  <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LRULinkedList</span>(<span class="hljs-params">maxSize</span>)</span>&#123;  <span class="hljs-built_in">this</span>.maxSize = maxSize  <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span>  <span class="hljs-built_in">this</span>.curSize = <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>.visit = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> n = <span class="hljs-keyword">new</span> Node(value)    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head,pre = <span class="hljs-built_in">this</span>.head    <span class="hljs-keyword">let</span> preCatch,curCatch    <span class="hljs-keyword">if</span>(!cur)&#123;      <span class="hljs-built_in">this</span>.head = n      <span class="hljs-built_in">this</span>.curSize = <span class="hljs-number">1</span>      <span class="hljs-keyword">return</span>     &#125;    <span class="hljs-keyword">if</span>(cur.value===value) <span class="hljs-keyword">return</span>     <span class="hljs-keyword">while</span>(cur)&#123;      <span class="hljs-keyword">if</span>(cur.value === value)&#123;          <span class="hljs-comment">// 找到了</span>          <span class="hljs-comment">// 从原来位置删除并作为头</span>          pre.next = cur.next          cur.next = <span class="hljs-built_in">this</span>.head          <span class="hljs-keyword">return</span>      &#125;      preCatch = pre      curCatch = cur      pre = cur      cur = cur.next    &#125;    <span class="hljs-comment">// 没找到</span>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.curSize&lt;maxSize)&#123;      <span class="hljs-comment">// 插入头部</span>      n.next = <span class="hljs-built_in">this</span>.head      <span class="hljs-built_in">this</span>.head = n      <span class="hljs-built_in">this</span>.curSize ++    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">// 删除尾部结点</span>      <span class="hljs-comment">// 插入头部</span>      preCatch.next = <span class="hljs-literal">null</span>      curCatch.next = <span class="hljs-built_in">this</span>.head      <span class="hljs-built_in">this</span>.head = curCatch    &#125;  &#125;&#125;</code></pre></div></li><li><p>回文链表</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 快慢指针找出中点</span><span class="hljs-comment">// 一半的链表与另一半链表组成的栈对比</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPalindrome</span>(<span class="hljs-params">head</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!head || !head.next) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  <span class="hljs-keyword">const</span> stack = []  <span class="hljs-keyword">let</span> slow = head  <span class="hljs-keyword">let</span> fast = head  <span class="hljs-keyword">while</span>(fast &amp;&amp; fast.next &amp;&amp; fast.next.next)&#123;    slow = slow.next    fast = fast.next.next  &#125;  <span class="hljs-keyword">let</span> mid  = slow  <span class="hljs-keyword">while</span> (mid.next) &#123;    stack.push(mid.next)    mid = mid.next  &#125;  <span class="hljs-keyword">while</span>(stack.length&gt;<span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">if</span>(head.val !== stack.pop().val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    head = head.next  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-comment">// 或者将链表转数组，对撞指针</span><span class="hljs-comment">// 另一种是到到中点后反转链表，不使用辅助栈</span></code></pre></div></li><li><p>合并两个有序链表</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1-&gt;2-&gt;4,1-&gt;3-&gt;4</span><span class="hljs-comment">// 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeLinkedList</span>(<span class="hljs-params">l1,l2</span>)</span>&#123;  <span class="hljs-keyword">if</span>(l1===<span class="hljs-literal">null</span>)&#123;    <span class="hljs-keyword">return</span> l2  &#125;  <span class="hljs-keyword">if</span>(l2===<span class="hljs-literal">null</span>)&#123;    <span class="hljs-keyword">return</span> l1  &#125;  <span class="hljs-keyword">if</span>(l1.value&lt;=l2.value)&#123;    l1.next = mergeLinkedList(l1.next,l2)    <span class="hljs-keyword">return</span> l1  &#125;<span class="hljs-keyword">else</span>&#123;    l2.next = mergeLinkedList(l2.next,l1)    <span class="hljs-keyword">return</span> l2  &#125;&#125;<span class="hljs-comment">// 或者蠢办法</span><span class="hljs-keyword">var</span> mergeTwoLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;   <span class="hljs-keyword">const</span> n = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>)   <span class="hljs-keyword">let</span> cur = n   <span class="hljs-keyword">while</span>(l1&amp;&amp;l2)&#123;       <span class="hljs-keyword">if</span>(l1.val&lt;=l2.val)&#123;           cur.next = l1           l1 = l1.next       &#125;<span class="hljs-keyword">else</span>&#123;           cur.next = l2           l2 = l2.next       &#125;       cur = cur.next   &#125;   <span class="hljs-comment">// 有一条到头咯</span>   <span class="hljs-keyword">if</span>(l1)&#123;       cur.next = l1   &#125;<span class="hljs-keyword">else</span>&#123;       cur.next = l2   &#125;   <span class="hljs-keyword">return</span> n.next&#125;;</code></pre></div></li><li><p>查找两个链表的公共起始点</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commonPrefix</span>(<span class="hljs-params">headA,headB</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!headA || !headB) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  <span class="hljs-keyword">while</span>(headA)&#123;    headA.flag = <span class="hljs-literal">true</span>    headA = headA.next  &#125;  <span class="hljs-keyword">while</span>(headB)&#123;    <span class="hljs-keyword">if</span>(headB.flag) <span class="hljs-keyword">return</span> headB    headB.flag =<span class="hljs-literal">true</span>    headB = headB.next  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commonPrefix2</span>(<span class="hljs-params">headA,headB</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!headA || !headB) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  <span class="hljs-comment">// 连个链表同时移动指针</span>  <span class="hljs-keyword">let</span> n1 = headA  <span class="hljs-keyword">let</span> n2 = headB  <span class="hljs-keyword">while</span>(n1 || n2)&#123;    <span class="hljs-keyword">if</span>(n1===n2) <span class="hljs-keyword">return</span> n1    <span class="hljs-comment">//指针到头后跳到对面的开头</span>    n1 = n1 === <span class="hljs-literal">null</span> ? headB : n1.next    n2 = n2 === <span class="hljs-literal">null</span> ? headA : n2.next  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>&#125;</code></pre></div></li><li><p>删除特定值链表节点</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteNode</span>(<span class="hljs-params">head,val</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span>   <span class="hljs-keyword">if</span>(head.val === val)&#123;    <span class="hljs-keyword">return</span> head.next  &#125;  head.next = deleteNode(head.next,val)  <span class="hljs-keyword">return</span> head&#125;</code></pre></div></li><li><p>返回链表中特定位置节点</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 计数法</span><span class="hljs-comment">// 一遍算链表长度</span><span class="hljs-comment">// 一遍根据位置.next</span><span class="hljs-comment">// 计数法配合map</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getKthFromEnd</span>(<span class="hljs-params">head,k</span>)</span>&#123;  <span class="hljs-keyword">let</span> pos = <span class="hljs-number">1</span>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()  <span class="hljs-keyword">while</span>(head)&#123;    map.set(pos++,head)    head = head.next  &#125;  <span class="hljs-keyword">return</span> map.get(pos-k)&#125;<span class="hljs-comment">// 双指针</span><span class="hljs-comment">// 返回倒数k位置</span><span class="hljs-comment">//  * Definition for singly-linked list.</span><span class="hljs-comment">//  * function ListNode(val) &#123;</span><span class="hljs-comment">//  *     this.val = val;</span><span class="hljs-comment">//  *     this.next = null;</span><span class="hljs-comment">//  * &#125;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getKthFromEnd</span>(<span class="hljs-params">head,k</span>)</span>&#123;  <span class="hljs-keyword">let</span> fast = head  <span class="hljs-keyword">let</span> slow = head  <span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>  <span class="hljs-keyword">while</span>(fast.next)&#123;    fast = fast.next    t ++    <span class="hljs-keyword">if</span>(t&gt;=k) slow = slow.next  &#125;  <span class="hljs-keyword">return</span> slow&#125;</code></pre></div></li><li><p>字符串中第一个不重复字符</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//map</span><span class="hljs-comment">//循环两次</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">firstUniqChar</span>(<span class="hljs-params">s</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!s) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [i,v] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Array</span>.from(s).entries())&#123;    <span class="hljs-keyword">if</span>(map.has(v))&#123;      map.set(v,-<span class="hljs-number">1</span>)    &#125;<span class="hljs-keyword">else</span>&#123;      map.set(v,i)    &#125;  &#125;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> map.keys())&#123;    <span class="hljs-keyword">if</span>(map.get(key)!==-<span class="hljs-number">1</span>)&#123;      <span class="hljs-keyword">return</span> key    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>&#125;<span class="hljs-comment">//</span>...indexOf===lastIndexOf...</code></pre></div></li><li><p>字符串能否构成回文</p></li></ul><p>字符顺序修改后能否回文<br>相当于非回文字符最多只有一个</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">canPermutePalindrome</span>(<span class="hljs-params">s</span>)</span>&#123;  <span class="hljs-comment">// map // object都行</span>&#125;<span class="hljs-keyword">var</span> canPermutePalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;  <span class="hljs-keyword">const</span> obj = &#123;&#125;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i&lt;s.length ;i++)&#123;    <span class="hljs-keyword">const</span> str = s[i]    <span class="hljs-built_in">console</span>.log(str);    <span class="hljs-keyword">if</span>(obj[str])&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>);      <span class="hljs-keyword">delete</span> obj[str]    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">// 使用object时，上面的if(obj[str])会和这里冲突</span>      <span class="hljs-comment">// 刚好设置obj[str] = 0</span>      <span class="hljs-comment">// if判断不成立</span>      obj[str] = <span class="hljs-number">1</span>    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(obj).length &lt;= <span class="hljs-number">1</span>&#125;;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>待整理的js片段</title>
    <link href="/2020/08/17/js%E7%89%87%E6%AE%B5/"/>
    <url>/2020/08/17/js%E7%89%87%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<ul><li>字母的所有组合</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> anagrams = <span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> &#123;  <span class="hljs-keyword">if</span>(str.length&lt;=<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> str.length===<span class="hljs-number">2</span> ? [str , str[<span class="hljs-number">1</span>] + str[<span class="hljs-number">0</span>]] :str  <span class="hljs-comment">// 这里使用reduce的第三个参数index，正在处理的元素</span>  <span class="hljs-comment">// 如果提供了initialValue，则起始索引号为0，否则从索引1起始。</span>  <span class="hljs-keyword">return</span> str.split(<span class="hljs-string">&#x27;&#x27;</span>).reduce(<span class="hljs-function">(<span class="hljs-params">acc,cur,index</span>)=&gt;</span>&#123;    <span class="hljs-keyword">let</span> other = str.slice(<span class="hljs-number">0</span>,index)+str.slice(index+<span class="hljs-number">1</span>)    <span class="hljs-comment">// other为除了当前处理元素外的字母</span>    <span class="hljs-comment">// a bcd =&gt;</span>    <span class="hljs-comment">// b cd =&gt; bcd bdc</span>    <span class="hljs-comment">// c bd =&gt; cbd cdb</span>    <span class="hljs-comment">// d bc =&gt; dbc dcb</span>    <span class="hljs-comment">// b...</span>    <span class="hljs-keyword">return</span> acc.concat(anagrams(other).map(<span class="hljs-function"><span class="hljs-params">char</span>=&gt;</span>cur+char))    <span class="hljs-comment">// 递归至两位数数组颠倒排序,并将所有可能与当前处理元素组合</span>  &#125;,[])  <span class="hljs-comment">// 指定initialValue</span>&#125;anagrams(<span class="hljs-string">&#x27;abcd&#x27;</span>) =&gt; [  <span class="hljs-string">&#x27;abcd&#x27;</span>, <span class="hljs-string">&#x27;abdc&#x27;</span>, <span class="hljs-string">&#x27;acbd&#x27;</span>,  <span class="hljs-string">&#x27;acdb&#x27;</span>, <span class="hljs-string">&#x27;adbc&#x27;</span>, <span class="hljs-string">&#x27;adcb&#x27;</span>,  <span class="hljs-string">&#x27;bacd&#x27;</span>, <span class="hljs-string">&#x27;badc&#x27;</span>, <span class="hljs-string">&#x27;bcad&#x27;</span>,  <span class="hljs-string">&#x27;bcda&#x27;</span>, <span class="hljs-string">&#x27;bdac&#x27;</span>, <span class="hljs-string">&#x27;bdca&#x27;</span>,  <span class="hljs-string">&#x27;cabd&#x27;</span>, <span class="hljs-string">&#x27;cadb&#x27;</span>, <span class="hljs-string">&#x27;cbad&#x27;</span>,  <span class="hljs-string">&#x27;cbda&#x27;</span>, <span class="hljs-string">&#x27;cdab&#x27;</span>, <span class="hljs-string">&#x27;cdba&#x27;</span>,  <span class="hljs-string">&#x27;dabc&#x27;</span>, <span class="hljs-string">&#x27;dacb&#x27;</span>, <span class="hljs-string">&#x27;dbac&#x27;</span>,  <span class="hljs-string">&#x27;dbca&#x27;</span>, <span class="hljs-string">&#x27;dcab&#x27;</span>, <span class="hljs-string">&#x27;dcba&#x27;</span>]</code></pre></div><ul><li>大写每个单词的首字母</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> capitalizeWords = <span class="hljs-function">(<span class="hljs-params">words</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> words.replace(<span class="hljs-regexp">/\b[a-z]/g</span>, <span class="hljs-function">(<span class="hljs-params">word</span>) =&gt;</span> word.toUpperCase());  <span class="hljs-comment">// \b匹配作为单词边界的那个字符</span>  <span class="hljs-comment">// 即匹配到了每一个单词的首字母</span>&#125;;</code></pre></div><ul><li>格式化只有首字母大写</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> capitalize = <span class="hljs-function">(<span class="hljs-params">str, lowerRest = <span class="hljs-literal">false</span></span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> (    str.slice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase() +    (lowerRest ? str.slice(<span class="hljs-number">1</span>).toLowerCase() : str.slice(<span class="hljs-number">1</span>))  );&#125;;</code></pre></div><ul><li>出现次数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> countOccurrences = <span class="hljs-function">(<span class="hljs-params">arr, value</span>) =&gt;</span>  arr.reduce(<span class="hljs-function">(<span class="hljs-params">a, v</span>) =&gt;</span> (v === value ? a + <span class="hljs-number">1</span> : a + <span class="hljs-number">0</span>), <span class="hljs-number">0</span>);<span class="hljs-comment">// countOccurrences([1,1,2,1,2,3], 1) -&gt; 3</span></code></pre></div><ul><li>Deep flatten array</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> deepFlatten = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span>  arr.reduce(<span class="hljs-function">(<span class="hljs-params">a, v</span>) =&gt;</span> a.concat(<span class="hljs-built_in">Array</span>.isArray(v) ? deepFlatten(v) : v), []);<span class="hljs-comment">// deepFlatten([1,[2],[[3],4],5]) -&gt; [1,2,3,4,5]</span></code></pre></div><ul><li>bifurcate</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bifurcate = <span class="hljs-function">(<span class="hljs-params">arr, filter</span>) =&gt;</span>  arr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, val, i</span>) =&gt;</span> (acc[filter[i] ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>].push(val), acc), [    [],    [],  ]);bifurcate([<span class="hljs-string">&quot;beep&quot;</span>, <span class="hljs-string">&quot;boop&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>], [<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>]);<span class="hljs-comment">// [ [&#x27;beep&#x27;, &#x27;boop&#x27;, &#x27;bar&#x27;], [&#x27;foo&#x27;] ]</span></code></pre></div><ul><li>阶乘</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> factorial = <span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> (n &lt;= <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : n * factorial(n - <span class="hljs-number">1</span>));<span class="hljs-comment">// factorial(6) -&gt; 720</span></code></pre></div><ul><li>斐波那契数组生成器</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fibonacci = <span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span>  <span class="hljs-built_in">Array</span>(n)    .fill(<span class="hljs-number">0</span>)    .reduce(      (acc, val, i) =&gt; acc.concat(i &gt; <span class="hljs-number">1</span> ? acc[i - <span class="hljs-number">1</span>] + acc[i - <span class="hljs-number">2</span>] : i),      []    );<span class="hljs-comment">// fibonacci(5) -&gt; [0,1,1,2,3]</span><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">fib</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> [pre, cur] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];  <span class="hljs-keyword">for</span> (;;) &#123;    <span class="hljs-comment">// 死循环的另一种写法</span>    <span class="hljs-comment">// while(true)</span>    [pre, cur] = [cur, cur + pre];    <span class="hljs-keyword">yield</span> cur;  &#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> fib()) &#123;  <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">100</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-built_in">console</span>.log(x);&#125;</code></pre></div><ul><li>数组中唯一值</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> filterNonUnique = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span>  arr.filter(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> arr.indexOf(i) === arr.lastIndexOf(i));<span class="hljs-comment">// filterNonUnique([1,2,2,3,4,4,5]) -&gt; [1,3,5]</span></code></pre></div><ul><li>最大公约数（GCD）</li></ul><p>使用递归。基本情况是当 y 等于 0 时。在这种情况下，返回 x。否则，返回 y 的 GCD 和 x / y 的其余部分。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> gcd = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> (!y ? x : gcd(y, x % y));<span class="hljs-comment">// gcd (8, 36) -&gt; 4</span></code></pre></div><ul><li>范围内生成数组</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> initializeArrayRange = <span class="hljs-function">(<span class="hljs-params">end, start = <span class="hljs-number">0</span></span>) =&gt;</span>  <span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">Array</span>(end - start)).map(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> i + start);<span class="hljs-comment">// initializeArrayRange(5) -&gt; [0,1,2,3,4]</span></code></pre></div><ul><li>function 计时</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> timeTaken = <span class="hljs-function">(<span class="hljs-params">callback</span>) =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.time(<span class="hljs-string">&quot;timeTaken&quot;</span>);  <span class="hljs-keyword">const</span> r = callback();  <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&quot;timeTaken&quot;</span>);  <span class="hljs-keyword">return</span> r;&#125;;<span class="hljs-comment">// timeTaken(() =&gt; Math.pow(2, 10)) -&gt; 1024</span><span class="hljs-comment">// (logged): timeTaken: 0.02099609375ms</span></code></pre></div><ul><li>打乱数组</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> shuffle = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> arr.sort(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">Math</span>.random() - <span class="hljs-number">0.5</span>);<span class="hljs-comment">// shuffle([1,2,3]) -&gt; [2,3,1]</span></code></pre></div><ul><li>RGB 转十六进制</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> rgbToHex = <span class="hljs-function">(<span class="hljs-params">r, g, b</span>) =&gt;</span>  ((r &lt;&lt; <span class="hljs-number">16</span>) + (g &lt;&lt; <span class="hljs-number">8</span>) + b).toString(<span class="hljs-number">16</span>).padStart(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-comment">// rgbToHex(255, 165, 1) -&gt; &#x27;ffa501&#x27;</span></code></pre></div><ul><li>字符串按字母排序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sortCharactersInString = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span>  str    .split(<span class="hljs-string">&quot;&quot;</span>)    .sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.localeCompare(b))    .join(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">// sortCharactersInString(&#x27;cabbage&#x27;) -&gt; &#x27;aabbceg&#x27;</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法题</title>
    <link href="/2020/08/02/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2020/08/02/%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ul><li><p>两数之合</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">arr,target</span>)</span>&#123;  <span class="hljs-keyword">let</span> res = []  <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()  <span class="hljs-comment">// 使用数值-&gt;索引建立map</span>  <span class="hljs-comment">// 每次循环计算得出当前差值</span>  <span class="hljs-comment">// 在map中查找这个差值既能得出索引</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i&lt;arr.length;i++)&#123;    <span class="hljs-keyword">let</span> k = target - arr[i]    <span class="hljs-keyword">if</span>(map.has(k))&#123;      res.push([map.get(k),i])    &#125;    map.set(arr[i],i)  &#125;  <span class="hljs-keyword">return</span> res.length === <span class="hljs-number">1</span> ? res[<span class="hljs-number">0</span>] : res&#125;</code></pre></div></li><li><p>排序数组的两数之和</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">nums,target</span>)</span>&#123;  <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> r = nums.length-<span class="hljs-number">1</span>  <span class="hljs-keyword">while</span>(l&lt;r)&#123;    <span class="hljs-keyword">const</span> curSum = nums[l]+nums[r]    <span class="hljs-keyword">if</span>(curNum === target) <span class="hljs-keyword">return</span> [nums[l],nums[r]]    <span class="hljs-keyword">if</span>(curNum&gt;target)&#123;      r --    &#125;<span class="hljs-keyword">else</span>&#123;      l ++    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre></div></li></ul><ul><li><p>三数之合</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">threeSum</span>(<span class="hljs-params">arr,target</span>)</span>&#123;  <span class="hljs-keyword">let</span> res = []  <span class="hljs-keyword">let</span> len = arr.length  <span class="hljs-keyword">if</span>(len&lt;<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> res  arr = arr.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>a-b)  <span class="hljs-comment">// 按大小排序</span>  <span class="hljs-comment">// 开始循环</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i&lt; len;i++)&#123;    <span class="hljs-keyword">if</span>(arr[i]&gt;=target) <span class="hljs-keyword">break</span>    <span class="hljs-comment">// 第一个值就大于target后面不用想了</span>    <span class="hljs-keyword">if</span>(arr[i] === arr[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>    <span class="hljs-comment">// 跳过重复的值</span>    <span class="hljs-keyword">let</span> first = i,    second = i+<span class="hljs-number">1</span>,    third = len-<span class="hljs-number">1</span>    <span class="hljs-keyword">while</span>(second&lt;third)&#123;      <span class="hljs-keyword">const</span> sum = arr[first]+arr[second]+arr[third]      <span class="hljs-keyword">if</span>(sum===target)&#123;        res.push([arr[first],arr[second],arr[third]])        second++        third--        <span class="hljs-comment">// 移动一次指针再跳过重复项</span>        <span class="hljs-keyword">while</span>(arr[second]===arr[second-<span class="hljs-number">1</span>])&#123;          second ++        &#125;        <span class="hljs-keyword">while</span>(arr[third]===arr[third+<span class="hljs-number">1</span>])&#123;          third --        &#125;      &#125;      <span class="hljs-comment">//移动指针</span>      <span class="hljs-keyword">if</span>(sum&gt;target) third --      <span class="hljs-keyword">if</span>(sum&lt;target) second ++    &#125;  &#125;  <span class="hljs-keyword">return</span> res&#125;</code></pre></div></li><li><p>最大面积</p><p>  给定数组，按数组index为x轴坐标,value为y轴坐标在二纬坐标系画线，连接哪两条线时得到最大面积</p><blockquote><p>面积 = 两直线中较短的高度 * 两线间距离</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxArea</span>(<span class="hljs-params">height</span>)</span>&#123;  <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> r = height.length - <span class="hljs-number">1</span>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>  <span class="hljs-keyword">while</span>(l&lt;r)&#123;    res = <span class="hljs-built_in">Math</span>.max(res,(r-l)*<span class="hljs-built_in">Math</span>.min(height[l],height[r]))    <span class="hljs-keyword">if</span>(height[l]&lt;height[r])&#123;      l++    &#125;<span class="hljs-keyword">else</span>&#123;      r--    &#125;  &#125;  <span class="hljs-keyword">return</span> res &#125;</code></pre></div></blockquote></li><li><p>删除排序数组中的重复项，不能使用额外空间，返回不重复的长度</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeDuplicates</span>(<span class="hljs-params">arr</span>)</span>&#123;  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> len = arr.length  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>;j&lt;len;j++)&#123;    <span class="hljs-keyword">if</span>(arr[j] !== arr[j-<span class="hljs-number">1</span>])&#123;      arr[++i] = arr[j]    &#125;  &#125;  <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>&#125;</code></pre></div></li><li><p>设计一个支持在平均时间复杂度 O(1) 下，执行以下操作的数据结构。</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">insert(val) ：当元素 val 不存在时，向集合中插入该项。remove(val) ：元素 val 存在时，从集合中移除该项。getRandom ：随机返回现有集合中的一项。每个元素应该有 相同的概率 被返回。示例 :<span class="hljs-comment">// 初始化一个空的集合。</span>RandomizedSet randomSet = <span class="hljs-keyword">new</span> RandomizedSet();<span class="hljs-comment">// 向集合中插入 1 。返回 true 表示 1 被成功地插入。</span>randomSet.insert(<span class="hljs-number">1</span>);<span class="hljs-comment">// 返回 false ，表示集合中不存在 2 。</span>randomSet.remove(<span class="hljs-number">2</span>);<span class="hljs-comment">// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。</span>randomSet.insert(<span class="hljs-number">2</span>);<span class="hljs-comment">// getRandom 应随机返回 1 或 2 。</span>randomSet.getRandom();<span class="hljs-comment">// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。</span>randomSet.remove(<span class="hljs-number">1</span>);<span class="hljs-comment">// 2 已在集合中，所以返回 false 。</span>randomSet.insert(<span class="hljs-number">2</span>);<span class="hljs-comment">// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。</span>randomSet.getRandom();<span class="hljs-comment">// map方法</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">RandomSet</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()  <span class="hljs-built_in">this</span>.values = []&#125;RandomSet.prototype.insert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.map.has(val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-built_in">this</span>.map.set(val,values.length)  <span class="hljs-comment">// 插入后的索引（插入前的数组长度）</span>  <span class="hljs-built_in">this</span>.values.push(val)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;RandomSet.prototype.remove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.map.has(val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">this</span>.map.get(val)  <span class="hljs-comment">// 判断在尾部</span>  <span class="hljs-comment">// 似乎也可以用头部</span>  <span class="hljs-keyword">if</span>(index === <span class="hljs-built_in">this</span>.values.length - <span class="hljs-number">1</span>)&#123;    <span class="hljs-built_in">this</span>.map.delete(value)    <span class="hljs-built_in">this</span>.values.pop()  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-comment">// 不在尾部</span>    <span class="hljs-comment">// values用尾部元素填充该位置</span>    <span class="hljs-comment">// map中修改索引</span>    <span class="hljs-keyword">let</span> last = <span class="hljs-built_in">this</span>.values.pop()    <span class="hljs-comment">// 赋值</span>    <span class="hljs-built_in">this</span>.values[index] = last    <span class="hljs-built_in">this</span>.map.set(last,index)    <span class="hljs-built_in">this</span>.map.delete(val)  &#125;  <span class="hljs-keyword">return</span> val&#125;RandomSet.prototype.getRandom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">let</span> len = <span class="hljs-built_in">this</span>.values.length  <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random()*len)  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.values[index]&#125;<span class="hljs-comment">// set方法</span><span class="hljs-comment">// set是不重复的值的集合</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">RandomSet</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()&#125;RandomizedSet.prototype.insert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.data.has(val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-built_in">this</span>.set.add(val)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;RandomizedSet.prototype.remove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.data.has(val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-built_in">this</span>.set.delete(val)  <span class="hljs-keyword">return</span> val&#125;RandomizedSet.prototype.getRandom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">let</span> len = <span class="hljs-built_in">this</span>.values.length  <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random()*len)  <span class="hljs-keyword">return</span> [...this.data][index]&#125;</code></pre></div></li></ul><ul><li>合并两个有序数组  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// arr1 = [1,2,5]  m=3</span><span class="hljs-comment">// arr2 = [2,3,4]  n=3</span><span class="hljs-comment">// 假设arr1能装下arr2</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeArr</span>(<span class="hljs-params">arr1,m,arr2,n</span>)</span>&#123;  <span class="hljs-keyword">let</span> index1 = m-<span class="hljs-number">1</span>  <span class="hljs-keyword">let</span> index2 = n-<span class="hljs-number">1</span>  <span class="hljs-keyword">let</span> index = m+n-<span class="hljs-number">1</span>  <span class="hljs-keyword">while</span>(index&gt;=<span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">if</span>(index2&lt;<span class="hljs-number">0</span>)&#123;      <span class="hljs-comment">// arr2耗尽</span>      <span class="hljs-comment">// 剩下保持arr1的值</span>      arr1[index--] = arr2[index2--]      <span class="hljs-keyword">continue</span>    &#125;    arr1[index--] = arr1[index1]&gt;=arr2[index2]?arr1[index1--]:arr2[index2--]  &#125;&#125;</code></pre></div></li></ul><ul><li>计算两个数组的交集  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">intersection</span>(<span class="hljs-params">arr1,arr2</span>)</span>&#123;  <span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Set</span>(arr1.filter(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>arr2.includes(item)))]&#125;</code></pre></div></li></ul><ul><li><p>计算多个数组的交集</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">intersection</span>(<span class="hljs-params">...arrs</span>)</span>&#123;  <span class="hljs-keyword">if</span>(arrs.length===<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> []  <span class="hljs-keyword">if</span>(arrs.length===<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> arrs[<span class="hljs-number">0</span>]  <span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Set</span>(arrs.reduce(<span class="hljs-function">(<span class="hljs-params">pre,next</span>)=&gt;</span>&#123;    <span class="hljs-comment">// reduce累加器，每一次的return作为下一次累加的pre，你咋这也能忘</span>    <span class="hljs-comment">// 后还能添加参数手动制定第一次累加的pre值</span>    <span class="hljs-keyword">return</span> pre.filter(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>next.includes(item))  &#125;))]&#125;</code></pre></div></li><li><p>实现一个fill函数</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// fill(3,4) =&gt; [4,4,4]</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFill</span>(<span class="hljs-params">num,size</span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">acc,size</span>)=&gt;</span>&#123;    <span class="hljs-keyword">if</span>(--size&gt;<span class="hljs-number">0</span>)&#123;      acc = acc.concat(num)    &#125;    <span class="hljs-keyword">return</span> acc  ,[]&#125;&#125;</code></pre></div></li></ul><ul><li><p>大数相加(可以输出字符串)</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bigAdd</span>(<span class="hljs-params">x, y</span>) </span>&#123;  <span class="hljs-keyword">if</span>(x===<span class="hljs-string">&#x27;0&#x27;</span>)<span class="hljs-keyword">return</span> y  <span class="hljs-keyword">if</span>(y===<span class="hljs-string">&#x27;0&#x27;</span>)<span class="hljs-keyword">return</span> x  <span class="hljs-keyword">let</span> num1;  <span class="hljs-keyword">let</span> num2;  <span class="hljs-keyword">let</span> curNum;  <span class="hljs-keyword">let</span> ix = x.length - <span class="hljs-number">1</span>;  <span class="hljs-keyword">let</span> iy = y.length - <span class="hljs-number">1</span>;  <span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> res = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// res是字符串</span>  <span class="hljs-keyword">while</span> (ix &gt;= <span class="hljs-number">0</span> || iy &gt;= <span class="hljs-number">0</span>) &#123;    num1 = x.charAt(ix--);    num2 = y.charAt(iy--);    curNum = <span class="hljs-built_in">Number</span>(num1) + <span class="hljs-built_in">Number</span>(num2) + carry    carry = <span class="hljs-number">0</span>    <span class="hljs-keyword">if</span>(curNum&gt;=<span class="hljs-number">10</span>)&#123;      carry = <span class="hljs-number">1</span>      curNum = curNum%<span class="hljs-number">10</span>    &#125;    res = curNum + res; <span class="hljs-comment">// 数字加上字符串，隐式转换为字符串拼接</span>  &#125;  <span class="hljs-keyword">return</span> carry ? carry + res : res&#125;</code></pre></div></li><li><p>大数相乘(可以输出字符串)</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bigMulti</span>(<span class="hljs-params">x,y</span>)</span>&#123;  <span class="hljs-keyword">if</span>(x===<span class="hljs-string">&#x27;0&#x27;</span> || y===<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>  <span class="hljs-keyword">if</span>(x===<span class="hljs-string">&#x27;1&#x27;</span>)<span class="hljs-keyword">return</span> y  <span class="hljs-keyword">if</span>(y===<span class="hljs-string">&#x27;1&#x27;</span>)<span class="hljs-keyword">return</span> x  <span class="hljs-keyword">const</span> len1 = x.length  <span class="hljs-keyword">const</span> len2 = y.length  <span class="hljs-keyword">const</span> pos = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len1+len2).fill(<span class="hljs-number">0</span>)  <span class="hljs-keyword">let</span> num1,num2,mulit,cur  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = len1 -<span class="hljs-number">1</span> ; i&gt;=<span class="hljs-number">0</span> ; i--)&#123;    num1 = x[i]    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = len2 - <span class="hljs-number">1</span> ; j &gt;= <span class="hljs-number">0</span> ;j --)&#123;      num2 = y[j]      mulit = num1*num2      cur = mulit + pos[i+j+<span class="hljs-number">1</span>]      pos[i+j+<span class="hljs-number">1</span>] = cur % <span class="hljs-number">10</span>      pos[i+j] += cur / <span class="hljs-number">10</span> | <span class="hljs-number">0</span> <span class="hljs-comment">// 取10位以上部分</span>    &#125;  &#125;  <span class="hljs-keyword">let</span> res = pos.join(<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-built_in">console</span>.log(res);  <span class="hljs-keyword">while</span>(res[<span class="hljs-number">0</span>]===<span class="hljs-string">&#x27;0&#x27;</span>)&#123;    res = res.substring(<span class="hljs-number">1</span>)  &#125;  <span class="hljs-keyword">return</span> res&#125;</code></pre></div></li><li><p>保留精度加法</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fixAdd = <span class="hljs-function">(<span class="hljs-params">x,y</span>)=&gt;</span>&#123;  <span class="hljs-keyword">const</span>  len1 = x.split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>].length  <span class="hljs-keyword">const</span>  len2 = y.split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>].length  <span class="hljs-keyword">const</span>  maxLen = len1&gt;=len2 ? len1 :len2  <span class="hljs-keyword">const</span> times = maxLen*<span class="hljs-number">10</span>  <span class="hljs-keyword">return</span> (x * times + y * times) / times;&#125;</code></pre></div></li><li><p>满9加1</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add1</span>(<span class="hljs-params">num</span>)</span>&#123;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> dig = num.length - <span class="hljs-number">1</span>;dig&gt;=<span class="hljs-number">0</span>;dig--)&#123;    <span class="hljs-keyword">if</span>(num[dig]===<span class="hljs-number">9</span>)&#123;      num[dig]=<span class="hljs-number">0</span>    &#125;<span class="hljs-keyword">else</span>&#123;      num[dig] ++      <span class="hljs-keyword">return</span> num    &#125;  &#125;  num.unshift(<span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> num&#125;</code></pre></div></li><li><p>将数组中的0全部移动到最后且非0部分保持原顺序</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move0</span>(<span class="hljs-params">num</span>)</span>&#123;  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>  <span class="hljs-keyword">while</span>(i&lt;num.length)&#123;    <span class="hljs-keyword">if</span>(num[i]!==<span class="hljs-number">0</span>)&#123;      [mim[i],num[j]] = [num[j],num[i]]      i++      j++    &#125;<span class="hljs-keyword">else</span>&#123;      i++    &#125;  &#125;&#125;</code></pre></div></li><li><p>数的次方（不使用内置库pow</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 如果指数n是偶数，x^n = x^(n/2) * x^(n/2)</span><span class="hljs-comment">// 如果指数n是奇数，x^n = x * x^(n/2) * x^(n/2)</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myPow</span>(<span class="hljs-params">x,n</span>)</span>&#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_pow</span>(<span class="hljs-params">base,ex</span>)</span>&#123;    <span class="hljs-keyword">if</span>(ex===<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    <span class="hljs-keyword">if</span>(ex===<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> base    <span class="hljs-keyword">const</span> splitPow = _pow(base,<span class="hljs-built_in">Math</span>.floor(ex/<span class="hljs-number">2</span>))    <span class="hljs-keyword">return</span> ex%<span class="hljs-number">2</span> ? base*splitPow*splitPow : splitPow*splitPow  &#125;  <span class="hljs-keyword">const</span> res = _pow(x,<span class="hljs-built_in">Math</span>.abs(n))  <span class="hljs-keyword">return</span> n&lt;<span class="hljs-number">0</span> ? <span class="hljs-number">1</span>/res : res &#125;</code></pre></div><ul><li>输出1到最大的n位数<div class="hljs code-wrapper"><pre><code class="hljs javascript">  <span class="hljs-comment">/**</span><span class="hljs-comment">  / <span class="hljs-doctag">@params </span>n=1 一位数，最大9，输出123456789</span><span class="hljs-comment">  / <span class="hljs-doctag">@params </span>n=2 两位数呀 最大99</span><span class="hljs-comment">  */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printNumbers1</span>(<span class="hljs-params">n</span>)</span>&#123;  <span class="hljs-comment">//组合字符串</span>  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)&#123;    str+=<span class="hljs-string">&#x27;9&#x27;</span>    n--  &#125;  str = <span class="hljs-built_in">Number</span>(str)  <span class="hljs-keyword">const</span> res = []  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;i&lt;=str;i++)&#123;    res.push(i)  &#125;  <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printNumbers1</span>(<span class="hljs-params">n</span>)</span>&#123;  <span class="hljs-comment">//最大值就是 10^n-1......</span>  <span class="hljs-keyword">const</span> max = <span class="hljs-number">10</span> ** n -<span class="hljs-number">1</span>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(max).fill(<span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> res.map(<span class="hljs-function">(<span class="hljs-params">v,i</span>)=&gt;</span>v+i)&#125;</code></pre></div></li></ul><ul><li><p>和为s的所有正数序列</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> *  15</span><span class="hljs-comment"> * [1,2,3,4,5] [4,5,6] [7,8]</span><span class="hljs-comment">*/</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findContinuousSequence</span>(<span class="hljs-params">target</span>)</span>&#123;  <span class="hljs-comment">// 直接用滑动窗口套</span>  <span class="hljs-keyword">let</span> l = <span class="hljs-number">1</span>  <span class="hljs-keyword">let</span> r = <span class="hljs-number">2</span>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">3</span>  <span class="hljs-keyword">const</span> res = []  <span class="hljs-keyword">while</span>(l&lt;r)&#123;    <span class="hljs-keyword">if</span>(sum===target)&#123;      <span class="hljs-keyword">const</span> ret = []      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = j;i&lt;=r;i++)&#123;        ret.push(i)      &#125;      sum-=l      l++    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target)&#123;      sum -= l      l++    &#125;<span class="hljs-keyword">else</span>&#123;      r++      sum+=r    &#125;  &#125;  <span class="hljs-keyword">return</span> res&#125;<span class="hljs-comment">// 滑动窗口的另外一种实现</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findContinuousSequence</span>(<span class="hljs-params">target</span>)</span>&#123;  <span class="hljs-keyword">const</span> max = target%<span class="hljs-number">2</span>===<span class="hljs-number">0</span>?target/<span class="hljs-number">2</span>:<span class="hljs-built_in">Math</span>.floor(target/<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>  <span class="hljs-comment">// max右边都不可能满足</span>  <span class="hljs-comment">// t = 9</span>  <span class="hljs-comment">// max = 1，2，3，4，5，6[x]，7[x]，8[x]</span>  <span class="hljs-keyword">const</span> <span class="hljs-built_in">window</span> = []  <span class="hljs-keyword">const</span> res = []  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;i &lt;= max ;i++)&#123;    <span class="hljs-built_in">window</span>.push(i)    sum += i    <span class="hljs-keyword">while</span>(sum &gt; target)&#123;      sum-=<span class="hljs-built_in">window</span>[<span class="hljs-number">0</span>]      <span class="hljs-built_in">window</span>.shift()    &#125;    <span class="hljs-keyword">if</span>(sum===target)&#123;      <span class="hljs-built_in">window</span>.length&gt;<span class="hljs-number">1</span> &amp;&amp; res.push([...window])      <span class="hljs-comment">// push window的浅拷贝</span>    &#125;  &#125;  <span class="hljs-keyword">return</span> res&#125;</code></pre></div></li><li><p>数组中出现次数超过数组长度一半的元素</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 一定会是排序后的数组中点</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">majorityElement</span>(<span class="hljs-params">nums</span>)</span>&#123;  nums = nums.sort()  <span class="hljs-keyword">return</span> nums[<span class="hljs-built_in">Math</span>.floor(nums.length/<span class="hljs-number">2</span>)]&#125;<span class="hljs-comment">// 投票记数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">majorityElement</span>(<span class="hljs-params">nums</span>)</span>&#123;  <span class="hljs-keyword">let</span> vote = <span class="hljs-number">0</span>  <span class="hljs-comment">// 前后元素相同投票加1，不同减1，票数抵消则计算后面的元素</span>  <span class="hljs-keyword">let</span> mid = nums[<span class="hljs-number">0</span>]  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums)&#123;    <span class="hljs-keyword">if</span>(vote===<span class="hljs-number">0</span>)&#123;      mid = num    &#125;    vote += num===mid ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>  &#125;  <span class="hljs-keyword">return</span> mid&#125;</code></pre></div></li><li><p>圆圈中最后剩下的数字</p></li></ul><p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 朴朴素素超时方法</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lastRemaining</span>(<span class="hljs-params">n,m</span>) </span>&#123;  <span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function">(<span class="hljs-params">v,i</span>)=&gt;</span>v+=i)  <span class="hljs-keyword">let</span> pos = <span class="hljs-number">0</span>  <span class="hljs-keyword">while</span>(arr&gt;<span class="hljs-number">1</span>)&#123;    pos = (pos+m-<span class="hljs-number">1</span>) % arr.length    arr.splice(pos,<span class="hljs-number">1</span>)  &#125;  <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>]&#125;<span class="hljs-comment">// 找规律</span><span class="hljs-comment">// 约瑟夫环</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lastRemaining</span>(<span class="hljs-params">n,m</span>)</span>&#123;  <span class="hljs-comment">// 只剩下一个数字时,这个最后剩下的数字索引为0</span>  <span class="hljs-comment">// 反推</span>  <span class="hljs-comment">// 剩下两个数字时，这个最后剩下的数字当前索引为(上一轮索引+m)%2</span>  <span class="hljs-comment">// 取%考虑索引溢出</span>  <span class="hljs-comment">// 剩下三个数字时，这个最后剩下的数字当前索引为(上一轮索引+m)%3</span>  <span class="hljs-comment">// 得到公式 </span>  <span class="hljs-comment">// n个数字 ，这个最后剩下的数字当前索引为(上一轮索引+m)%n</span>  <span class="hljs-comment">// 当前状态用f(n,m)表示，则上一轮为f(n-1,m)</span>  <span class="hljs-comment">// f(n,m) = (f(n-1,m)+m)%n</span>    <span class="hljs-keyword">if</span>(n===<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    <span class="hljs-keyword">return</span> (lastRemaining(n-<span class="hljs-number">1</span>,m)+m) % n&#125;<span class="hljs-comment">// 也可以使用迭代实现</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lastRemaining</span>(<span class="hljs-params">n,m</span>)</span>&#123;  <span class="hljs-keyword">let</span> pos = <span class="hljs-number">0</span> <span class="hljs-comment">// n为1时的 剩下0</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span> ; i &lt;= n ;i++)&#123;    <span class="hljs-comment">// 每一轮都根据规律修改</span>    pos = (pos+m) % i  &#125;  <span class="hljs-keyword">return</span> pos&#125;</code></pre></div><ul><li><p>将数组中的奇数移动到前，偶数移动到后</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">nums</span>)</span>&#123;  <span class="hljs-comment">// 对撞指针</span>  <span class="hljs-comment">// 分别寻找符合条件的数</span>  <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span> ,r = nums.length -<span class="hljs-number">1</span>  <span class="hljs-keyword">while</span>(l&lt;r)&#123;    <span class="hljs-keyword">while</span>(l&lt;r &amp;&amp; nums[l]%<span class="hljs-number">2</span>!==<span class="hljs-number">0</span>) l++    <span class="hljs-keyword">while</span>(l&lt;r &amp;&amp; nums[r]%<span class="hljs-number">2</span>===<span class="hljs-number">0</span>) r--    [nums[l],nums[r]] = [nums[r],nums[l]]  &#125;  <span class="hljs-keyword">return</span> nums&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">nums</span>)</span>&#123;  <span class="hljs-comment">// 快慢指针</span>  <span class="hljs-keyword">let</span> slow = <span class="hljs-number">0</span> ,fast = <span class="hljs-number">0</span>  <span class="hljs-keyword">while</span>(fast&lt;nums.length)&#123;    <span class="hljs-keyword">if</span>(nums[fast]%<span class="hljs-number">2</span>!==<span class="hljs-number">0</span>)&#123;      [nums[slow],nums[fast]] = [num[fast],nums[slow]]      slow++    &#125;    fast++  &#125;  <span class="hljs-keyword">return</span> nums&#125;</code></pre></div></li><li><p>实现前缀树prefixTree</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PrefixTree</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.tree = &#123;&#125;&#125;PrefixTree.prototype.insert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">word</span>)</span>&#123;  <span class="hljs-comment">// 依次将单词的每个字母向tree对象中递归添加属性</span>  <span class="hljs-comment">// msy= &gt;</span>  <span class="hljs-comment">// &#123;m:&#123;s:&#123;y:&#123;isEnd:true&#125;&#125;&#125;&#125;</span>  <span class="hljs-keyword">let</span> node = <span class="hljs-built_in">this</span>.tree  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> word)&#123;    <span class="hljs-keyword">if</span>(!node[n]) node[n] = &#123;&#125;    node = node[n]  &#125;  node.isEnd = <span class="hljs-literal">true</span>&#125;PrefixTree.prototype.loop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">word</span>)</span>&#123;  <span class="hljs-keyword">let</span> node = <span class="hljs-built_in">this</span>.tree  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> word)&#123;    <span class="hljs-keyword">if</span>(!node[n]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    node = node[n]  &#125;  <span class="hljs-keyword">return</span> node&#125;PrefixTree.prototype.search = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">word</span>)</span>&#123;  <span class="hljs-keyword">const</span> ret = <span class="hljs-built_in">this</span>.loop(word)  <span class="hljs-keyword">return</span> ret!==<span class="hljs-literal">undefined</span> &amp;&amp; ret.isEnd === <span class="hljs-literal">true</span>&#125;PrefixTree.prototype.startWith = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prefix</span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.loop(prefix)&#125;</code></pre></div></li><li><p>青蛙跳台阶</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">numWays</span>(<span class="hljs-params">n</span>)</span>&#123;  <span class="hljs-keyword">if</span>(n===<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>  <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>  <span class="hljs-comment">// 两个台阶时</span>  <span class="hljs-keyword">let</span> cur = <span class="hljs-number">2</span>  <span class="hljs-comment">// 两种跳法</span>  <span class="hljs-keyword">let</span> pre = <span class="hljs-number">1</span>  <span class="hljs-comment">// 少一个台阶的跳法</span>  <span class="hljs-keyword">while</span>(i++ &lt; n)&#123;    <span class="hljs-comment">// 从n=3时迭代推导</span>    res = cur + pre    pre = cur    cur = res  &#125;  <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">numWays</span>(<span class="hljs-params">n</span>)</span>&#123;  <span class="hljs-comment">// 斐波那契数列</span>  <span class="hljs-keyword">const</span> arr = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span> ;i &lt;= n ;i++)&#123;    arr[i] = arr[i-<span class="hljs-number">1</span>] + arr[i-<span class="hljs-number">2</span>]  &#125;  <span class="hljs-keyword">return</span> arr[i]&#125;</code></pre></div><ul><li><p>连续子数组的和的最大值</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxSubArray</span>(<span class="hljs-params">nums</span>)</span>&#123;  <span class="hljs-comment">// 用dp记录该位置作为子数组末尾的累加值</span>  <span class="hljs-comment">// [nums[0],nums[1]],dp[1] = num[0] + num[1]</span>  <span class="hljs-comment">// dp[2] = dp[1] + nums[2]</span>  <span class="hljs-comment">// 同时判断前一dp的值正负</span>  <span class="hljs-comment">// 前一个dp为正则 当前dp = 前dp + 当前nums</span>  <span class="hljs-comment">// 如果为负直接丢弃</span>  <span class="hljs-keyword">if</span>(nums.length&lt;<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]  <span class="hljs-keyword">let</span> max = nums[<span class="hljs-number">0</span>]  <span class="hljs-keyword">let</span> dpi = nums[<span class="hljs-number">0</span>]  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span> ; i &lt; nums.length ;i++)&#123;    dpi = dpi &gt; <span class="hljs-number">0</span> ? dpi + nums[i] : nums[i]    max = <span class="hljs-built_in">Math</span>.max(max,dpi)  &#125;  <span class="hljs-keyword">return</span> max&#125;</code></pre></div></li><li><p>反转嵌套数组</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 已知数组 a=[1,[2,[3,[4,null]]]], 实现数组 b=[4,[3,[2,[1,null]]]] ，考虑n级嵌套的情况</span><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-literal">null</span>]]]];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseArray</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">arr,temp</span>)</span>&#123;    <span class="hljs-comment">// arr = [1,[2,[3,[4,null]]]]</span>    <span class="hljs-comment">// arr = [1,[2,[3,[4,null]]]][1] = [2,[3,[4,null]]]</span>    <span class="hljs-comment">// arr = [1,[2,[3,[4,null]]]][1][1] = [3,[4,null]]</span>    <span class="hljs-comment">// arr = [1,[2,[3,[4,null]]]][1][1][1] = [4,null]</span>    <span class="hljs-keyword">if</span>(arr[<span class="hljs-number">1</span>]===<span class="hljs-literal">null</span>)&#123;      <span class="hljs-keyword">return</span> [arr[<span class="hljs-number">0</span>],temp]      <span class="hljs-comment">// return </span>    &#125;    temp = temp ? [arr[<span class="hljs-number">0</span>],temp] : [arr[<span class="hljs-number">0</span>],<span class="hljs-literal">null</span>]<span class="hljs-comment">// temp = [1,null]</span><span class="hljs-comment">// temp = [2,[1,null]]</span><span class="hljs-comment">// temp = [3,[2,[1,null]]]</span>    <span class="hljs-keyword">return</span> reverse(arr[<span class="hljs-number">1</span>],temp) <span class="hljs-comment">// 递归进嵌套</span>  &#125;  <span class="hljs-keyword">return</span> reverse(arr,<span class="hljs-literal">null</span>)&#125;<span class="hljs-built_in">console</span>.log(reverseArray(a));</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象题</title>
    <link href="/2020/04/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%A2%98/"/>
    <url>/2020/04/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ul><li>打车时可以打专车或快车。任何车都有车牌号和名称。快车每公里1元，专车每公里2元。行程开始时，显示车辆信息。行程结束时，显示打车金额。行程距离为5公里。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">licence,name</span>)</span>&#123;    <span class="hljs-built_in">this</span>.licence = licence    <span class="hljs-built_in">this</span>.name = name  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastCar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Car</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">licence,name</span>)</span>&#123;    <span class="hljs-built_in">super</span>(licence,name)    <span class="hljs-built_in">this</span>.price =<span class="hljs-number">1</span>  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrivateCar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Car</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">licence,name</span>)</span>&#123;    <span class="hljs-built_in">super</span>(licence,name)    <span class="hljs-built_in">this</span>.price = <span class="hljs-number">2</span>  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">car,distance</span>)</span>&#123;    <span class="hljs-built_in">this</span>.car = car    <span class="hljs-built_in">this</span>.distance = distance  &#125;  <span class="hljs-function"><span class="hljs-title">getIn</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.car.name);    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.car.licence);  &#125;  <span class="hljs-function"><span class="hljs-title">getOff</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.car.price*<span class="hljs-built_in">this</span>.distance);  &#125;&#125;<span class="hljs-keyword">let</span> car1 = <span class="hljs-keyword">new</span> PrivateCar(<span class="hljs-string">&#x27;粤A8888888&#x27;</span>,<span class="hljs-string">&#x27;特斯拉&#x27;</span>)<span class="hljs-keyword">let</span> cost1 = <span class="hljs-keyword">new</span> Order(car1,<span class="hljs-number">5</span>).getOff()</code></pre></div><ul><li>某停车场, 分三层, 每层100 车位,每个车位都能监控到车辆的进入和离开,车辆进入前,显示每层的空余车位数量,车辆进入时,摄像头可识别车牌号和进入时间,车辆出来时,出口显示屏显示车牌号和停车时长</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">licence</span>)</span>&#123;    <span class="hljs-built_in">this</span>.licence = licence  &#125;&#125;<span class="hljs-comment">// 整个停车场</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkingLot</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">floors</span>)</span>&#123;    <span class="hljs-comment">// floors:[[300],[300],[300]]</span>    <span class="hljs-built_in">this</span>.floors = floors    <span class="hljs-built_in">this</span>.dataBase = []  &#125;  <span class="hljs-function"><span class="hljs-title">showSpace</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">this</span>.floors.length;i++)&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`第<span class="hljs-subst">$&#123;i+<span class="hljs-number">1</span>&#125;</span>层空闲车位(<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.floors[i].emptySpace()&#125;</span>)`</span>)    &#125;  &#125;  <span class="hljs-function"><span class="hljs-title">intoLot</span>(<span class="hljs-params">car,floorIndex,lotIndex</span>)</span>&#123;    <span class="hljs-comment">//车牌，时间</span>    <span class="hljs-keyword">let</span> licence = car.licence    <span class="hljs-keyword">let</span> intoTime = <span class="hljs-built_in">Date</span>.now()    <span class="hljs-keyword">let</span> space = <span class="hljs-built_in">this</span>.floors[floorIndex].lot[lotIndex]    <span class="hljs-built_in">this</span>.dataBase[licence] = &#123;intoTime,floorIndex,lotIndex&#125;    space.checkIn()  &#125;  <span class="hljs-function"><span class="hljs-title">outLot</span>(<span class="hljs-params">car</span>)</span>&#123;    <span class="hljs-keyword">let</span> outTime = <span class="hljs-built_in">Date</span>.now()    <span class="hljs-keyword">let</span> licence = car.licence    <span class="hljs-keyword">let</span> info = <span class="hljs-built_in">this</span>.dataBase[licence]    <span class="hljs-keyword">let</span> space = <span class="hljs-built_in">this</span>.floors[info.floorIndex].lot[info.lotIndex]    <span class="hljs-keyword">let</span> timeCount = <span class="hljs-built_in">parseInt</span>((outTime-info.intoTime)/<span class="hljs-number">36000000</span>)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`停车时长<span class="hljs-subst">$&#123;timeCount&#125;</span>小时`</span>)    space.checkOut()  &#125;&#125;<span class="hljs-comment">// 车位,监视驶入离开</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkingSpace</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">this</span>.free = <span class="hljs-literal">true</span>  &#125;  <span class="hljs-function"><span class="hljs-title">checkIn</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">this</span>.free = <span class="hljs-literal">false</span>  &#125;  <span class="hljs-function"><span class="hljs-title">checkOut</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">this</span>.free = <span class="hljs-literal">true</span>  &#125;&#125;<span class="hljs-comment">// 层</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkingFloor</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">floor,lot</span>)</span>&#123;    <span class="hljs-built_in">this</span>.floor = floor    <span class="hljs-built_in">this</span>.lot = lot  &#125;  <span class="hljs-function"><span class="hljs-title">emptySpace</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">//返回空闲车位</span>    <span class="hljs-keyword">let</span> freeLot = <span class="hljs-number">0</span>    <span class="hljs-built_in">this</span>.lot.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;      <span class="hljs-keyword">if</span>(item.free)&#123;        freeLot++      &#125;    &#125;);    <span class="hljs-keyword">return</span> freeLot  &#125;&#125;</code></pre></div><ul><li>一副扑克牌有54张牌，其中52张是正牌，另2张是副牌（大王和小王）。<br>52张正牌又均分为13张一组，并以黑桃、红桃、草花、方块四种花色表示各组，每组花色的牌包括从1-10（1通常表示为A）以及J、Q、K标示的13张牌。<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;J&#x27;</span>,<span class="hljs-string">&#x27;Q&#x27;</span>,<span class="hljs-string">&#x27;K&#x27;</span>]<span class="hljs-keyword">const</span> signs = [<span class="hljs-string">&#x27;♥️&#x27;</span>, <span class="hljs-string">&#x27;♦️&#x27;</span>, <span class="hljs-string">&#x27;♣️&#x27;</span>, <span class="hljs-string">&#x27;♠️&#x27;</span>]<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Poker</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">signs,numbers</span>)</span> &#123;<span class="hljs-built_in">this</span>.signs = signs<span class="hljs-built_in">this</span>.numbers = numbers<span class="hljs-built_in">this</span>.mounts = <span class="hljs-number">52</span><span class="hljs-built_in">this</span>.pokers = []&#125;<span class="hljs-function"><span class="hljs-title">initPokers</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">this</span>.signs.length;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">this</span>.numbers.length;j++)&#123;<span class="hljs-built_in">this</span>.pokers.push(<span class="hljs-keyword">new</span> Card(<span class="hljs-built_in">this</span>.signs[i],<span class="hljs-built_in">this</span>.numbers[j]))&#125;&#125;<span class="hljs-built_in">this</span>.pokers.push(<span class="hljs-keyword">new</span> Card(<span class="hljs-string">&#x27;BLACK&#x27;</span>,<span class="hljs-string">&#x27;GHOST&#x27;</span>))<span class="hljs-built_in">this</span>.pokers.push(<span class="hljs-keyword">new</span> Card(<span class="hljs-string">&#x27;RED&#x27;</span>,<span class="hljs-string">&#x27;GHOST&#x27;</span>))&#125;  <span class="hljs-function"><span class="hljs-title">shuffleCard</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-comment">// let arr = this.pokers</span><span class="hljs-comment">// let len = arr.length</span>    <span class="hljs-comment">// let temp,i</span>    <span class="hljs-comment">// while(len)&#123;</span>    <span class="hljs-comment">//   i = Math.floor(Math.random()*len--)</span>    <span class="hljs-comment">//   temp = arr[i]</span>    <span class="hljs-comment">//   arr[i] = arr[len]</span>    <span class="hljs-comment">//   arr[len] = temp</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-comment">// this.pokers = arr</span>    <span class="hljs-built_in">this</span>.pokers = <span class="hljs-built_in">this</span>.pokers.sort(<span class="hljs-function">()=&gt;</span><span class="hljs-built_in">Math</span>.random()-<span class="hljs-number">0.5</span>)  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Card</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">sign, number</span>)</span> &#123;    <span class="hljs-built_in">this</span>.sign = sign;    <span class="hljs-built_in">this</span>.number = number;  &#125;&#125;<span class="hljs-keyword">let</span> game1 = <span class="hljs-keyword">new</span> Poker(signs,numbers)game1.initPokers()game1.shuffleCard()<span class="hljs-built_in">console</span>.log(game1.pokers);game1.shuffleCard()<span class="hljs-built_in">console</span>.log(game1.pokers);</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原生js</title>
    <link href="/2020/03/27/%E5%8E%9F%E7%94%9Fjs/"/>
    <url>/2020/03/27/%E5%8E%9F%E7%94%9Fjs/</url>
    
    <content type="html"><![CDATA[<ul><li><p>javascript</p><p>js 是一门函数优先的轻量级解释型语言，基于原型编程的动态脚本语言</p><ol><li>函数是一等公民（变量提升，函数可以作为函数的参数，返回值，可以赋值给变量，【函数式编程的条件】</li><li>面向对象编程</li><li>弱类型语言（变量的类型在运行时会变化，强类型语言的变量类型编译时就确定且不会改变</li><li>基于原型（区别于基于类[类和实例]，js 中万物皆为[对象]<blockquote><p>基于原型的语言具有所谓原型对象（prototypical object）的概念。原型对象可以作为一个模板，新对象可以从中获得原始的属性。任何对象都可以指定其自身的属性，任何对象都可以作为另一个对象的原型（prototype），从而允许后者共享前者的属性。</p></blockquote></li></ol></li><li><p>BOM 浏览器的编程接口</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">navigator浏览器信息location浏览器定位和导航history窗口浏览器历史screen 屏幕</code></pre></div><ul><li>DOM 文档的编程接口</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.getElementById(id);<span class="hljs-built_in">document</span>.getElementsByTagName(name);<span class="hljs-built_in">document</span>.createElement(name);parentNode.appendChild(node);element.innerHTML;<span class="hljs-comment">//innerHTML 从对象起始位置到终止位置的全部内容（包括html标签</span><span class="hljs-comment">//outerHTML 包括对象自身标签</span><span class="hljs-comment">//innerText innerHTML但不包括html标签，</span><span class="hljs-comment">//textContent 所有文本内容，包括script和style标签内</span>element.style.left;element.setAttribute();element.getAttribute();element.addEventListener();<span class="hljs-built_in">window</span>.content;<span class="hljs-built_in">window</span>.onload;<span class="hljs-built_in">window</span>.dump();<span class="hljs-built_in">window</span>.scrollTo();</code></pre></div><ul><li><p>面向对象与面向过程</p><ul><li><p>分析出解决问题的步骤，用函数分别实现各步骤</p></li><li><p>把构成问题的事物抽象分解成各个对象，用对象来描述某个事物在整个解决问题过程中的行为</p></li><li><p>面向对象三要素</p><ol><li>封装 -&gt; 利用抽象数据类型将数据和基于数据的操作封装在一起只留下接口给外部访问</li><li>继承 -&gt; 子类自动共享父类数据结构和方法</li><li>多态 -&gt; 相同的操作或函数可作用于多种类型的对象上并获得不同的结果</li></ol></li></ul></li></ul><ul><li><p>作用域/作用域链/闭包</p><ul><li>作用域：js 中的作用域是函数级的，变量在它声明的函数体以及函数体内嵌套的任意函数体内有定义</li><li>作用域链：js 执行时创建的执行上下文含有外部词法环境的引用，可以通过这个引用获取外部词法环境的变量、声明等，这些引用串联起来一直指向全局的词法环境，形成了作用域链。</li><li>闭包：函数体和其词法环境共同组成闭包。</li><li>JavaScript 中，函数在每次创建时生成闭包</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(i);  &#125;, <span class="hljs-number">1000</span> * i);&#125;</code></pre></div></li><li><p>map/flatMap/reduce</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// reduce的骚操作</span><span class="hljs-comment">// 对对象内的数据求和</span><span class="hljs-keyword">let</span> data = [  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;mmm&quot;</span>, <span class="hljs-attr">money</span>: <span class="hljs-number">120</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;mmm&quot;</span>, <span class="hljs-attr">money</span>: <span class="hljs-number">120</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;mmm&quot;</span>, <span class="hljs-attr">money</span>: <span class="hljs-number">120</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;mmm&quot;</span>, <span class="hljs-attr">money</span>: <span class="hljs-number">120</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;mmm&quot;</span>, <span class="hljs-attr">money</span>: <span class="hljs-number">120</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;mmm&quot;</span>, <span class="hljs-attr">money</span>: <span class="hljs-number">120</span> &#125;,];<span class="hljs-keyword">const</span> sumMoney = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> data.reduce(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> a + y.money, <span class="hljs-number">0</span>);&#125;;<span class="hljs-comment">//720</span><span class="hljs-comment">// 计算出现次数</span><span class="hljs-keyword">const</span> showCount = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> data.reduce(<span class="hljs-function">(<span class="hljs-params">showList, item</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (item <span class="hljs-keyword">in</span> showList) &#123;      showList[item]++;    &#125; <span class="hljs-keyword">else</span> &#123;      showList[item] = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> showList;  &#125;, &#123;&#125;);&#125;;<span class="hljs-comment">// orderBy按属性分类</span><span class="hljs-keyword">const</span> orderBy = <span class="hljs-function">(<span class="hljs-params">data, prop</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> data.reduce(<span class="hljs-function">(<span class="hljs-params">list, item</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> key = item[prop];    <span class="hljs-keyword">if</span> (!list[key]) &#123;      list[ket] = [];    &#125;    list[key].push(item);    <span class="hljs-keyword">return</span> list;  &#125;, &#123;&#125;);&#125;;<span class="hljs-comment">// 对象中取出特定数据输出新数组</span><span class="hljs-keyword">const</span> newArr = <span class="hljs-function">(<span class="hljs-params">data, prop</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> data.reduce(<span class="hljs-function">(<span class="hljs-params">arr, item</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> [...arr, ...item[prop]];  &#125;, []);&#125;;<span class="hljs-comment">// 数组去重</span><span class="hljs-keyword">const</span> reduceSet = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> arr.sort().reduce(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (!acc.length || acc[acc.length - <span class="hljs-number">1</span>] !== cur) &#123;      acc.push(cur);    &#125;    <span class="hljs-keyword">return</span> acc;  &#125;, []);&#125;;</code></pre></div></li><li><p>window</p><ul><li><code>window.ready</code>样式应用到了 DOM 上</li><li><code>window.load</code>加载完所有资源（图片</li></ul></li><li><p>进制转换</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 十进制转换为其他进制</span><span class="hljs-built_in">Number</span>(val).toString(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>);<span class="hljs-comment">// 其他进制转十进制</span><span class="hljs-built_in">parseInt</span>(val, radix);</code></pre></div><ul><li><p>严格模式<code>use strick</code></p><ul><li>严格模式通过抛出错误来消除了一些原有静默错误和编码错误。</li><li>严格模式修复了一些导致 JavaScript 引擎难以执行优化的缺陷，提高代码运行效率。</li><li>严格模式禁用了在 ECMAScript 的未来版本中可能会定义的一些关键字</li><li>无法再意外创建全局变量，全局作用域下，this 的值为 undefined。</li><li>要求函数的参数名唯一</li><li>eval()函数有自己的作用域</li></ul></li><li><p>操作字符串</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">charAt(); <span class="hljs-comment">//返回索引位置字符</span>concat(); <span class="hljs-comment">//拼接</span>indexOf(), lastIndexOf(); <span class="hljs-comment">//返回出现的索引位置</span>includes();match(); <span class="hljs-comment">//匹配正则</span>replace();split(); <span class="hljs-comment">//以xx分割字符串</span>slice(); <span class="hljs-comment">//截取返回新字符串，以索引</span>substring(); <span class="hljs-comment">//截取返回新字符串，以长度</span>trim(); <span class="hljs-comment">//删除空格</span>toLowerCase(), toUpperCase();</code></pre></div><ul><li><p>操作数组</p><ul><li>不改变原数组</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">filter();slice();concat();join(); <span class="hljs-comment">//返回字符串</span>includes();indexOf(), lastIndexOf();reduce();forEach();reduce();map();find(); <span class="hljs-comment">//返回符合条件的</span>every(); <span class="hljs-comment">//全都符合条件？</span>some(); <span class="hljs-comment">//有符合条件的</span></code></pre></div><ul><li>改变原数组</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">push();pop();shift();unshift();sort(); <span class="hljs-comment">//排序</span>reverse(); <span class="hljs-comment">//倒序</span>splice(); <span class="hljs-comment">// 删除</span>flat();</code></pre></div></li><li><p>洗牌</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shuffle</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">let</span> len = arr.length  <span class="hljs-keyword">while</span> (len) &#123;    <span class="hljs-keyword">const</span> i = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * len--);    [arr[i],arr[len]] = [arr[len],arr[i]]  &#125;  <span class="hljs-keyword">return</span> arr;&#125;</code></pre></div><ul><li>实现 EventEmitter</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 请实现下面的自定义事件 Event 对象的接口，功能见注释(测试1)</span><span class="hljs-comment">// 该 Event 对象的接口需要能被其他对象拓展复用(测试2)</span><span class="hljs-comment">// 测试1</span>Event.on(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(result);&#125;);Event.on(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;test&quot;</span>);&#125;);Event.emit(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;hello world&quot;</span>); <span class="hljs-comment">// 输出 &#x27;hello world&#x27; 和 &#x27;test&#x27;</span><span class="hljs-comment">// 测试2</span><span class="hljs-keyword">var</span> person1 = &#123;&#125;;<span class="hljs-keyword">var</span> person2 = &#123;&#125;;<span class="hljs-built_in">Object</span>.assign(person1, Event);<span class="hljs-built_in">Object</span>.assign(person2, Event);person1.on(<span class="hljs-string">&quot;call1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;person1&quot;</span>);&#125;);person2.on(<span class="hljs-string">&quot;call2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;person2&quot;</span>);&#125;);person1.emit(<span class="hljs-string">&quot;call1&quot;</span>); <span class="hljs-comment">// 输出 &#x27;person1&#x27;</span>person1.emit(<span class="hljs-string">&quot;call2&quot;</span>); <span class="hljs-comment">// 没有输出</span>person2.emit(<span class="hljs-string">&quot;call1&quot;</span>); <span class="hljs-comment">// 没有输出</span>person2.emit(<span class="hljs-string">&quot;call2&quot;</span>); <span class="hljs-comment">// 输出 &#x27;person2&#x27;</span><span class="hljs-keyword">var</span> Event = &#123;  <span class="hljs-comment">// 通过on接口监听事件eventName</span>  <span class="hljs-comment">// 如果事件eventName被触发，则执行callback回调函数</span>  on: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">eventName, callback</span>) </span>&#123;    <span class="hljs-comment">//你的代码</span>  &#125;,  <span class="hljs-comment">// 触发事件 eventName</span>  emit: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">eventName</span>) </span>&#123;    <span class="hljs-comment">//你的代码</span>  &#125;,&#125;;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Event =&#123;  on:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name,cb</span>)</span>&#123;    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.handlers)&#123;      <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">this</span>,<span class="hljs-string">&#x27;handlers&#x27;</span>,&#123;        value:&#123;&#125;,        enumerable:<span class="hljs-literal">false</span>,        configurable:<span class="hljs-literal">true</span>,        writable:<span class="hljs-literal">true</span>      &#125;)    &#125;    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.handlers[name])&#123;      <span class="hljs-built_in">this</span>.handlers[name] = []    &#125;    <span class="hljs-built_in">this</span>.handles[name].push(cb)  &#125;,  emit:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name,...args</span>)</span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.handlers[name])&#123;      <span class="hljs-built_in">this</span>.handlers[name].forEach(<span class="hljs-function"><span class="hljs-params">cb</span>=&gt;</span>&#123;        cb(...args)      &#125;)    &#125;  &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Events</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">this</span>.events = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()  &#125;  <span class="hljs-function"><span class="hljs-title">addEvent</span>(<span class="hljs-params">key,fn,isOnce,...args</span>)</span>&#123;    <span class="hljs-keyword">const</span> curEvent = <span class="hljs-built_in">this</span>.events.get(key) ? <span class="hljs-built_in">this</span>.events.get(key) : <span class="hljs-built_in">this</span>.events.set(key,<span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()).get(key)    curEvent.set(fn,<span class="hljs-function">(<span class="hljs-params">...args2</span>)=&gt;</span>&#123;      fn(...args,...args2)      <span class="hljs-keyword">if</span>(isOnce)<span class="hljs-built_in">this</span>.off(key,fn)    &#125;)  &#125;  <span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">key, fn, ...args</span>)</span> &#123;    <span class="hljs-built_in">this</span>.addEvent(key, fn, <span class="hljs-literal">false</span>, ...args)  &#125;  <span class="hljs-function"><span class="hljs-title">once</span>(<span class="hljs-params">key,fn,...args</span>)</span>&#123;    <span class="hljs-built_in">this</span>.addEvent(key,fn,<span class="hljs-literal">true</span>,...args)  &#125;  <span class="hljs-function"><span class="hljs-title">off</span>(<span class="hljs-params">key,fn</span>)</span>&#123;    <span class="hljs-built_in">this</span>.events.get(key).delete(fn)  &#125;  <span class="hljs-function"><span class="hljs-title">fire</span>(<span class="hljs-params">key,...args</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.events.get(key));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> cb <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>.events.get(key).values())&#123;      cb(...args)    &#125;  &#125;&#125;<span class="hljs-comment">// 请使用原生代码实现一个Events模块，可以实现自定义事件的订阅、触发、移除功能</span><span class="hljs-keyword">const</span> fn1 = <span class="hljs-function">(<span class="hljs-params">... args</span>)=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;I want sleep1&#x27;</span>, ... args)<span class="hljs-keyword">const</span> fn2 = <span class="hljs-function">(<span class="hljs-params">... args</span>)=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;I want sleep2&#x27;</span>, ... args)<span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> Events();event.on(<span class="hljs-string">&#x27;sleep&#x27;</span>, fn1, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);event.on(<span class="hljs-string">&#x27;sleep&#x27;</span>, fn2, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);event.fire(<span class="hljs-string">&#x27;sleep&#x27;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<span class="hljs-comment">// I want sleep1 1 2 3 4 5 6</span><span class="hljs-comment">// I want sleep2 1 2 3 4 5 6</span>event.off(<span class="hljs-string">&#x27;sleep&#x27;</span>, fn1);event.once(<span class="hljs-string">&#x27;sleep&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;I want sleep&#x27;</span>));event.fire(<span class="hljs-string">&#x27;sleep&#x27;</span>);<span class="hljs-comment">// I want sleep2 1 2 3</span><span class="hljs-comment">// I want sleep</span>event.fire(<span class="hljs-string">&#x27;sleep&#x27;</span>);<span class="hljs-comment">// I want sleep2 1 2 3</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS面试题</title>
    <link href="/2020/03/24/css%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2020/03/24/css%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS3-新特性"><a href="#CSS3-新特性" class="headerlink" title="CSS3 新特性"></a>CSS3 新特性</h2><ul><li>边框属性<code>border-radius</code>，<code>box-shadow</code>，<code>border-image</code></li><li>背景控制<code>background-size,background-origin</code></li><li>文字效果和自动换行<code>text-shadow,word-wrap</code></li><li>自定义字体<code>@font-face</code></li><li>2d/3d 变换，过渡和动画<code>transition``animation</code></li><li>多栏布局column</li><li>盒模型属性<code>box-sizing</code></li><li>弹性盒子<code>flex</code></li><li>更强大的多媒体查询<h2 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h2></li><li>IE<ul><li>双边距 <ul><li><code>display:inline</code></li></ul></li><li>默认高度<code>16px</code><ul><li><code>font-size:0</code></li><li><code>overflow:hidden</code></li></ul></li><li>超链接内img会有边框<ul><li><code>border:0</code> </li></ul></li></ul></li></ul><ul><li>3px bug<ul><li><code>display:block</code></li><li><code>vertical-align:top</code></li></ul></li></ul><h2 id="position-跟-display、margin-collapse、overflow、float-这些特性相互叠加后会怎样"><a href="#position-跟-display、margin-collapse、overflow、float-这些特性相互叠加后会怎样" class="headerlink" title="position 跟 display、margin collapse、overflow、float 这些特性相互叠加后会怎样"></a>position 跟 display、margin collapse、overflow、float 这些特性相互叠加后会怎样</h2><ul><li>如果元素的 display 为 none，那么元素不被渲染，position，float 不起作用；</li><li>如果元素拥有 position:absolute;或 position:fixed;属性，那么元素将为绝对定位，float 不起作用。</li><li>如果元素 float 属性不是 none，元素会脱离文档流，根据 float 属性值来显示。</li><li>有浮动、绝对定位，inline-block 属性的元素，margin 不会和垂直方向上的其他元素 margin 折叠。</li></ul><h2 id="画三角形"><a href="#画三角形" class="headerlink" title="画三角形"></a>画三角形</h2><ul><li>不同边border之间45度拼接<div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-tag">div</span>&#123;  <span class="hljs-attribute">width</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">border-top</span>:<span class="hljs-number">50px</span> red solid;  <span class="hljs-attribute">border-left</span>:<span class="hljs-number">50px</span> $(背景色) solid;  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> $(背景色) solid;&#125;</code></pre></div></li></ul><h2 id="画椭圆"><a href="#画椭圆" class="headerlink" title="画椭圆"></a>画椭圆</h2><p><code>border-radius属性</code></p><ul><li>boder-radius 是简写属性<ul><li>border-top-left-radius</li><li>border-top-right-radius</li><li>border-bottom-right-radius</li><li>border-botom-left-radius</li><li>top 左右，bottom 右左，顺时针</li><li>/ 用来分隔水平方向和垂直方向<div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-comment">/* 绘制半椭圆 */</span><span class="hljs-selector-tag">div</span>&#123; <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">border-style</span>: solid; <span class="hljs-attribute">border-color</span>: <span class="hljs-number">#f00</span>; <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>/<span class="hljs-number">100%</span> <span class="hljs-number">100%</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>； /* 水平方向上四个角的半径都为<span class="hljs-number">50%</span> /  垂直方向 左右上半径为<span class="hljs-number">100%</span>，左右下为<span class="hljs-number">0</span>*/&#125;</code></pre></div></li></ul></li></ul><h2 id="文本溢出"><a href="#文本溢出" class="headerlink" title="文本溢出"></a>文本溢出</h2><ul><li><p>单行文本居中，多行文本左对齐</p><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-tag">div</span>&#123;  <span class="hljs-attribute">text-align</span>:center&#125;<span class="hljs-selector-tag">p</span>&#123;  <span class="hljs-attribute">display</span>:inline-block;  <span class="hljs-attribute">text-align</span><span class="hljs-selector-pseudo">:left</span>&#125;</code></pre></div></li><li><p>多行文本省略号</p><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-tag">p</span>:after&#123;  content:<span class="hljs-string">&#x27;...&#x27;</span>&#125;</code></pre></div></li><li><p>单行文本溢出省略</p><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-attribute">overflow</span>: hidden；/* （文字长度超出限定宽度，则隐藏超出的内容） */white-space: nowrap；/* （设置文字在一行显示，不能换行） */text-overflow: ellipsis；/* （规定当文本溢出时，显示省略符号来代表被修剪的文本） */</code></pre></div></li><li><p>多行文本溢出</p><div class="hljs code-wrapper"><pre><code class="hljs CSS">-webkit-line-clamp: <span class="hljs-number">2</span>；/* （用来限制在一个块元素显示的文本的行数，<span class="hljs-number">2</span> 表示最多显示 <span class="hljs-number">2</span> 行。为了实现该效果，它需要组合其他的 WebKit 属性） */display: -webkit-box；/* （和 <span class="hljs-number">1</span> 结合使用，将对象作为弹性伸缩盒子模型显示 ） */-webkit-box-orient: vertical；/* （和 <span class="hljs-number">1</span> 结合使用 ，设置或检索伸缩盒对象的子元素的排列方式 ） */overflow: hidden；/* （文本溢出限定的宽度就隐藏内容） */text-overflow: ellipsis；/* （多行文本的情况下，用省略号 “…” 隐藏溢出范围的文本) */</code></pre></div></li></ul><h2 id="dpr-1px边框"><a href="#dpr-1px边框" class="headerlink" title="dpr 1px边框"></a>dpr 1px边框</h2><ul><li><code>@media</code>配合<code>transform:scale()</code></li><li>查询设备dpr等比缩放px大小<div class="hljs code-wrapper"><pre><code class="hljs CSS">.<span class="hljs-number">1px</span>_border:before&#123;  content:<span class="hljs-string">&#x27;&#x27;</span>;  <span class="hljs-attribute">position</span>:absolute;  <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">1px</span>;  <span class="hljs-attribute">background-color</span>:<span class="hljs-number">#000</span>;  <span class="hljs-attribute">transform-origin</span>:<span class="hljs-number">50%</span>,<span class="hljs-number">0</span>&#125;<span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio</span>: <span class="hljs-number">2</span>) &#123;  .<span class="hljs-number">1px</span>_border:before &#123;    transform: scaleY (<span class="hljs-number">0.5</span>);  &#125;<span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio</span>: <span class="hljs-number">3</span>) &#123;  .<span class="hljs-number">1px</span>_border:before &#123;    transform: scaleY (<span class="hljs-number">0.33</span>);  &#125;&#125;</code></pre></div></li></ul><h2 id="垂直居中div"><a href="#垂直居中div" class="headerlink" title="垂直居中div"></a>垂直居中div</h2><ul><li>绝对定位+上下左右0+margin 0</li><li>绝对定位+负margin</li><li>绝对定位+负translate</li><li>flex+justify-content+align-items</li><li>table-cell+vertical-align</li><li>table+table-cell</li></ul><h2 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h2><div class="hljs code-wrapper"><pre><code>左右固定，中自适应</code></pre></div><ol><li>绝对定位</li><li>左右浮动【自适应元素要放在最后】 <div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>          * &#123;<span class="css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><span class="css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span>          &#125;<span class="css">          <span class="hljs-selector-tag">body</span> &#123;</span><span class="css">            <span class="hljs-attribute">min-width</span>: <span class="hljs-number">550px</span>;</span>          &#125;          .container &#123;<span class="css">            <span class="hljs-attribute">overflow</span>: hidden;</span>          &#125;          .column &#123;<span class="css">            <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100px</span>;</span>          &#125;          .left &#123;<span class="css">            <span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;</span><span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="css">            <span class="hljs-attribute">background</span>: <span class="hljs-number">#ffbbff</span>;</span>          &#125;          .center &#123;<span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="css">            <span class="hljs-attribute">background</span>: <span class="hljs-number">#bfefff</span>;</span>          &#125;          .right &#123;<span class="css">            <span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:right</span>;</span><span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><span class="css">            <span class="hljs-attribute">background</span>: <span class="hljs-number">#eeee00</span>;</span>          &#125;          /*左右浮动至左右并处于同一行          *未浮动的center内容会被浮动元素环绕          */    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column center&quot;</span>&gt;</span>center<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div></li><li>全部左浮，-margin移到上一行【自适应元素放在最前】 <div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>      * &#123;<span class="css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><span class="css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span>      &#125;<span class="css">      <span class="hljs-selector-tag">body</span> &#123;</span><span class="css">        <span class="hljs-attribute">min-width</span>: <span class="hljs-number">550px</span>;</span>      &#125;      .container &#123;<span class="css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">150px</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;</span><span class="css">        <span class="hljs-attribute">overflow</span>: hidden;</span>      &#125;      .column &#123;<span class="css">        <span class="hljs-attribute">position</span>: relative;</span>        /**<span class="css">        *设置定位，元素需要手动移动至<span class="hljs-attribute">padding</span>空隙中</span>        */<span class="css">        <span class="hljs-attribute">float</span>: left;</span><span class="css">        <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100px</span>;</span>      &#125;      .left &#123;<span class="css">        <span class="hljs-attribute">right</span>: <span class="hljs-number">200px</span>;</span><span class="css">        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="css">        <span class="hljs-attribute">background</span>: <span class="hljs-number">#ffbbff</span>;</span>      &#125;      .center &#123;<span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="css">        <span class="hljs-attribute">background</span>: <span class="hljs-number">#bfefff</span>;</span>      &#125;      .right &#123;<span class="css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">150px</span>;</span><span class="css">        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">150px</span>;</span><span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><span class="css">        <span class="hljs-attribute">background</span>: <span class="hljs-number">#eeee00</span>;</span>      &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column center&quot;</span>&gt;</span>center<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div></li><li>全部左浮，center元素需要撑开center-wrapper【自适应元素放在最前】<div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>       * &#123;<span class="css">         <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><span class="css">         <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span>       &#125;<span class="css">       <span class="hljs-selector-tag">body</span> &#123;</span><span class="css">         <span class="hljs-attribute">min-width</span>: <span class="hljs-number">550px</span>;</span>       &#125;       .container &#123;<span class="css">         <span class="hljs-attribute">overflow</span>: hidden;</span>       &#125;       .column &#123;<span class="css">         <span class="hljs-attribute">float</span>: left;</span><span class="css">         <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100px</span>;</span>       &#125;       .left &#123;<span class="css">         <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><span class="css">         <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="css">         <span class="hljs-attribute">background</span>: <span class="hljs-number">#ffbbff</span>;</span>       &#125;       .center-wrapper &#123;<span class="css">         <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span>       &#125;       .center &#123;<span class="css">         <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;</span><span class="css">         <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">150px</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;</span><span class="css">         <span class="hljs-attribute">background</span>: <span class="hljs-number">#bfefff</span>;</span><span class="css">         <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100px</span>;</span>       &#125;       .right &#123;<span class="css">         <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">150px</span>;</span><span class="css">         <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><span class="css">         <span class="hljs-attribute">background</span>: <span class="hljs-number">#eeee00</span>;</span>       &#125;       /**       *3，4方法类似<span class="css">       * -<span class="hljs-number">100%</span>的<span class="hljs-attribute">margin-left</span>将元素移到上行最左</span><span class="css">       * -自身宽度<span class="hljs-attribute">margin-left</span>将元素移到上行最右</span><span class="css">       * 并通过给center加<span class="hljs-attribute">padding</span></span>       */     <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column center-wrapper&quot;</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>center<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div></li><li>flex</li><li>grid</li><li>table-cell</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>控制台一直打印http://xxx/sockjs-node/info?t=xxx</title>
    <link href="/2020/02/04/%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%80%E7%9B%B4%E6%8A%A5%E9%94%99sockjs-node/"/>
    <url>/2020/02/04/%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%80%E7%9B%B4%E6%8A%A5%E9%94%99sockjs-node/</url>
    
    <content type="html"><![CDATA[<h3 id="sockjs-node是一个JavaScript库，提供跨浏览器JavaScript的API，创建了一个低延迟，全双工的浏览器和web服务器之间通信通道。"><a href="#sockjs-node是一个JavaScript库，提供跨浏览器JavaScript的API，创建了一个低延迟，全双工的浏览器和web服务器之间通信通道。" class="headerlink" title="sockjs-node是一个JavaScript库，提供跨浏览器JavaScript的API，创建了一个低延迟，全双工的浏览器和web服务器之间通信通道。"></a>sockjs-node是一个JavaScript库，提供跨浏览器JavaScript的API，创建了一个低延迟，全双工的浏览器和web服务器之间通信通道。</h3><h3 id="如果你的项目没有用到sockjs-vuecli3-运行npm-run-serve-之后network里面一直调用一个接口"><a href="#如果你的项目没有用到sockjs-vuecli3-运行npm-run-serve-之后network里面一直调用一个接口" class="headerlink" title="如果你的项目没有用到sockjs,vuecli3 运行npm run serve 之后network里面一直调用一个接口:"></a>如果你的项目没有用到sockjs,vuecli3 运行npm run serve 之后network里面一直调用一个接口:</h3><p><code>http://localhost:8080/sockjs-node/info?t=1556418283950</code></p><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><ol><li>开发环境中关闭此服务</li></ol><p>  <code>node_modules/sockjs-client/dist/sockjs.js</code>中注释<br><code>self.xhr.send(payload)</code></p><ol start="2"><li>webpack配置中</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript">sockHost: <span class="hljs-string">&quot; http://192.168.1.6:8080&quot;</span>,disableHostCheck: <span class="hljs-literal">true</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
