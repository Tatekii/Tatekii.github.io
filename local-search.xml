<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>解析URL参数</title>
    <link href="/2021/04/06/%E8%A7%A3%E6%9E%90URL%E5%8F%82%E6%95%B0/"/>
    <url>/2021/04/06/%E8%A7%A3%E6%9E%90URL%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<ol><li><p>正则解析</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> rule = <span class="hljs-regexp">/([^?=&amp;]+)=([^&amp;]*)/g</span>&lt;!-- (匹配非[?=&amp;]且出现多次的字符) --&gt;&lt;!-- = --&gt;&lt;!-- (匹配出现<span class="hljs-number">0</span>次或多次的非[&amp;]的字符) --&gt;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseURL</span>(<span class="hljs-params">url</span>)</span>&#123;  <span class="hljs-keyword">return</span> url.match(rule).reduce(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>&#123;    <span class="hljs-keyword">let</span> [key,value] = b.split(<span class="hljs-string">&#x27;=&#x27;</span>)    key = <span class="hljs-built_in">decodeURIComponent</span>(key)    value = <span class="hljs-built_in">decodeURIComponent</span>(value)    <span class="hljs-keyword">if</span>(!a.hasOwnProperty(key))&#123;      a[key] = value    &#125;<span class="hljs-keyword">else</span>&#123;      a[key] = [].concat(value,a[key])    &#125;    <span class="hljs-keyword">return</span> a  &#125;,&#123;&#125;)&#125;</code></pre></div></li><li><p>API解析</p><p> URLSearchParams<br> <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams">https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams</a></p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseURL</span>(<span class="hljs-params">url</span>)</span>&#123;  <span class="hljs-keyword">const</span> urlObj = <span class="hljs-keyword">new</span> URLSearchParams(url.slice(url.indexOf(<span class="hljs-string">&#x27;?&#x27;</span>)))  <span class="hljs-keyword">const</span> res = []  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> urlObj.keys())&#123;    res[key] = urlObj.getAll(key)  &#125;  <span class="hljs-keyword">return</span> res&#125;</code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件夹内批量映射为模块</title>
    <link href="/2021/04/06/%E6%89%B9%E9%87%8F%E6%98%A0%E5%B0%84%E6%A8%A1%E5%9D%97/"/>
    <url>/2021/04/06/%E6%89%B9%E9%87%8F%E6%98%A0%E5%B0%84%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript">./controllers中controllerA.jscontrollerB.jscontrollerC.js</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript">./controllers/index.js<span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>)<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-comment">/**</span><span class="hljs-comment"> * 映射文件夹下的文件为模块</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> mapDir = <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> tree = &#123;&#125;    <span class="hljs-comment">// 获得当前文件夹下的所有的文件夹和文件</span>    <span class="hljs-keyword">const</span> [dirs, files] = _(fs.readdirSync(d))        .partition(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> fs.statSync(path.join(d, p)).isDirectory())    <span class="hljs-comment">// _(value)</span>    <span class="hljs-comment">// 创建一个经 lodash 包装后的对象会启用隐式链。返回的数组、集合、方法相互之间能够链式调用</span>        <span class="hljs-comment">// 递归映射文件夹</span>    dirs.forEach(<span class="hljs-function"><span class="hljs-params">dir</span> =&gt;</span> &#123;        tree[dir] = mapDir(path.join(d, dir))    &#125;)    <span class="hljs-comment">// 映射文件</span>    files.forEach(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (path.extname(file) === <span class="hljs-string">&#x27;.js&#x27;</span>) &#123;            tree[path.basename(file, <span class="hljs-string">&#x27;.js&#x27;</span>)] = <span class="hljs-built_in">require</span>(path.join(d, file))        &#125;    &#125;)    <span class="hljs-keyword">return</span> tree&#125;<span class="hljs-comment">// 默认导出当前文件夹下的映射</span><span class="hljs-built_in">module</span>.exports = mapDir(path.join(__dirname))</code></pre></div><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> controllers = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../controllers&quot;</span>);router.get(<span class="hljs-string">&#x27;/A&#x27;</span>,controllers.controllerA)router.post(<span class="hljs-string">&#x27;/B&#x27;</span>,controllers.controllerB)router.post(<span class="hljs-string">&#x27;/C&#x27;</span>,controllers.controllerC)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>div高度为高度一半</title>
    <link href="/2021/04/04/div%E9%AB%98%E5%BA%A6%E4%B8%BA%E9%AB%98%E5%BA%A6%E4%B8%80%E5%8D%8A/"/>
    <url>/2021/04/04/div%E9%AB%98%E5%BA%A6%E4%B8%BA%E9%AB%98%E5%BA%A6%E4%B8%80%E5%8D%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="position属性"><a href="#position属性" class="headerlink" title="position属性"></a>position属性</h2><ul><li><code>static</code><ul><li>正常流，默认值</li><li>top, right, bottom, left 和 z-index 属性无效。</li></ul></li><li><code>relative</code><ul><li>相对正常流偏移</li><li>原位置有预留空间</li></ul></li><li><code>absolute</code><ul><li>移出正常文档流</li><li>相对于最近的非 static 定位祖先元素偏移</li><li>不为元素预留空间</li></ul></li><li><code>fixed</code><ul><li>移出正常文档流</li><li>相对于屏幕视口（viewport）的位置来指定元素位置</li><li>不为元素预留空间<blockquote><p>当元素祖先的 transform, perspective 或 filter 属性非 none 时，容器由视口改为该祖先。</p></blockquote></li></ul></li><li><code>sticky</code><ul><li>相对定位和固定定位的混合</li><li>须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</li><li>跨越特定阈值前为相对定位，之后为固定定位</li></ul></li></ul><h2 id="包含块"><a href="#包含块" class="headerlink" title="包含块"></a>包含块</h2><h3 id="包含块的作用"><a href="#包含块的作用" class="headerlink" title="包含块的作用"></a>包含块的作用</h3><p>  元素的尺寸及位置，常常会受它的包含块所影响。对于一些属性，例如 width,height, padding, margin，绝对定位元素的偏移值 （比如 position 被置为 absolute 或 fixed），当我们对其赋予百分比值时，这些值的计算值就是通过元素的包含块计算得来</p><h3 id="确定包含块"><a href="#确定包含块" class="headerlink" title="确定包含块"></a>确定包含块</h3><blockquote><p>一个元素的包含块并不一定父元素的内容区</p></blockquote><p>元素的包含块由其<code>position</code>决定：</p><ul><li><code>static 、 relative 或 sticky </code>，包含块可能由它的最近的祖先块元素（比如说inline-block, block 或 list-item元素）的内容区的边缘组成<code>content</code></li><li><code>absolute</code> ，包含块就是由它的最近的 <code>position 的值不是 static</code> （也就是值为fixed, absolute, relative 或 sticky）的祖先元素的内边距区的边缘组成<code>content+padding</code></li><li><code>fixed</code>，在连续媒体的情况下(continuous media)包含块是 viewport ,在分页媒体(paged media)下的情况下包含块是分页区域(page area)。<blockquote><p>当元素祖先的 transform, perspective 或 filter 属性非 none 时,包含块是这个元素的内边距区 content+padding</p></blockquote></li></ul><h3 id="根据包含块计算"><a href="#根据包含块计算" class="headerlink" title="根据包含块计算"></a>根据包含块计算</h3><ul><li>要计算 <code>height</code> <code>top</code> 及 <code>bottom</code> 中的百分值，是通过包含块的 <code>height</code> 的值</li><li>要计算 <code>width</code>, <code>left</code>, <code>right</code>, <strong><code>padding</code>!, <code>margin</code></strong> 这些属性由包含块的 <code>width</code> 属性的值来计算它的百分值。</li></ul><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ol><li><p>实现一个div垂直水平居中高度为宽度的一半自适应</p><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 外层wrapper */</span><span class="hljs-selector-class">.outer-wrapper</span>&#123;  <span class="hljs-attribute">height</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span> auto;  <span class="hljs-attribute">display</span>:flex;  <span class="hljs-comment">/* flex默认行排列，所以这里设置侧轴对齐 */</span>  <span class="hljs-attribute">align-items</span>:center&#125;<span class="hljs-comment">/* 内层wrapper */</span><span class="hljs-selector-class">.inner-wrapper</span>&#123;  <span class="hljs-attribute">position</span>:relative;  <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">padding-bottom</span>:<span class="hljs-number">50%</span>;  <span class="hljs-comment">/* padding,margin值的百分比是相较于父元素width */</span>&#125;<span class="hljs-selector-class">.div</span>&#123;  <span class="hljs-attribute">position</span>:absolute;  <span class="hljs-comment">/* 两个position设置都是为了确定包含块 */</span>  <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">100%</span>;  <span class="hljs-comment">/* 这里的高度就=inner-wrapper[height+padding] */</span>&#125;</code></pre></div></li><li><p>实现div正方形大小自适应</p></li></ol><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span>&#123;  <span class="hljs-attribute">position</span>:relative;  <span class="hljs-attribute">padding-top</span>:<span class="hljs-number">50%</span>;  <span class="hljs-attribute">width</span>:<span class="hljs-number">50%</span>;&#125;<span class="hljs-selector-class">.div</span>&#123;  <span class="hljs-attribute">position</span>:absolute;  <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;  <span class="hljs-comment">/* 偏移到wrapper位置 */</span>  <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">100%</span>;  <span class="hljs-comment">/* 同样相较于包含块的尺寸百分比 */</span>&#125;<span class="hljs-comment">/* 也可使用伪元素撑开高度 */</span><span class="hljs-selector-class">.div</span>&#123;  <span class="hljs-attribute">width</span>:<span class="hljs-number">50%</span>;  <span class="hljs-comment">/* 触发BFC避免塌陷 */</span>  <span class="hljs-comment">/* overflow不为visible */</span>  <span class="hljs-comment">/* position为fixed,absolute[绝对定位] */</span>  <span class="hljs-comment">/* float不为none[浮动元素] */</span>  <span class="hljs-comment">/* flex/grid/table */</span>  <span class="hljs-attribute">display</span>:flow-root&#125;<span class="hljs-selector-class">.div</span>&#123;  <span class="hljs-attribute">content</span>:<span class="hljs-string">&#x27;&#x27;</span>;  <span class="hljs-attribute">margin-top</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">display</span>:block&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axios</title>
    <link href="/2021/01/27/axios/"/>
    <url>/2021/01/27/axios/</url>
    
    <content type="html"><![CDATA[<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><ul><li><p>拦截器中可以修改config和response</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">axios.interceptors.request.use(  (config) =&gt; &#123;    &lt;!-- 加入参数 --&gt;    config.params = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">666</span>&#125;    <span class="hljs-keyword">return</span> config  &#125;,  (err) =&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(err)  &#125;);</code></pre></div></li><li><p>执行顺序</p><ul><li>请求拦截器 后面的拦截器先执行</li><li>响应拦截器 前面的拦截器先执行</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">axios.interceptors.request.use(<span class="hljs-function"><span class="hljs-params">config</span>=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;request1&#x27;</span>)&#125;,<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;err1&#x27;</span>)&#125;)axios.interceptors.request.use(<span class="hljs-function"><span class="hljs-params">config</span>=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;request2&#x27;</span>)&#125;,<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;err2&#x27;</span>)&#125;)axios.interceptors.response.use(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;response1&#x27;</span>)&#125;，err=&gt;&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;resErr1&#x27;</span>)&#125;)axios.interceptors.response.use(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;response2&#x27;</span>)&#125;，err=&gt;&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;resErr2&#x27;</span>)&#125;)&lt;!-- <span class="hljs-built_in">console</span> --&gt;request2request1response1response2</code></pre></div></li><li><p>取消请求</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> CancelToken = axios.CancelToken;<span class="hljs-keyword">let</span> cancel = <span class="hljs-literal">null</span>btn.onclick = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">if</span>(cancel !== <span class="hljs-literal">null</span>) cancel()  &lt;!-- 执行取消函数 --&gt;  axios(&#123;    method:<span class="hljs-string">&#x27;GET&#x27;</span>,    url:<span class="hljs-string">&#x27;http://xxxxxxx&#x27;</span>,    &lt;!--  --&gt;    cancelToken : <span class="hljs-keyword">new</span> CancelToken(<span class="hljs-function"><span class="hljs-params">c</span>=&gt;</span>&#123;      cancel = c      &lt;!-- cancelToken --&gt;    &#125;)  &#125;)&#125;.then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;  cancel = <span class="hljs-literal">null</span>&#125;)</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vuecli打包优化踩坑</title>
    <link href="/2020/11/30/%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/"/>
    <url>/2020/11/30/%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="按需引入"><a href="#按需引入" class="headerlink" title="按需引入"></a>按需引入</h2><ol><li>elementui官网配置方法不适用</li><li>vuecli中babel配置文件为<code>babel.config.js</code></li><li>安装<code>babel-plugin-component</code></li><li>配置<code>babel.config.js</code></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;  presets: [    <span class="hljs-string">&#x27;@vue/cli-plugin-babel/preset&#x27;</span>  ],  plugins: [    [      <span class="hljs-string">&quot;component&quot;</span>,<span class="hljs-comment">// 插件位置</span>      &#123;        <span class="hljs-string">&quot;libraryName&quot;</span>: <span class="hljs-string">&quot;element-ui&quot;</span>,        <span class="hljs-string">&quot;styleLibraryName&quot;</span>: <span class="hljs-string">&quot;theme-chalk&quot;</span>      &#125;    ]  ]&#125;</code></pre></div><ol><li>修改<code>main.js</code><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; MenuItem,Container,Header,Aside,Main,Input,Footer,Avatar, Menu, Table, TableColumn, Pagination ,Button&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;element-ui&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> [MenuItem,Container,Header,Aside,Main,Input,Footer,Avatar, Menu, Table, TableColumn, Pagination,Button]) &#123;  Vue.use(item);&#125;</code></pre></div></li><li>也可以单独独立出自定义组件,二次封装<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// eleui.js</span><span class="hljs-keyword">import</span> &#123; MenuItem,Container,Header,Aside,Main,Input,Footer,Avatar, Menu, Table, TableColumn, Pagination ,Button&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;element-ui&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  install : <span class="hljs-function">(<span class="hljs-params">Vue</span>) =&gt;</span> &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> co <span class="hljs-keyword">of</span> [MenuItem,Container,Header,Aside,Main,Input,Footer,Avatar, Menu, Table, TableColumn, Pagination ,Button])&#123;      Vue.use(co)    &#125;  &#125;&#125;<span class="hljs-comment">// main.js</span><span class="hljs-keyword">import</span> eleUI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./eleUI.js&#x27;</span>Vue.use(eleUI)</code></pre></div></li></ol><h2 id="CDN加载资源"><a href="#CDN加载资源" class="headerlink" title="CDN加载资源"></a>CDN加载资源</h2><ol><li><p>安装<code>html-webpack-plugin</code></p></li><li><p>修改<code>public/index.html</code></p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    &lt;meta      name=&quot;viewport&quot;      content=&quot;width=device-width,initial-scale=1.0,user-scalable=no&quot;    /&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;</span> /&gt;</span>    <span class="hljs-comment">&lt;!-- 使用CDN的CSS文件 --&gt;</span>    &lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp;    htmlWebpackPlugin.options.cdn.css) &#123; %&gt;    &lt;link      href=&quot;&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot;      rel=&quot;preload&quot;      as=&quot;style&quot;    /&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> /&gt;</span>    &lt;% &#125; %&gt;    <span class="hljs-comment">&lt;!-- 使用CDN的CSS文件 --&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span>      &lt;strong        &gt;We&#x27;re sorry but moviapp doesn&#x27;t work properly without JavaScript        enabled. Please enable it to continue.&lt;/strong      &gt;    <span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- built files will be auto injected --&gt;</span>    <span class="hljs-comment">&lt;!-- 使用CDN的JS文件 --&gt;</span>    &lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp;    htmlWebpackPlugin.options.cdn.js) &#123; %&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&lt;%= htmlWebpackPlugin.options.cdn.js[i] %&gt;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    &lt;% &#125; %&gt;    <span class="hljs-comment">&lt;!-- 使用CDN的JS文件 --&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div></li><li><p>配置<code>vue.config.js</code></p></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 判断生产环境</span><span class="hljs-keyword">const</span> isProduction = process.env.NODE_ENV === <span class="hljs-string">&quot;production&quot;</span>;<span class="hljs-keyword">const</span> cdn = &#123;  <span class="hljs-comment">// 随便抓几个</span>  js: [    <span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.0/vue.runtime.esm.js&quot;</span>,    <span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/vue-router/3.1.3/vue-router.esm.js&quot;</span>  ],&#125;;<span class="hljs-built_in">module</span>.exports = &#123;  configureWebpack: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (isProduction) &#123;      config.externals = &#123;        <span class="hljs-comment">// 排除的依赖，不从bundle中引入的依赖</span>        <span class="hljs-string">&quot;vue&quot;</span>: <span class="hljs-string">&quot;Vue&quot;</span>,        <span class="hljs-string">&quot;vue-router&quot;</span>: <span class="hljs-string">&quot;VueRouter&quot;</span>      &#125;;    &#125;  &#125;,  chainWebpack: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (isProduction) &#123;      config.plugin(<span class="hljs-string">&quot;html&quot;</span>).tap(<span class="hljs-function">(<span class="hljs-params">args</span>) =&gt;</span> &#123;        <span class="hljs-comment">// 传递给 html-webpack-plugin&#x27;s 构造函数的新参数</span>        args[<span class="hljs-number">0</span>].cdn = cdn;        <span class="hljs-keyword">return</span> args;      &#125;);    &#125;  &#125;,&#125;;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>diff算法</title>
    <link href="/2020/11/25/diff%E7%AE%97%E6%B3%95/"/>
    <url>/2020/11/25/diff%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>diff算法，包含渲染器如何对各种类型的vNode的属性，text，fragment进行patch更新，以及判断是patch vNode，还是新增还是删除</p><h3 id="简单diff"><a href="#简单diff" class="headerlink" title="简单diff"></a>简单diff</h3><ul><li>newNode.children.length = 0 =&gt; 删除oldNode.children</li><li>oldNode.children = 0 =&gt; 新增newNode.children</li><li>添加全部子节点/删除全部子节点</li></ul><h3 id="核心diff"><a href="#核心diff" class="headerlink" title="核心diff"></a>核心diff</h3><ul><li>相对于简单diff就是优化对子节点的操作过程</li><li>尽可能复用节点</li></ul><h4 id="key的作用"><a href="#key的作用" class="headerlink" title="key的作用"></a>key的作用</h4><ul><li>vNode中的唯一标识符</li><li>用于保存新旧vNode的映射关系</li><li>找到可复用的vNode</li></ul><h4 id="移动节点-gt-最大索引值k"><a href="#移动节点-gt-最大索引值k" class="headerlink" title="移动节点-&gt;最大索引值k"></a>移动节点-&gt;最大索引值k</h4><ul><li><p>新旧vNode，依次取出新vNode去旧vNode中寻找正确位置</p></li><li><p>如果索引呈现递增趋势<br>（newA-&gt;oldA=&gt;0,newB-&gt;oldB=&gt;1,newC-&gt;oldC=&gt;2）则说明新旧 children 中节点顺序相同，不需要移动操作。相反的，如果在寻找的过程中遇到的索引值不呈现递增趋势，则说明需要移动操作</p></li><li><p>如果匹配过程中递增规律被打破</p><p><code>k</code>为在旧 children 中所遇到的最大索引值，则后续匹配的索引小于这个值意味着都需要移动</p></li></ul><h3 id="vue2的双端比较"><a href="#vue2的双端比较" class="headerlink" title="vue2的双端比较"></a>vue2的双端比较</h3><ul><li>vue同时从新旧children的两端开始比较</li><li>四个指针，分别查找是否key相同</li><li>有相同则匹配项目的两个指针向内移动，对匹配成功的vNode进行patch</li><li>新children中拥有新的vNode时，会发生匹配不上的情况，新增节点</li><li>匹配结束后旧children中还有未处理的节点，删除</li></ul><h3 id="vue3的inferno"><a href="#vue3的inferno" class="headerlink" title="vue3的inferno"></a>vue3的inferno</h3><ul><li><p>文本diff-&gt;排除相同的前置和后置元素</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">a,b,c| | |-------|   | |a,e,b,c</code></pre></div><ul><li>分别从新旧节点的头和尾出发</li><li>依次遍历到key值不一样时停止 </li><li>这样匹配成功后剩下的部分就是需要新增/删除的vNode</li></ul></li><li><p>文本diff后，使用剩余新children的长度建立source索引数组</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">oldChildren = [b,c,d,f]newChildren = [c,d,b,g]source = [-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>]<span class="hljs-comment">// 默认全为-1</span><span class="hljs-comment">// 如果在旧children中匹配到key，则把该位置的-1改为旧vNode的索引，并且patch该节点</span><span class="hljs-comment">// 比如</span>source = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>]</code></pre></div></li><li><p>使用最大索引算法判断节点是否需要移动</p></li><li><p>根据source求出最长递增子序列</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">LIS = [<span class="hljs-number">0</span>，<span class="hljs-number">1</span>]<span class="hljs-comment">// LIS中存储的是source索引</span><span class="hljs-comment">// 表示新旧children中这几个节点的先后关系相同</span></code></pre></div></li><li><p>根据LIS得出不进行移动的节点</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">[c,d]</code></pre></div></li><li><p>从LIS和新children尾处建立指针处理余下节点</p></li></ul><h4 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h4><ul><li>子序列：不要求连续</li><li>字串：要求连续</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 动态规划</span><span class="hljs-keyword">const</span> longestChildSequence = <span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> &#123;  <span class="hljs-keyword">let</span> len = arr.length  <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>  <span class="hljs-keyword">const</span> dp = <span class="hljs-built_in">Array</span>(len).fill(<span class="hljs-number">1</span>)  <span class="hljs-comment">// dp[i]代表原始数组该位置的最长子序列长度</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; len ; i++)&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span> ; j &lt; i ; j++)&#123;      <span class="hljs-comment">// j遍历之前遍历过的所有元素</span>      <span class="hljs-comment">// 可能存在大小不一的递增序列，使用max取得最大值</span>      <span class="hljs-keyword">if</span>(arr[i] &gt; arr [j])&#123;        dp[i] = <span class="hljs-built_in">Math</span>.max(dp[i],dp[j]+<span class="hljs-number">1</span>)        <span class="hljs-comment">// [1,2,3,4,1,2,5]</span>        <span class="hljs-comment">// 如果只使用dp[j]+1 ，dp[6]会在[1,2,5]中得出结果3</span>        <span class="hljs-comment">// 使用max比较之前更长的序列[1，2，3，4，5]得到5</span>      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(...dp)&#125;<span class="hljs-comment">// 贪心+二分</span><span class="hljs-keyword">const</span> longestChildSequence = <span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> &#123;  <span class="hljs-keyword">let</span> len = arr.length  <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>  <span class="hljs-keyword">const</span> res = [arr[<span class="hljs-number">0</span>]]  <span class="hljs-comment">//将arr中后续元素arr[i]与res末尾元素比较</span>  <span class="hljs-comment">//大于则push进res</span>  <span class="hljs-comment">//小于则查找res中第一个比arr[i]大的元素并替换</span>  <span class="hljs-comment">//由于存在替换，子序列值不一定正确，但长度是正确的</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i&lt; len ;i++)&#123;    <span class="hljs-keyword">if</span>(arr[i]&gt;res[res.length-<span class="hljs-number">1</span>])&#123;      res.push(arr[i])    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">// res中左右指针的index</span>      <span class="hljs-comment">// 二分查找</span>      <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>      <span class="hljs-keyword">let</span> right = res.length - <span class="hljs-number">1</span>      <span class="hljs-keyword">while</span>(left&lt;right)&#123;        <span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">Math</span>.floor((left+right)/<span class="hljs-number">2</span>)        <span class="hljs-comment">// let mid = ((left+right)/2) | 0</span>        <span class="hljs-comment">// 浮点小数向下求整</span>        <span class="hljs-keyword">if</span>(arr[i]&gt;res[mid])&#123;          left = mid + <span class="hljs-number">1</span>        &#125;<span class="hljs-keyword">else</span>&#123;          right = mid        &#125;      &#125;      res[left] = arr[i]    &#125;  &#125;  <span class="hljs-keyword">return</span> res.length &#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>vue</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node下单文件模块批量映射到处</title>
    <link href="/2020/11/20/node%E4%B8%8B%E7%9A%84%E6%89%B9%E9%87%8F%E6%98%A0%E5%B0%84/"/>
    <url>/2020/11/20/node%E4%B8%8B%E7%9A%84%E6%89%B9%E9%87%8F%E6%98%A0%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<p><img src="../images/controllers.png" alt="controllers"></p><ul><li><p>以koa为例</p></li><li><p>controllers写成单文件</p></li><li><p>使用index.js批量映射</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//index.js</span><span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>)<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-comment">/**</span><span class="hljs-comment"> * 映射文件夹下的文件为模块</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> mapDir = <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> tree = &#123;&#125;    <span class="hljs-comment">// 获得当前文件夹下的所有的文件夹和文件</span>    <span class="hljs-keyword">const</span> [dirs, files] = _(fs.readdirSync(d))        .partition(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> fs.statSync(path.join(d, p)).isDirectory())    <span class="hljs-comment">// _( ...)</span>    <span class="hljs-comment">// 创建一个经 lodash 包装后的对象会启用隐式链。返回的数组、集合、方法相互之间能够链式调用</span>        <span class="hljs-comment">// 递归映射文件夹</span>    dirs.forEach(<span class="hljs-function"><span class="hljs-params">dir</span> =&gt;</span> &#123;        tree[dir] = mapDir(path.join(d, dir))    &#125;)    <span class="hljs-comment">// 映射文件</span>    files.forEach(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (path.extname(file) === <span class="hljs-string">&#x27;.js&#x27;</span>) &#123;            tree[path.basename(file, <span class="hljs-string">&#x27;.js&#x27;</span>)] = <span class="hljs-built_in">require</span>(path.join(d, file))        &#125;    &#125;)    <span class="hljs-keyword">return</span> tree&#125;<span class="hljs-built_in">module</span>.exports = mapDir(path.join(__dirname<span class="hljs-comment">//当前文件夹目录))</span></code></pre></div></li><li><p>使用时候只需require(index.js)后.[module]即可</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> controllers = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../controllers&quot;</span>);router.get(<span class="hljs-string">&quot;/&quot;</span>, controllers.admin);router.get(<span class="hljs-string">&#x27;/userList&#x27;</span>,controllers.adminUser)router.post(<span class="hljs-string">&#x27;/userFreeze&#x27;</span>,controllers.adminFreeze)router.post(<span class="hljs-string">&#x27;/userDelete&#x27;</span>,controllers.adminDelete)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单实现vue3的响应式模块</title>
    <link href="/2020/11/16/vue3_reactive/"/>
    <url>/2020/11/16/vue3_reactive/</url>
    
    <content type="html"><![CDATA[<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// monkeyVersionReactivity.js猴版响应式框架</span><span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();<span class="hljs-keyword">const</span> effectStack = [];<span class="hljs-keyword">const</span> isObject = <span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> obj !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;object&quot;</span>;<span class="hljs-keyword">const</span> baseHandler = &#123;  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, key</span>)</span> &#123;    <span class="hljs-keyword">const</span> ret = <span class="hljs-built_in">Reflect</span>.get(target, key);    track(target, key);    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ret === <span class="hljs-string">&quot;object&quot;</span>) &#123;      <span class="hljs-keyword">return</span> reactive(ret);    &#125;    <span class="hljs-keyword">return</span> ret;  &#125;,  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">target, key, val</span>)</span> &#123;    <span class="hljs-built_in">Reflect</span>.set(target, key, val);    trigger(target, key, val);  &#125;,&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">track</span>(<span class="hljs-params">target, key</span>) </span>&#123;  <span class="hljs-keyword">let</span> activeEffect = effectStack[effectStack.length - <span class="hljs-number">1</span>];  <span class="hljs-keyword">if</span> (!activeEffect) <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">let</span> depsMap = targetMap.get(target);  <span class="hljs-keyword">if</span> (!depsMap) &#123;    targetMap.set(target, (depsMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()));  &#125;  <span class="hljs-keyword">let</span> dep = depsMap.get(key);  <span class="hljs-keyword">if</span> (!dep) &#123;    depsMap.set(key, (dep = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()));  &#125;  <span class="hljs-keyword">if</span> (!dep.has(activeEffect)) &#123;    dep.add(activeEffect);    <span class="hljs-comment">// TODO</span>    activeEffect.deps.push(dep);  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trigger</span>(<span class="hljs-params">target, key, val</span>) </span>&#123;  <span class="hljs-keyword">const</span> depsMap = targetMap.get(target);  <span class="hljs-keyword">if</span> (!depsMap) &#123;    <span class="hljs-comment">// never been tracked</span>    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-keyword">const</span> effects = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();  <span class="hljs-keyword">if</span> (key) &#123;    <span class="hljs-keyword">const</span> dep = depsMap.get(key);    dep.forEach(<span class="hljs-function">(<span class="hljs-params">effect</span>) =&gt;</span> &#123;      effects.add(effect);    &#125;);  &#125;  effects.forEach(<span class="hljs-function">(<span class="hljs-params">ef</span>) =&gt;</span> ef());&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createReactiveEffect</span>(<span class="hljs-params">fn,options</span>)</span>&#123;  <span class="hljs-keyword">const</span> effect = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveEffect</span>(<span class="hljs-params"></span>)</span>&#123;      <span class="hljs-keyword">try</span> &#123;        effectStack.push(effect)        <span class="hljs-keyword">return</span> fn()      &#125; <span class="hljs-keyword">finally</span> &#123;        effectStack.pop()      &#125;  &#125;  effect.deps = []  effect.options = options  <span class="hljs-keyword">return</span> effect&#125;<span class="hljs-comment">// ---------</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactive</span>(<span class="hljs-params">target</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, baseHandler);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">effect</span>(<span class="hljs-params">fn, options=&#123;&#125;</span>) </span>&#123;  <span class="hljs-keyword">const</span> effect = createReactiveEffect(fn, options);  <span class="hljs-keyword">if</span> (!options.lazy) &#123;    effect();  &#125;  <span class="hljs-keyword">return</span> effect;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computed</span>(<span class="hljs-params">fn</span>)</span>&#123;  <span class="hljs-keyword">const</span> runner = effect(fn,&#123;<span class="hljs-attr">computed</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">lazy</span>:<span class="hljs-literal">true</span>&#125;)  <span class="hljs-keyword">return</span> &#123;    effect:runner,    <span class="hljs-keyword">get</span> <span class="hljs-title">val</span>()&#123;      <span class="hljs-keyword">return</span> runner()    &#125;  &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列算法题</title>
    <link href="/2020/09/29/%E9%98%9F%E5%88%97/"/>
    <url>/2020/09/29/%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="队列结构，先进先出"><a href="#队列结构，先进先出" class="headerlink" title="队列结构，先进先出"></a>队列结构，先进先出</h2><ul><li><p>用数组实现-顺序队列</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ArrayQueue</span>(<span class="hljs-params">len</span>)</span>&#123;  <span class="hljs-built_in">this</span>.items = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len)  <span class="hljs-built_in">this</span>.n = len  <span class="hljs-built_in">this</span>.head = <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>.tail = <span class="hljs-number">0</span>&#125;ArrayQueue.prototype.enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.tail === <span class="hljs-built_in">this</span>.n)&#123;<span class="hljs-comment">// tail后没有空余空间</span>    <span class="hljs-keyword">if</span>(head === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><span class="hljs-comment">// head也在0位，表示都是满的</span>    <span class="hljs-comment">//出队后head不在0了</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = head;i&lt;<span class="hljs-built_in">this</span>.tail;i++)&#123;      <span class="hljs-built_in">this</span>.items[i-head] = <span class="hljs-built_in">this</span>.items[i]    &#125;<span class="hljs-comment">// 往前搬移</span>    tail = tail-head    head = <span class="hljs-number">0</span>  &#125;  <span class="hljs-built_in">this</span>.items[<span class="hljs-built_in">this</span>.tail] = item  <span class="hljs-built_in">this</span>.tail ++  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;ArrayQueue.prototype.dequeue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">if</span>(head === tail) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  <span class="hljs-keyword">const</span> ret = items.shift()  head ++  <span class="hljs-keyword">return</span> ret&#125;</code></pre></div></li><li><p>!循环队列</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 避免了顺序队列中的数据搬移操作</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CircularQueue</span>(<span class="hljs-params">len</span>)</span>&#123;  <span class="hljs-built_in">this</span>.items = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len)  <span class="hljs-built_in">this</span>.n = len  <span class="hljs-built_in">this</span>.head = <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>.tail = <span class="hljs-number">0</span>&#125;CircularQueue.prototype = &#123;  enqueue:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>&#123;    <span class="hljs-keyword">if</span>((<span class="hljs-built_in">this</span>.tail+<span class="hljs-number">1</span>)%n===<span class="hljs-built_in">this</span>.head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    <span class="hljs-built_in">this</span>.items[<span class="hljs-built_in">this</span>.tail] = item    <span class="hljs-built_in">this</span>.tail = (<span class="hljs-built_in">this</span>.tail+<span class="hljs-number">1</span>)%n    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  &#125;,  dequeue:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.head===<span class="hljs-built_in">this</span>.tail) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>    <span class="hljs-keyword">const</span> ret = <span class="hljs-built_in">this</span>.items[head]    <span class="hljs-built_in">this</span>.head = (<span class="hljs-built_in">this</span>.head+<span class="hljs-number">1</span>)%n    <span class="hljs-keyword">return</span> ret  &#125;&#125;</code></pre></div></li><li><p>用链表实现-链式队列</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">val</span>)</span>&#123;  <span class="hljs-built_in">this</span>.val = val  <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LinkedListQueue</span>(<span class="hljs-params">len</span>)</span>&#123;  <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span>  <span class="hljs-built_in">this</span>.tail = <span class="hljs-literal">null</span>  <span class="hljs-built_in">this</span>.curLen = <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>.maxLen = len&#125;LinkedListQueue.prototype = &#123;  enqueue: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>)</span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.head===<span class="hljs-literal">null</span>)&#123;      <span class="hljs-built_in">this</span>.head = node      <span class="hljs-built_in">this</span>.tail = node      <span class="hljs-built_in">this</span>.curLen = <span class="hljs-number">1</span>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.curLen &gt;= <span class="hljs-built_in">this</span>.len) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head    <span class="hljs-keyword">while</span>(cur.next)&#123;      cur = cur.next    &#125;    cur.next = node    <span class="hljs-built_in">this</span>.tail = node    <span class="hljs-built_in">this</span>.curLen ++    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  &#125;,  dequeue : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head    <span class="hljs-built_in">this</span>.head = cur.next    <span class="hljs-built_in">this</span>.curLen --    <span class="hljs-keyword">return</span> cur  &#125;&#125;</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>topK问题</title>
    <link href="/2020/09/24/topK/"/>
    <url>/2020/09/24/topK/</url>
    
    <content type="html"><![CDATA[<h2 id="最大-小的-K-个数，第-K-个最大-最小值"><a href="#最大-小的-K-个数，第-K-个最大-最小值" class="headerlink" title="最大/小的 K 个数，第 K 个最大/最小值"></a>最大/小的 K 个数，第 K 个最大/最小值</h2><ul><li>数组完全排序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">data = data.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a);<span class="hljs-comment">//前k个大值</span><span class="hljs-keyword">let</span> res1 = data.slice(<span class="hljs-number">0</span>, k);<span class="hljs-comment">//第k大的值</span><span class="hljs-keyword">let</span> res2 = data[k - <span class="hljs-number">1</span>];</code></pre></div><ul><li>局部冒泡</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr, k</span>) </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>;    <span class="hljs-comment">// 冒泡执行k次</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = arr.length - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span> + i; j--) &#123;      <span class="hljs-keyword">if</span> (arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) &#123;        [arr[j], arr[j - <span class="hljs-number">1</span>]] = [arr[j - <span class="hljs-number">1</span>], arr[j]];        flag = <span class="hljs-literal">true</span>;      &#125;    &#125;    <span class="hljs-keyword">if</span> (!flag) <span class="hljs-keyword">break</span>;  &#125;&#125;<span class="hljs-comment">//前k个小值</span>data.slice(<span class="hljs-number">0</span>, k);<span class="hljs-comment">//第k小的值</span>data[k - <span class="hljs-number">1</span>];</code></pre></div><ul><li>堆排序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// topk</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapObj</span>(<span class="hljs-params">items,k</span>)</span>&#123;  <span class="hljs-keyword">const</span> heap = [,...items.slice(<span class="hljs-number">0</span>,k)]  <span class="hljs-keyword">const</span> heapSize = k  buildHeap(heap,heapSize)  <span class="hljs-comment">// 求大值，建立最小堆</span>  <span class="hljs-comment">// 后续与最小堆堆顶比较</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = k ; j &lt; items.length ; j++)&#123;    <span class="hljs-keyword">if</span>(heap[<span class="hljs-number">1</span>] &lt; items[j])&#123;      heap[<span class="hljs-number">1</span>] = items[j]      heapify(heap,heapSize,<span class="hljs-number">1</span>)    &#125;  &#125;  <span class="hljs-keyword">return</span> heap  <span class="hljs-comment">// 前k个大值</span>  heap.slice(<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>)  <span class="hljs-comment">//第k大的值</span>  heap[k]&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildHeap</span>(<span class="hljs-params">items,heapSize</span>)</span>&#123;  <span class="hljs-keyword">if</span>(heapSize === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(heapSize/<span class="hljs-number">2</span>) ; i &gt;= <span class="hljs-number">1</span> ; i --)&#123;    heapify(items,heapSize,i)  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">items,heapSize,i</span>)</span>&#123;  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;    <span class="hljs-keyword">let</span> minIndex = i    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i &lt;= heapSize &amp;&amp; items[<span class="hljs-number">2</span>*i] &lt; items[i]) minIndex = <span class="hljs-number">2</span>*i    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; items[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>] &lt; items[minIndex]) minIndex = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>    <span class="hljs-keyword">if</span>(minIndex===i) <span class="hljs-keyword">break</span>    [items[i],items[minIndex]] = [items[minIndex],items[i]]    i = minIndex  &#125;</code></pre></div><ul><li>快速排序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 随机选取基准，数组分成基准左右两部分</span><span class="hljs-comment">// 将比基准大的移动基准右边，比基准小的移动到基准左边</span><span class="hljs-comment">// 递归分割排序</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr</span>) </span>&#123;  quick(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quick</span>(<span class="hljs-params">arr, left, right</span>) </span>&#123;    <span class="hljs-keyword">let</span> index;    <span class="hljs-keyword">if</span> (left &lt; right) &#123;      <span class="hljs-comment">//</span>      index = partition(arr, left, right);      <span class="hljs-comment">// 分离一次</span>      <span class="hljs-keyword">if</span> (left &lt; index - <span class="hljs-number">1</span>) &#123;        quick(arr, left, index - <span class="hljs-number">1</span>);      &#125;      <span class="hljs-keyword">if</span> (index &lt; right) &#123;        quick(arr, index, right);      &#125;    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partition</span>(<span class="hljs-params">arr, left, right</span>) </span>&#123;    <span class="hljs-keyword">const</span> base = arr[<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (right - left + <span class="hljs-number">1</span>)) + left];    <span class="hljs-keyword">let</span> L = left,      R = right;    <span class="hljs-keyword">while</span> (L &lt;= R) &#123;      <span class="hljs-keyword">while</span> (arr[L] &lt; base) &#123;        L++;      &#125;      <span class="hljs-keyword">while</span> (arr[R] &gt; base) &#123;        R--;      &#125;      <span class="hljs-keyword">if</span> (L &lt;= R) &#123;        [arr[L], arr[R]] = [arr[R], arr[L]];        L++;        R--;      &#125;    &#125;    <span class="hljs-keyword">return</span> L;  &#125;&#125;quickSort([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>]);<span class="hljs-comment">//[(1, 2, 3, 4, 5, 6, 7, 8)];</span><span class="hljs-comment">//前k个大值</span>arr.slice(-k);<span class="hljs-comment">//第k大的值</span>arr[arr.length - k];</code></pre></div><ul><li>选择排序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//分割出来的索引位置，与k的索引位置比较</span><span class="hljs-comment">//第k大的值，小到大排序后就是 [nums.length - k] 索引的位置</span><span class="hljs-comment">//减少操作次数，不用完全排序一遍</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findK</span>(<span class="hljs-params">nums, k</span>) </span>&#123;  <span class="hljs-keyword">return</span> quickSelect(nums, nums.length - k);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSelect</span>(<span class="hljs-params">arr, k</span>) </span>&#123;  <span class="hljs-keyword">return</span> quick(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, k);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quick</span>(<span class="hljs-params">arr, left, right, k</span>) </span>&#123;  <span class="hljs-keyword">let</span> index;  <span class="hljs-keyword">if</span> (left &lt; right) &#123;    index = partition(arr, left, right);    <span class="hljs-keyword">if</span> (k === index) &#123;      <span class="hljs-keyword">return</span> arr[index];    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &lt; index) &#123;      <span class="hljs-keyword">return</span> quick(arr, left, index - <span class="hljs-number">1</span>, k);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> quick(arr, index + <span class="hljs-number">1</span>, right, k);    &#125;  &#125;  <span class="hljs-keyword">return</span> arr[left];&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partition</span>(<span class="hljs-params">arr, left, right</span>) </span>&#123;  <span class="hljs-keyword">let</span> base = arr[<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (right - left + <span class="hljs-number">1</span>)) + left];  <span class="hljs-keyword">let</span> L = left,    R = right;  <span class="hljs-keyword">while</span> (L &lt; R) &#123;    <span class="hljs-keyword">while</span> (arr[L] &lt; base) &#123;      L++;    &#125;    <span class="hljs-keyword">while</span> (arr[R] &gt; base) &#123;      R--;    &#125;    <span class="hljs-keyword">if</span> (L &lt; R) [arr[L], arr[R]] = [arr[R], arr[L]];    <span class="hljs-keyword">if</span> (arr[L] === arr[R] &amp;&amp; L !== R) L++;  &#125;  <span class="hljs-keyword">return</span> L;&#125;</code></pre></div><h2 id="出现最多-最少的-K-个元素"><a href="#出现最多-最少的-K-个元素" class="headerlink" title="出现最多/最少的 K 个元素"></a>出现最多/最少的 K 个元素</h2><ul><li>傻瓜 map 映射一个 arr 进行排序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMost</span>(<span class="hljs-params">arr, k</span>) </span>&#123;  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();  <span class="hljs-keyword">const</span> ret = [...new <span class="hljs-built_in">Set</span>(arr)];  arr.map(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (map.has(num)) &#123;      map.set(num, map.get(num) + <span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      map.set(num, <span class="hljs-number">1</span>);    &#125;  &#125;);  ret.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> map.get(b) - map.get(a));  <span class="hljs-keyword">return</span> ret.slice(<span class="hljs-number">0</span>, k);&#125;</code></pre></div><ul><li>map 映射堆排序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMost</span>(<span class="hljs-params">arr, k</span>) </span>&#123;  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();  <span class="hljs-keyword">const</span> heap = [,];  arr.map(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (map.has(num)) &#123;      map.set(num, map.get(num) + <span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      map.set(num, <span class="hljs-number">1</span>);    &#125;  &#125;);  <span class="hljs-keyword">if</span> (map.size &lt;= k) <span class="hljs-keyword">return</span> [...map.keys()];  <span class="hljs-comment">//k大于元素数，直接输出</span>  <span class="hljs-keyword">let</span> times = <span class="hljs-number">1</span>;  <span class="hljs-comment">//记数器</span>  <span class="hljs-comment">//小于k的部分直接建立堆，大于的部分开始与堆top比较</span>  map.forEach(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (times &lt;= k) &#123;      heap.push(key);      <span class="hljs-keyword">if</span> (times === k) &#123;        <span class="hljs-comment">//堆化</span>        buildHeap(heap, map, k);      &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.get(heap[<span class="hljs-number">1</span>]) &lt; value) &#123;      <span class="hljs-comment">// 与小顶堆顶交换</span>      heap[<span class="hljs-number">1</span>] = key;      heapify(heap, map, k, <span class="hljs-number">1</span>);    &#125;    times++;  &#125;);  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildHeap</span>(<span class="hljs-params">heap, map, heapSize</span>) </span>&#123;    <span class="hljs-keyword">if</span> (k === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(heapSize / <span class="hljs-number">2</span>); i &gt;= <span class="hljs-number">1</span>; i--) &#123;      heapify(heap, map, heapSize, i);    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">heap, map, heapSize, i</span>) </span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;      <span class="hljs-keyword">let</span> minIndex = i;      <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * i &lt;= heapSize &amp;&amp; map.get(heap[<span class="hljs-number">2</span> * i]) &lt; map.get(heap[minIndex]))        minIndex = <span class="hljs-number">2</span> * i;      <span class="hljs-keyword">if</span> (        <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span> &lt;= heapSize &amp;&amp;        map.get(heap[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>]) &lt; map.get(heap[minIndex])      )        minIndex = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;      <span class="hljs-keyword">if</span> (minIndex === i) <span class="hljs-keyword">break</span>;      swap(heap, minIndex, i);      i = minIndex;    &#125;  &#125;  heap.shift();  <span class="hljs-keyword">return</span> heap;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">data, l, r</span>) </span>&#123;  <span class="hljs-keyword">let</span> temp = data[l];  data[l] = data[r];  data[r] = temp;&#125;</code></pre></div><ul><li>桶排序<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMost</span>(<span class="hljs-params">arr,k</span>)</span>&#123;  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()  arr.map(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (map.has(num)) &#123;      map.set(num, map.get(num) + <span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      map.set(num, <span class="hljs-number">1</span>);    &#125;  &#125;);  <span class="hljs-keyword">if</span>(map.size&lt;=k) <span class="hljs-keyword">return</span> [...map.keys()]  <span class="hljs-keyword">return</span> buckerSort(map,k)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buckerSort</span>(<span class="hljs-params">map,k</span>)</span>&#123;  <span class="hljs-keyword">let</span> arr = []  <span class="hljs-keyword">let</span> res = []  map.forEach(<span class="hljs-function">(<span class="hljs-params">value,key</span>)=&gt;</span>&#123;    <span class="hljs-keyword">if</span>(!arr[value])&#123;      arr[value] = [key]    &#125;<span class="hljs-keyword">else</span>&#123;      arr[value].push(key)    &#125;  &#125;)  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = arr.length - <span class="hljs-number">1</span> ; i&gt;=<span class="hljs-number">0</span> &amp;&amp; res.length &lt; k ; i--)&#123;    <span class="hljs-keyword">if</span>(arr[i])&#123;      res.push(...arr[i])    &#125;  &#125;  <span class="hljs-keyword">return</span> res&#125;</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cookie</title>
    <link href="/2020/09/17/cookie%E5%92%8Csession/"/>
    <url>/2020/09/17/cookie%E5%92%8Csession/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p><strong>广义</strong>上的<code>Session</code>：由于HTTP协议是无状态的协议，所以服务端需要用某种机制来标示和跟踪具体用户，这就是<code>Session</code>(会话)概念</p></li><li><p><strong>狭义</strong>上的<code>Session</code>：服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中</p></li><li><p>目前大多数应用使用<code>cookie</code>来实现<code>Session</code>跟踪，<code>http cookie</code>是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</p><ol><li>服务端通过<code>set-cookie</code>让浏览器记录对应本用户的<code>cookie</code></li><li>之后的请求都会带上<code>cookie</code>,服务器读取<code>cookie</code>后加载相应的<code>session</code>数据，识别该请求来源于特定的用户</li></ol></li></ul><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><blockquote><p>存储在本地的小型文本文件</p></blockquote><ul><li><p>由服务器设置过期时间</p></li><li><p>数据大小 4KB</p></li><li><p>参与每次http请求</p></li><li><p>有路径概念，可以限制不同路径下的 cookie 互相是访问</p></li><li><p>字段</p><ul><li><p><code>name</code></p></li><li><p><code>value</code></p></li><li><p><code>domain</code>　        可以访问此cookie的域，默认为该请求源的域</p></li><li><p><code>path</code>　        　 可以访问此cookie的页面路径</p></li><li><p><code>expires/Max-Age</code> 过期时间，如没设置则与会话时效相同（关闭浏览器窗口失效）</p></li><li><p><code>httponly</code>　      只能传输不能查看</p></li><li><p><code>secure</code>          只使用HTTPS传输</p></li><li><p><code>sameSite = </code></p><ul><li><code>Strict</code>  跨域时不允许带上任何cookie</li><li><code>Lax</code>  只有三种情况可以带上cookie[a连接,get提交的表单,预加载link]<blockquote><p>现代浏览器会将没有声明 SameSite 值的 cookie 默认设置为Lax</p></blockquote></li><li><code>None</code> 需配合<code>secure</code>使用用 <code>Set-Cookie: widget_session=xxxxx; SameSite=None; Secure</code></li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器缓存策略</title>
    <link href="/2020/09/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    <url>/2020/09/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><ul><li> 浏览器直接验证本地资源看是否过期，如果没过期直接使用本地缓存，并返回<code>200</code></li><li> 验证两种字段<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a><code>Expires</code></h3></li></ul><ol><li>http 1.0</li><li>时间戳格式<code>Expires: Wed, 22 Oct 2018 08:41:00 GMT</code></li><li>使用本地时间验证，与服务器时间之间的误差或者本地时间的修改都后会造成缓存失效</li></ol><h3 id="Cache-control"><a href="#Cache-control" class="headerlink" title="Cache-control"></a><code>Cache-control</code></h3><ol><li><p>http 1.1</p></li><li><p>可选参数：</p><ul><li><code>max-age</code>,<code>s-maxage</code><ul><li>单位为毫秒，表示多长时间后过期</li><li><code>s-maxage</code>优先级高于前者</li><li>可设置为 <strong>0</strong> 立即请求新资源</li></ul></li><li><code>public</code>,<code>private</code><ul><li><code>public</code> 表示该资源可以被所有客户端和代理服务器缓存</li><li><code>private</code> 表示该资源仅能客户端缓存。默认值是 <code>private</code></li><li>当设置了 <code>s-maxage</code> 的时候表示允许代理服务器缓存，相当于 <code>public</code></li></ul></li><li><code>no-cache</code>,<code>no-store</code><ul><li><code>no-cache</code> 会缓存资源，但要协商缓存验证</li><li><code>no-store</code> 不缓存</li><li>两个字段存在时忽略<code>max-age</code>长度和<code>Expire</code>时间戳</li></ul></li></ul></li></ol><h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a><code>Pragma</code></h3><p><code>Pragma = no-cache</code>与<code>Cache-Control: no-cache</code>效果一致</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><code>pragma -&gt; cache-control -&gt; expires</code></p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><ul><li>浏览器携带缓存标识向服务器发起请求，询问服务器缓存有效性</li><li>协商缓存生效，返回<code>304</code>和<code>Not Modified</code></li><li>协商缓存失效，返回<code>200</code>和请求结果<h3 id="Last-modified-If-Modified-Since"><a href="#Last-modified-If-Modified-Since" class="headerlink" title="Last-modified + If-Modified-Since"></a><code>Last-modified + If-Modified-Since</code></h3></li></ul><ol><li><p>服务器返回资源的同时在<code>response header</code>中添加 <code>Last-Modified</code>，值是这个资源在服务器上的最后修改时间<br> <code>Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT</code></p></li><li><p>再次请求该资源时，浏览器检测到资源中存在 <code>Last-Modified</code>字段，则会将这个时间戳作为<code>If-Modified-Since</code>的值加入请求头中发送给服务器</p></li><li><p>服务器根据自身资源的修改时间和来自请求的时间戳判断资源是否更新，返回相对应的结果</p></li></ol><h4 id="优劣"><a href="#优劣" class="headerlink" title="@优劣"></a>@优劣</h4><ul><li>本地打开缓存文件，即使没有对文件进行修改，但还是会造成 <code>Last-Modified</code> 被修改</li><li><code>Last-Modified</code> 只能以秒计时，如果在不可感知的时间内修改完成文件，则不能体现被修改过</li></ul><h3 id="ETag-If-Not-Match"><a href="#ETag-If-Not-Match" class="headerlink" title="ETag + If-Not-Match"></a><code>ETag + If-Not-Match</code></h3><ol><li>服务器为资源进行hash计算生成唯一的标识符<code>Etag</code>加入返回头，资源的修改会导致标识改变</li><li>浏览器请求时将资源自带的标识作为<code>If-None-Match</code>的值加入请求头中发送给服务器</li><li>服务器根据同一资源标识是否一致返回相应结果</li></ol><h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><ol><li><p>先判断<code>Cache-Control</code>，在<code>Cache-Control</code>的<code>max-age</code>之内，直接返回<code>200 from cache</code>；</p></li><li><p>没有<code>Cache-Control</code>再判断<code>Expires</code>，在<code>Expires</code>之内，直接返回<code>200 from cache</code></p></li><li><p><code>Cache-Control=no-cache</code>或者不符合<code>Expires</code>，浏览器向服务器发送请求</p></li><li><p> 服务器判断<code>If-Modified-Since</code>和<code>If-None-Match</code>，两者同时出现时会忽略<code>If-Modified-Since</code>，有效则返回<code>304</code>，失效则返回新资源。</p></li></ol><h2 id="用户行为的影响"><a href="#用户行为的影响" class="headerlink" title="用户行为的影响"></a>用户行为的影响</h2><ol><li><em>地址栏</em>访问，链接跳转是正常用户行为，将会触发浏览器缓存机制；</li><li><em>F5</em>刷新，浏览器会设置max-age=0，强缓存失效，进行协商缓存判断；</li><li><em>ctrl+F5</em>刷新，跳过强缓存和协商缓存，直接从服务器拉取资源。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3预热</title>
    <link href="/2020/09/07/vue3%E9%A2%84%E7%83%AD/"/>
    <url>/2020/09/07/vue3%E9%A2%84%E7%83%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="VUE冲冲冲"><a href="#VUE冲冲冲" class="headerlink" title="VUE冲冲冲"></a>VUE冲冲冲</h1><h2 id="代替defineProperty的Proxy"><a href="#代替defineProperty的Proxy" class="headerlink" title="代替defineProperty的Proxy"></a>代替defineProperty的Proxy</h2><h3 id="vue2-X存在的缺陷"><a href="#vue2-X存在的缺陷" class="headerlink" title="vue2.X存在的缺陷"></a>vue2.X存在的缺陷</h3><ul><li><p>无法检测对象中 <code>property</code> 的添加或移除</p></li><li><p>通过下标操作数组，例如：<code>vm.items[indexOfItem] = newValue （性能考虑放弃）</code></p></li><li><p>修改数组的长度时，例如：<code>vm.items.length = newLength</code></p></li><li><p>变通</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// Object新增元素</span>Vue.set(object, propertyName, value)<span class="hljs-comment">// or</span><span class="hljs-built_in">this</span>.$set(<span class="hljs-built_in">this</span>.someObject,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">2</span>)<span class="hljs-comment">// 下标修改数组</span>Vue.set(vm.array1, indexOfItem, newValue)<span class="hljs-comment">// or</span><span class="hljs-built_in">this</span>.$set(<span class="hljs-built_in">this</span>.array1, indexOfItem, newValue)<span class="hljs-comment">// or</span><span class="hljs-built_in">this</span>.array1.splice(indexOfItem, <span class="hljs-number">1</span>, newValue)<span class="hljs-comment">// 修改数组长度</span><span class="hljs-built_in">this</span>.array1.splice(newLength)</code></pre></div></li><li><p>包裹数组部分方法以支持响应式</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">pop()push()shift()unshift()splice()sort()reverse()</code></pre></div><h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a><code>defineProperty</code></h3></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.defineProperty(obj<span class="hljs-comment">/* 对象*/</span>, prop<span class="hljs-comment">/* 属性*/</span>, descriptor<span class="hljs-comment">/*描述符*/</span>)&#123;  <span class="hljs-comment">//对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。</span>  <span class="hljs-comment">//数据描述符是一个具有值的属性，该值可以是可写的，也可以是不可写的。</span>  <span class="hljs-comment">//存取描述符是由 getter 函数和 setter 函数所描述的属性。</span>  <span class="hljs-comment">//一个描述符只能是这两者其中之一；不能同时是两者。</span>  configurable: <span class="hljs-literal">true</span>,  <span class="hljs-comment">//configurable 特性表示对象的属性是否可以被删除，以及除 value 和 writable 特性外的其他特性是否可以被修改。</span>  enumerable: <span class="hljs-literal">true</span>,  <span class="hljs-comment">//enumerable 定义了对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举。</span>  value: <span class="hljs-literal">true</span>,  writable: <span class="hljs-literal">true</span>,  <span class="hljs-comment">//当 writable 属性设置为 false 时，该属性被称为“不可写的”。它不能被重新赋值。</span>  <span class="hljs-comment">//</span>  <span class="hljs-comment">// 或者</span>  <span class="hljs-comment">//</span>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123; ... &#125;,  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newValue</span>)</span> &#123; ... &#125;,  enumerable : <span class="hljs-literal">true</span>,  configurable : <span class="hljs-literal">true</span>&#125;</code></pre></div><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol><li>兼容<code>IE9</code></li><li>劫持了对象上的<code>属性</code></li><li>数据结构越复杂初始性能会越差,需要递归遍历绑定<code>defineProperty</code></li><li>为保持响应式还需要为新增数据再次绑定<code>defineProperty</code></li><li>原数据的修改即可触发拦截器</li></ol><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a><code>proxy</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler)handler.getPrototypeOf()<span class="hljs-comment">//Object.getPrototypeOf 方法的捕捉器。</span>handler.setPrototypeOf()<span class="hljs-comment">//Object.setPrototypeOf 方法的捕捉器。</span>handler.isExtensible()<span class="hljs-comment">//Object.isExtensible 方法的捕捉器。</span>handler.preventExtensions()<span class="hljs-comment">//Object.preventExtensions 方法的捕捉器。</span>handler.getOwnPropertyDescriptor()<span class="hljs-comment">//Object.getOwnPropertyDescriptor 方法的捕捉器。</span>handler.defineProperty()<span class="hljs-comment">//Object.defineProperty 方法的捕捉器。</span>handler.has()<span class="hljs-comment">//in 操作符的捕捉器。</span>handler.get()<span class="hljs-comment">//属性读取操作的捕捉器。</span>handler.set()<span class="hljs-comment">//属性设置操作的捕捉器。</span>handler.deleteProperty()<span class="hljs-comment">//delete 操作符的捕捉器。</span>handler.ownKeys()<span class="hljs-comment">//Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。</span>handler.apply()<span class="hljs-comment">//函数调用操作的捕捉器。</span>handler.construct()<span class="hljs-comment">//new 操作符的捕捉器。</span></code></pre></div><ol><li>不兼容<code>IE</code></li><li>劫持<code>整个对象</code>，无需对对象本体的变化作出修改</li><li>拦截器响应的是<code>proxy</code>生成的代理对象，原数据的修改将不会触发拦截器</li><li>拦截器种类繁多</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>require.context()</title>
    <link href="/2020/09/03/require.context%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/09/03/require.context%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<ul><li><p>自动化注册组件</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// global.js</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> upperFirst <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash/upperFirst&#x27;</span><span class="hljs-keyword">import</span> camelCase <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash/camelCase&#x27;</span><span class="hljs-keyword">const</span> requireComponent = <span class="hljs-built_in">require</span>.context(  <span class="hljs-comment">// 其组件目录的相对路径</span>  <span class="hljs-comment">// 全局注册的目录</span>  .,  <span class="hljs-comment">// 是否查询其子目录</span>  <span class="hljs-literal">false</span>,  <span class="hljs-comment">// 匹配基础组件文件名的正则表达式</span>  <span class="hljs-comment">// /Base[A-Z]\w+\.(vue|js)$/</span>  /\.vue$/)requireComponent.keys().forEach(<span class="hljs-function"><span class="hljs-params">fileName</span> =&gt;</span> &#123;  <span class="hljs-comment">// 获取组件配置</span>  <span class="hljs-keyword">const</span> componentConfig = requireComponent(fileName)  <span class="hljs-comment">// 获取组件的 PascalCase 命名</span>  <span class="hljs-keyword">const</span> componentName = upperFirst(    camelCase(      <span class="hljs-comment">// 获取和目录深度无关的文件名</span>      fileName        <span class="hljs-comment">// .split(&#x27;/&#x27;)</span>        <span class="hljs-comment">// .pop()</span>        .replace(<span class="hljs-regexp">/^\.\//</span>,<span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-comment">// ‘./ComA.vue’ =&gt; &#x27;ComA.vue&#x27;</span>        .replace(<span class="hljs-regexp">/\.\w+$/</span>, <span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-comment">// =&gt; &#x27;ComA&#x27;</span>    )  )  <span class="hljs-comment">// 全局注册组件</span>  Vue.component(    componentName,    <span class="hljs-comment">// 如果这个组件选项是通过 `export default` 导出的，</span>    <span class="hljs-comment">// 那么就会优先使用 `.default`，</span>    <span class="hljs-comment">// 否则回退到使用模块的根。</span>    componentConfig.default || componentConfig  )&#125;)</code></pre></div></li><li><p>自动化注册路由</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// router.js</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>Vue.use(Router)<span class="hljs-keyword">const</span> routerList = []<span class="hljs-keyword">const</span> importAllRouter = <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;  r.keys().forEach(<span class="hljs-function"><span class="hljs-params">key</span>=&gt;</span>&#123;    routerList.push(r[key].default  <span class="hljs-comment">/*export default*/</span>)  &#125;)&#125;importAllRouter(<span class="hljs-built_in">require</span>.context(.<span class="hljs-comment">/* 查询目录*/</span>,<span class="hljs-literal">true</span><span class="hljs-comment">/*是否包含子目录*/</span>,<span class="hljs-regexp">/\.router\.js/</span><span class="hljs-regexp">/*匹配正则*/</span>))<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Router(&#123;  ...routerList&#125;)</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆及相关算法</title>
    <link href="/2020/08/31/%E5%A0%86/"/>
    <url>/2020/08/31/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul><li><p>堆就是完全二叉树</p><div class="hljs code-wrapper"><pre><code>完全二叉树：除了深度最深的一层外所有层节点数都满员深度：从根节点到该节点经历的节点个数</code></pre></div></li><li><p>每一个节点都比左右子节点大–&gt;最大堆，最大值在根节点</p></li><li><p>每一个节点都比左右子节点小–&gt;最小堆，最小值在根节点</p></li><li><p>完全二叉树可以使用数组来存储</p></li></ul><h3 id="建立堆"><a href="#建立堆" class="headerlink" title="建立堆"></a>建立堆</h3><ul><li>将节点与父节点比较</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//小顶堆</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildHeap</span>(<span class="hljs-params">items,heapSize</span>)</span>&#123;  <span class="hljs-keyword">while</span>(heapSize&lt;items.length - <span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">// items 第一个是&lt;empty item&gt;</span>    heapSize++    heapify(items,heapSize)  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">items,i</span>)</span>&#123;  <span class="hljs-keyword">while</span>(<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>) &gt; <span class="hljs-number">0</span> &amp;&amp; items[i] &lt; items[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)])&#123;    [items[i],items[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)]] =  [items[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)],items[i]]    <span class="hljs-comment">// 交换位置</span>    i = <span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)  &#125; &#125;</code></pre></div><ul><li>将节点与子节点比较</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//大顶堆</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildHeap</span>(<span class="hljs-params">items</span>)</span>&#123;  <span class="hljs-keyword">const</span> heapSize = items.length - <span class="hljs-number">1</span>  <span class="hljs-comment">// &lt;-- items.length - 1 !</span>  <span class="hljs-comment">// 最后叶子节点的索引值</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(heapSize/<span class="hljs-number">2</span>) ; i &gt;= <span class="hljs-number">1</span> ; i--)&#123; <span class="hljs-comment">// &lt;-i&gt;=1 !</span>    <span class="hljs-comment">// i 为最后一个非 叶子 节点的索引，i还有子节点</span>    heapify(items,heapSize,i)  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">items, heapSize, i</span>) </span>&#123;  <span class="hljs-comment">// 自上而下式堆化</span>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;      <span class="hljs-keyword">var</span> maxIndex = i;      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i &lt;= heapSize &amp;&amp; items[maxIndex] &lt; items[i*<span class="hljs-number">2</span>] ) &#123;        <span class="hljs-comment">// 这里的等号意味着万一这个节点是最后的节点呢</span>          maxIndex = i*<span class="hljs-number">2</span>;      &#125;      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; items[maxIndex] &lt; items[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] ) &#123;          maxIndex = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;      &#125;      <span class="hljs-keyword">if</span> (maxIndex === i) <span class="hljs-keyword">break</span>;      [items[i],items[maxIndex]] = [items[maxIndex],items[i]]      i = maxIndex;   &#125;&#125;</code></pre></div><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ol><li>建立大顶堆/小顶堆</li><li>则索引1位置为当前堆的 最大值/最小值</li><li>循环将[1]与[末尾]交换位置，并且缩小堆的大小（相当于将上一次的最值移出堆）</li><li>一直堆化</li><li>大顶堆得到升序 / 小顶堆得到降序排列</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapSort</span>(<span class="hljs-params">arr</span>)</span>&#123;  <span class="hljs-comment">// 输入需要为[,]</span>  <span class="hljs-comment">// const heap = [,]</span>  <span class="hljs-comment">// let i = 0</span>  <span class="hljs-comment">// while(i&lt;arr.length)&#123;</span>  <span class="hljs-comment">//   heap.push(arr[i++])</span>  <span class="hljs-comment">// &#125;</span>  <span class="hljs-keyword">const</span> heapSize  =  arr.length - <span class="hljs-number">1</span>  buildHeap(arr,heapSize)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = heapSize ; i&gt;<span class="hljs-number">1</span> ;i--)&#123;    [arr[i],arr[<span class="hljs-number">1</span>]]=[arr[<span class="hljs-number">1</span>],arr[i]]    heapSize --    heapify(arr,heapSize,<span class="hljs-number">1</span>)  &#125;  <span class="hljs-keyword">return</span> arr&#125;</code></pre></div><h3 id="topK问题"><a href="#topK问题" class="headerlink" title="topK问题"></a>topK问题</h3><p>求出前k个最大/最小值，或者出现次数最多/最少的k个值</p><ul><li>求大值，建立最小堆</li><li>求小值，建立最大堆<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 比如求前k个最大值</span><span class="hljs-comment">// 先用前k个数据建立小顶堆</span><span class="hljs-comment">// 为什么求前k大建立小顶堆？？？</span><span class="hljs-comment">// 如果建立大顶堆，交换堆顶后，堆顶依然是最大的，依次比较之后的数据只会改变堆顶而已，收集不了别的值</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">topK</span>(<span class="hljs-params">data,k</span>)</span>&#123;  <span class="hljs-keyword">let</span> heap = [,],i = <span class="hljs-number">0</span>  <span class="hljs-keyword">while</span>(i&lt;k)&#123;    heap.push(data[i++])  &#125;  <span class="hljs-keyword">const</span> heapSize = k  buildHeap(heap,heapSize)  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = k ; j &lt;data.length ;j++)&#123;    <span class="hljs-comment">// 将余下的数据依次与堆顶比较</span>    <span class="hljs-comment">// 比小顶堆的堆顶大则交换</span>    <span class="hljs-keyword">if</span>(heap[<span class="hljs-number">1</span>] &lt; data[j])&#123;      heap[<span class="hljs-number">1</span>] = data[j]      heapify(heap,k,<span class="hljs-number">1</span>)    &#125;  &#125;  heap.shift()  <span class="hljs-keyword">return</span> heap&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildHeap</span>(<span class="hljs-params">items ,heapSize</span>)</span>&#123;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(heapSize/<span class="hljs-number">2</span>) ; i &gt;= <span class="hljs-number">1</span> ; i--)&#123;    heapify(items,heapSize,i)  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">items,heapSize,i</span>)</span>&#123;  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;    <span class="hljs-keyword">let</span> minIndex = i    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i &lt;= heapSize &amp;&amp; items[minIndex] &gt; items[i*<span class="hljs-number">2</span>] ) &#123;        <span class="hljs-comment">// 这里的等号意味着万一这个节点是最后的节点呢</span>        minIndex = i*<span class="hljs-number">2</span>;      &#125;      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; items[minIndex] &gt; items[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] ) &#123;        minIndex = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;      &#125;      <span class="hljs-keyword">if</span> (minIndex === i) <span class="hljs-keyword">break</span>;      [items[i],items[minIndex]] = [items[minIndex],items[i]]      i = minIndex;   &#125;&#125;</code></pre></div></li></ul><h3 id="中位数问题"><a href="#中位数问题" class="headerlink" title="中位数问题"></a>中位数问题</h3><p><code>n</code>个数据中的中位数</p><div class="hljs code-wrapper"><pre><code>  [1,2,3] =&gt; 2  [1,2,3,4] =&gt; 2,3  当 n % 2 !== 0 时，中位数为：arr[(n-1)/2]  当 n % 2 === 0 时，中位数为：arr[n/2], arr[n/2 + 1]</code></pre></div><ul><li><p>将前<code>n/2//偶数</code>||<code>（Math.floor(n/2)）+ 1//奇数</code>堆化为大顶堆，后<code>Math.floor(n/2)</code>堆化为小顶堆。</p></li><li><p>结果分别为两个堆顶<code>偶数</code>/前面的堆顶<code>奇数</code></p></li><li><p>动态数组，则把插入的数据与堆顶比较</p><ul><li>【升序】大于大顶堆的顶则加入小顶堆</li><li>【降序】小于小顶堆则加入大顶堆</li><li> 加入后再次堆化，如果堆大小不满足分割中位数要求则继续调整</li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Median</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.maxHeap = <span class="hljs-keyword">new</span> MaxHeap()  <span class="hljs-built_in">this</span>.minHeap = <span class="hljs-keyword">new</span> MinHeap()&#125;Median.prototype.addNum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>)</span>&#123;  <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-built_in">this</span>.maxHeap.getTop() || !<span class="hljs-built_in">this</span>.maxHeap.getSize())&#123;    <span class="hljs-built_in">this</span>.maxHeap.insert(num)  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-built_in">this</span>.minHeap.insert(num)  &#125;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.maxHeap.getSize() - <span class="hljs-built_in">this</span>.minHeap.getSize() &gt; <span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">//奇数分布</span>    <span class="hljs-comment">//大顶堆size比小顶堆大1</span>    <span class="hljs-built_in">this</span>.minHeap.insert(<span class="hljs-built_in">this</span>.maxHeap.rmTop())    <span class="hljs-comment">//不符合则大顶堆顶插入小顶堆</span>  &#125;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.minHeap.getSize() &gt; <span class="hljs-built_in">this</span>.maxHeap.getSize())&#123;    <span class="hljs-built_in">this</span>.maxHeap.insert(<span class="hljs-built_in">this</span>.minHeap.rmTop())    <span class="hljs-comment">// </span>  &#125;&#125;Median.prototype.getMedianNum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-comment">// return console.log(this.maxHeap.getSize());</span>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.maxHeap.getSize() &amp;&amp; <span class="hljs-built_in">this</span>.maxHeap.getSize() === <span class="hljs-built_in">this</span>.minHeap.getSize())&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.maxHeap.getTop() + <span class="hljs-built_in">this</span>.minHeap.getTop())/<span class="hljs-number">2</span>  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.maxHeap.getTop()&#125;<span class="hljs-comment">// 大顶堆</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MaxHeap</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">const</span> heap = [,]  <span class="hljs-built_in">this</span>.getSize = <span class="hljs-function">() =&gt;</span> heap.length - <span class="hljs-number">1</span>  <span class="hljs-built_in">this</span>.getTop = <span class="hljs-function">() =&gt;</span> heap.length &gt; <span class="hljs-number">1</span> ? heap[<span class="hljs-number">1</span>] : <span class="hljs-literal">null</span>  <span class="hljs-built_in">this</span>.insert = <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;    <span class="hljs-comment">//插入式建堆</span>    heap.push(num)    <span class="hljs-keyword">let</span> i = heap.length - <span class="hljs-number">1</span>    <span class="hljs-comment">// push 进去的索引</span>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)&gt;<span class="hljs-number">0</span> &amp;&amp; heap[i] &gt; heap[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)])&#123;      <span class="hljs-comment">// 大顶堆，与父节点比较，大于则交换</span>      [heap[i],heap[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)]] = [heap[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)],heap[i]]      i = <span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)    &#125;  &#125;  <span class="hljs-built_in">this</span>.rmTop = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(!heap.length &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>    <span class="hljs-keyword">if</span>(heap.length === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> heap.pop()    <span class="hljs-keyword">const</span> num = heap[<span class="hljs-number">1</span>]    heap[<span class="hljs-number">1</span>] = heap.pop()<span class="hljs-comment">// 拿走了top值，并用末尾节点填充</span>    heapify(<span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> num  &#125;  <span class="hljs-keyword">const</span> heapify = <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> &#123;    <span class="hljs-comment">// 堆化</span>    <span class="hljs-keyword">const</span> heapSize = heap.length - <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;      <span class="hljs-keyword">let</span> maxIndex = i      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; heap[<span class="hljs-number">2</span>*i] &gt; heap[i]) maxIndex = <span class="hljs-number">2</span>*i      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; heap[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>] &gt; heap[maxIndex]) maxIndex = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> <span class="hljs-comment">// !!!!!!</span>      <span class="hljs-keyword">if</span>(maxIndex === i) <span class="hljs-keyword">break</span>      [heap[i],heap[maxIndex]] = [heap[maxIndex],heap[i]]      <span class="hljs-comment">// 重新赋值i开始下级循环</span>      i = maxIndex    &#125;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MinHeap</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">const</span> heap = [,]  <span class="hljs-built_in">this</span>.getSize = <span class="hljs-function">() =&gt;</span> heap.length - <span class="hljs-number">1</span>  <span class="hljs-built_in">this</span>.getTop = <span class="hljs-function">() =&gt;</span> heap.length &gt; <span class="hljs-number">1</span> ? heap[<span class="hljs-number">1</span>] : <span class="hljs-literal">null</span>  <span class="hljs-built_in">this</span>.insert = <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;    heap.push(num)    <span class="hljs-keyword">let</span> i = heap.length - <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)&gt;<span class="hljs-number">0</span> &amp;&amp; heap[i] &lt; heap[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)])&#123;      <span class="hljs-comment">// 小顶堆，与父节点比较，小于则交换</span>      [heap[i],heap[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)]] = [heap[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)],heap[i]]      i = <span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)    &#125;  &#125;  <span class="hljs-built_in">this</span>.rmTop = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(!heap.length&gt;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>    <span class="hljs-keyword">if</span>(heap.length === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> heap.pop()    <span class="hljs-keyword">const</span> num = heap[<span class="hljs-number">1</span>]    heap[<span class="hljs-number">1</span>] = heap.pop()    heapify(<span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> num  &#125;  heapify = <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> heapSize = heap.length - <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;      <span class="hljs-keyword">let</span> minIndex = i      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; heap[<span class="hljs-number">2</span>*i] &lt; heap[i]) minIndex = <span class="hljs-number">2</span>*i      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; heap[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>] &lt; heap[minIndex]) minIndex = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>      <span class="hljs-keyword">if</span>(minIndex === i) <span class="hljs-keyword">break</span>      [heap[i],heap[minIndex]] = [heap[minIndex],heap[i]]      <span class="hljs-comment">// 重新赋值i开始下级循环</span>      i = minIndex    &#125;  &#125;&#125;<span class="hljs-comment">// 二分查找法</span><span class="hljs-keyword">const</span> MedianFinder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.data = []&#125;MedianFinder.prototype.addMun = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>)</span>&#123;  <span class="hljs-keyword">const</span> data = <span class="hljs-built_in">this</span>.data  <span class="hljs-keyword">if</span>(data.length&lt;<span class="hljs-number">1</span>)&#123;    data.push(num)    <span class="hljs-keyword">return</span>   &#125;  <span class="hljs-keyword">let</span> L = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> R = data.length - <span class="hljs-number">1</span>  <span class="hljs-keyword">while</span>(L&lt;=R)&#123;    <span class="hljs-keyword">let</span> M = <span class="hljs-built_in">Math</span>.floor((L+R)/<span class="hljs-number">2</span>)    <span class="hljs-keyword">if</span>(data[M]===num)&#123;      data.splice(M,<span class="hljs-number">0</span>,num)      <span class="hljs-keyword">return</span>     &#125;    <span class="hljs-keyword">if</span>(data[M]&lt;num)&#123;      L ++    &#125;<span class="hljs-keyword">else</span>&#123;      R --    &#125;  &#125;  data.splice(R+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,num)&#125;MedianFinder.prototype.findMedian = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> len = <span class="hljs-built_in">this</span>.data.length  <span class="hljs-keyword">if</span>(!len) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor((len-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>)  <span class="hljs-keyword">if</span>(len%<span class="hljs-number">2</span>===<span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.data[mid]+ <span class="hljs-built_in">this</span>.data[mid+<span class="hljs-number">1</span>])/<span class="hljs-number">2</span>  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.data[mid]  &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 二分查找元素</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binaryFind</span>(<span class="hljs-params">arr,target,s=<span class="hljs-number">0</span>,e=arr.length-<span class="hljs-number">1</span></span>)</span>&#123;  <span class="hljs-keyword">const</span> i  = <span class="hljs-built_in">Math</span>.floor((s+e)/<span class="hljs-number">2</span>)  <span class="hljs-keyword">if</span>(arr[i]===target)&#123;    <span class="hljs-keyword">return</span> i  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[i]&gt;target)&#123;    <span class="hljs-keyword">return</span> binaryFind(arr,target,s,i-<span class="hljs-number">1</span>)  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[i]&lt;target)&#123;    <span class="hljs-keyword">return</span> binaryFind(arr,target,i+<span class="hljs-number">1</span>,e)  &#125;  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binaryFind2</span>(<span class="hljs-params">arr,target</span>)</span>&#123;  <span class="hljs-keyword">let</span> s = <span class="hljs-number">0</span>,e = arr.length-<span class="hljs-number">1</span>,mid  <span class="hljs-keyword">while</span>(s&lt;=e)&#123;    mid = <span class="hljs-built_in">Math</span>.floor((s+e)/<span class="hljs-number">2</span>)    <span class="hljs-keyword">if</span>(arr[mid] === target)&#123;      <span class="hljs-keyword">return</span> mid    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &gt; target)&#123;      e = mid - <span class="hljs-number">1</span>     &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &lt; target)&#123;      s = mid + <span class="hljs-number">1</span>    &#125;  &#125;  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>&#125;<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<span class="hljs-built_in">console</span>.log(binaryFind2(arr,<span class="hljs-number">9</span>));</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2020/08/28/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/08/28/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="树型结构"><a href="#树型结构" class="headerlink" title="树型结构"></a>树型结构</h2><ul><li><p>节点不能闭环</p></li><li><p>只有一个根节点</p></li><li><p>除了根节点，每个节点有且只有一个父节点</p></li><li><p>深度：节点到根节点的最长路径经过节点个数</p></li><li><p>高度：节点到叶节点最长路径经过节点个数</p></li><li><p>树的高度：根节点到叶节点的最长路径经过节点个数</p></li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>最多只有两个子节点的树结构</p><ul><li>平衡二叉树</li><li>满二叉树</li><li>完全二叉树</li></ul><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BinaryTree</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> Node = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;    <span class="hljs-built_in">this</span>.val = val    <span class="hljs-built_in">this</span>.left = <span class="hljs-literal">null</span>    <span class="hljs-built_in">this</span>.right = <span class="hljs-literal">null</span>  &#125;  <span class="hljs-keyword">let</span> root = <span class="hljs-literal">null</span>&#125;</code></pre></div><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preOrderTraverse</span>(<span class="hljs-params">node</span>)</span>&#123;  <span class="hljs-keyword">let</span> res = []  <span class="hljs-keyword">let</span> stack = []  <span class="hljs-keyword">if</span>(node) stack.push(node)  <span class="hljs-keyword">while</span>(stack.length&gt;<span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">let</span> curNode  = stack.pop()    res.push(curNode.val)    <span class="hljs-keyword">if</span>(curNode.right!==<span class="hljs-literal">null</span>)&#123;      stack.push(curNode.right)    &#125;    <span class="hljs-keyword">if</span>(curNode.left!==<span class="hljs-literal">null</span>)&#123;      stack.push(curNode.left)    &#125;  &#125;  <span class="hljs-keyword">return</span> res&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈算法题</title>
    <link href="/2020/08/27/%E6%A0%88%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2020/08/27/%E6%A0%88%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="栈结构，先进后出"><a href="#栈结构，先进后出" class="headerlink" title="栈结构，先进后出"></a>栈结构，先进后出</h2><ul><li><p>最小栈</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MinStack</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.stack = []  <span class="hljs-built_in">this</span>.min = <span class="hljs-literal">null</span>&#125;MinStack.prototype.push = <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.stack.length)&#123;    <span class="hljs-built_in">this</span>.min = item  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-built_in">this</span>.min = <span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">this</span>.min,item)  &#125;  <span class="hljs-built_in">this</span>.stack.push(item)&#125;MinStack.prototype.pop = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> item  = <span class="hljs-built_in">this</span>.stack.pop()  <span class="hljs-built_in">this</span>.min = <span class="hljs-built_in">Math</span>.min(...this.stack)  <span class="hljs-keyword">return</span> item&#125;MinStack.prototype.top = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.stack.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stack[<span class="hljs-built_in">this</span>.stack.length-<span class="hljs-number">1</span>]&#125;MinStack.prototype.getMin = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.min&#125;</code></pre></div></li><li><p>判断括号是否闭合</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// ()</span><span class="hljs-comment">// []</span><span class="hljs-comment">// &#123;&#125;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bracketCheck</span>(<span class="hljs-params">str</span>)</span>&#123;  <span class="hljs-keyword">const</span> brackets = &#123;    <span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-string">&#x27;)&#x27;</span>,    <span class="hljs-string">&#x27;&#123;&#x27;</span>:<span class="hljs-string">&#x27;&#125;&#x27;</span>,    <span class="hljs-string">&#x27;[&#x27;</span>:<span class="hljs-string">&#x27;]&#x27;</span>  &#125;  <span class="hljs-keyword">let</span> stack = []  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ;i&lt;str.length;i++)&#123;    <span class="hljs-keyword">if</span>(brackets[str[i]])&#123;      stack.push([str[i]])    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[i] !== brackets[stack.pop()])&#123;      <span class="hljs-comment">// 这个写法6⃣️啊</span>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;  &#125;  <span class="hljs-keyword">return</span> stack.length === <span class="hljs-number">0</span>&#125;</code></pre></div><ul><li>删除字符串内相邻重复项<div class="hljs code-wrapper"><pre><code class="hljs javascript">给出由小写字母组成的字符串 S ，重复项删除操作 会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delDup</span>(<span class="hljs-params">S</span>)</span>&#123;  <span class="hljs-keyword">let</span> stack = [],pre = <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> c <span class="hljs-keyword">of</span> S)&#123;    pre = stack.pop()    <span class="hljs-keyword">if</span>(c !== pre)&#123;      stack.push(pre)      stack.push(c)    &#125;  &#125;  <span class="hljs-keyword">return</span> stack.join(<span class="hljs-string">&#x27;&#x27;</span>)&#125;</code></pre></div></li></ul><ul><li>滑动窗口最大值<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// k 为窗口大小</span><span class="hljs-comment">// window存储数组索引</span><span class="hljs-comment">// 每次循环判断窗口长度</span><span class="hljs-comment">// 每次循环将arr[i]与窗口内值比较</span><span class="hljs-comment">// 保证最大值索引在窗口最左边</span><span class="hljs-comment">// 依次移动窗口，输出索引到res数组</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxInSlideWin</span>(<span class="hljs-params">arr,k</span>)</span>&#123;  <span class="hljs-keyword">let</span> res = []  <span class="hljs-keyword">let</span> <span class="hljs-built_in">window</span> = []  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; arr.length ; i++)&#123;    <span class="hljs-keyword">if</span>(i-<span class="hljs-built_in">window</span>[<span class="hljs-number">0</span>]&gt;=k)&#123;      <span class="hljs-built_in">window</span>.shift()    &#125;    <span class="hljs-keyword">while</span>(arr[<span class="hljs-built_in">window</span>[<span class="hljs-built_in">window</span>.length-<span class="hljs-number">1</span>]]&lt;=arr[i])&#123;      <span class="hljs-built_in">window</span>.pop()    &#125;    <span class="hljs-built_in">window</span>.push(i)    <span class="hljs-keyword">if</span>(i&gt;=k-<span class="hljs-number">1</span>)&#123;      res.push(arr[<span class="hljs-built_in">window</span>[<span class="hljs-number">0</span>]])    &#125;  &#125;  <span class="hljs-keyword">return</span> res&#125;</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作字符串算法题</title>
    <link href="/2020/08/27/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2020/08/27/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ul><li><p>寻找最长公公前缀</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><span class="hljs-comment">// 输出: &quot;fl&quot;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commonPrefix</span>(<span class="hljs-params">...strs</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!strs.length || strs.length===<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>  <span class="hljs-keyword">let</span> ref = strs[<span class="hljs-number">0</span>]  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;i&lt;strs.length;i++)&#123;    <span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span>(;j&lt;ref.length &amp;&amp; j&lt;strs[i].length;j++)&#123;      <span class="hljs-keyword">if</span>(ref.chartAt(j)!==strs[i].chartAt(j)) <span class="hljs-keyword">break</span>    &#125;    ref = ref.subString(<span class="hljs-number">0</span>,j)  &#125;  <span class="hljs-keyword">return</span> ref&#125;</code></pre></div></li><li><p>连字符转为驼峰</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hump</span>(<span class="hljs-params">str</span>)</span>&#123;  <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/-\w/g</span>,$<span class="hljs-number">1</span>=&gt;&#123;    <span class="hljs-keyword">return</span> $<span class="hljs-number">1.</span>slice(<span class="hljs-number">1</span>).toUpperCase()  &#125;)&#125;</code></pre></div></li></ul><ul><li>将字符串改为首字母大写<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//-i-hate -_you_</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Upper</span>(<span class="hljs-params">str</span>)</span>&#123;  <span class="hljs-keyword">let</span> rule = <span class="hljs-regexp">/\b_?(\w)/g</span>  <span class="hljs-keyword">return</span> str.replace(rule,($<span class="hljs-number">1</span>=&gt;&#123;    <span class="hljs-keyword">return</span> $<span class="hljs-number">1.</span>toUpperCase()  &#125;))&#125;</code></pre></div></li></ul><ul><li>反转句子<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//  正则</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseWords</span>(<span class="hljs-params">str</span>)</span>&#123;  <span class="hljs-keyword">return</span> str.trim().replace(<span class="hljs-regexp">/\s+/g</span>,<span class="hljs-string">&#x27; &#x27;</span>).split(<span class="hljs-string">&#x27; &#x27;</span>).reverse().join(<span class="hljs-string">&#x27; &#x27;</span>)  <span class="hljs-comment">// \s \s是指空白,包括空格、换行、tab缩进等所有的空白</span>  <span class="hljs-comment">// 去除单词之间多余的空白</span>&#125;<span class="hljs-comment">//</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseWords</span>(<span class="hljs-params">str</span>)</span>&#123;  <span class="hljs-keyword">let</span> arr = []  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> right = str.length-<span class="hljs-number">1</span>  <span class="hljs-keyword">let</span> word = <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-keyword">while</span>(str.charAt(str)===<span class="hljs-string">&#x27; &#x27;</span>) left++  <span class="hljs-keyword">while</span>(str.charAt(str)===<span class="hljs-string">&#x27; &#x27;</span>) right--  <span class="hljs-comment">// 去除头尾多余空格</span>  <span class="hljs-keyword">while</span>(left&lt;=right)&#123;    <span class="hljs-keyword">let</span> char = str.charAt(left)    <span class="hljs-keyword">if</span>(char===<span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; word)&#123;      arr.unshift(word)      word = <span class="hljs-string">&#x27;&#x27;</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(char!== <span class="hljs-string">&#x27; &#x27;</span>)&#123;      word += char    &#125;    left ++  &#125;  arr.unshift(word)  <span class="hljs-keyword">return</span> arr.join(<span class="hljs-string">&#x27; &#x27;</span>)&#125;</code></pre></div></li></ul><ul><li>检查回文</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseCheck</span>(<span class="hljs-params">str</span>)</span>&#123;  <span class="hljs-keyword">let</span> s = str.toLowerCase().replace(<span class="hljs-regexp">/[\W_]/g</span>,<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment">// 格式掉不是字母的别的玩意</span>  <span class="hljs-comment">// | `\W`   | 匹配任意不是字母，数字，下划线 |</span>  <span class="hljs-comment">// `[]` 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思</span>  <span class="hljs-keyword">return</span> s === s.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>)&#125;</code></pre></div><ul><li>计算最长不重复字符串</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">longestStr</span>(<span class="hljs-params">str</span>)</span>&#123;  <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(),maxLength = <span class="hljs-number">0</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; j = <span class="hljs-number">0</span>;j&lt;str.length;j++)&#123;    <span class="hljs-keyword">if</span>(map.has(str[j]))&#123;      i = <span class="hljs-built_in">Math</span>.max(map.get(str[j])+<span class="hljs-number">1</span>,i)    &#125;    maxLength = <span class="hljs-built_in">Math</span>.max(j-i+<span class="hljs-number">1</span>,maxLength)    map.set(str[j],j)  &#125;  <span class="hljs-keyword">return</span> maxLength&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">longestStr2</span>(<span class="hljs-params">str</span>)</span>&#123;  <span class="hljs-keyword">let</span> arr = [],maxLen = <span class="hljs-number">0</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i&lt;str.length;i++)&#123;    <span class="hljs-keyword">let</span> index = arr.indexOf(str[i])    <span class="hljs-keyword">if</span>(index!==-<span class="hljs-number">1</span>)&#123;      arr.splice(<span class="hljs-number">0</span>,index+<span class="hljs-number">1</span>)      <span class="hljs-comment">// splice() 方法向/从数组中添加/删除项目,然后返回被删除的项目</span>    &#125;    arr.push(str[i])    maxLen = <span class="hljs-built_in">Math</span>.max(maxLen,arr.length)    <span class="hljs-comment">// 取最大值！！</span>    <span class="hljs-comment">// 最长的字符串不一定从头就开始出现</span>  &#125;  <span class="hljs-keyword">return</span> maxLen&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2020/08/27/%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/08/27/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>数组需要申请连续的内存空间，链表可以使用“零散的”内存空间</li><li>插入/删除时间复杂度<code>O(1)</code></li><li>随机访问时间复杂度<code>O(n)</code></li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul><li>零散的内存块称为<code>结点</code></li><li>记录下一个结点地址的指针叫做<code>后继指针next</code></li><li><code>headNode</code></li><li><code>tailNode.next = null</code></li></ul><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><ul><li>单链表</li><li>循环链表</li></ul><p>  <code>tailNode.next = headNode</code></p><p>  适合处理环状结构的数据</p><ul><li><p>双向链表</p><p>结点拥有两个指针<br><code>curNode.prev</code><br><code>curNode.next</code></p><p><code>O(1)</code>时间复杂度即可访问前序结点</p></li><li><p>双向循环链表</p><p><code>headNode.prev = tailNode</code><br><code>tailNode.next = headNode</code></p></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 单向链表</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">linkedList</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span>;    <span class="hljs-built_in">this</span>.length = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-comment">// 追加</span>  <span class="hljs-function"><span class="hljs-title">append</span>(<span class="hljs-params">element</span>)</span> &#123;    <span class="hljs-keyword">const</span> n = <span class="hljs-keyword">new</span> Node(element);    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head;    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.head) &#123;      <span class="hljs-built_in">this</span>.head = n;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">while</span> (cur.next) &#123;        cur = cur.next;      &#125;      cur.next = n;      <span class="hljs-built_in">this</span>.length++;    &#125;  &#125;  <span class="hljs-comment">// 查找</span>  <span class="hljs-function"><span class="hljs-title">search</span>(<span class="hljs-params">element</span>)</span> &#123;    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head;    <span class="hljs-keyword">if</span> (!cur) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">while</span> (cur) &#123;      <span class="hljs-keyword">if</span> (cur.element === element) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      &#125;      cur = cur.next;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// 插入</span>  <span class="hljs-comment">// position之前插入新node</span>  <span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">position, element</span>)</span> &#123;    <span class="hljs-keyword">if</span> (position &gt;= <span class="hljs-number">0</span> &amp;&amp; position &lt;= <span class="hljs-built_in">this</span>.length) &#123;      <span class="hljs-keyword">let</span> n = <span class="hljs-keyword">new</span> Node(element);      <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) &#123;        n.next = <span class="hljs-built_in">this</span>.head;        <span class="hljs-built_in">this</span>.head = n;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head,pre        <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (index &lt; position) &#123;          pre = cur;          cur = cur.next;          index++;        &#125;        pre.next = n;        n.next = cur;      &#125;      <span class="hljs-built_in">this</span>.length++;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;  &#125;  <span class="hljs-comment">// 删除</span>  <span class="hljs-function"><span class="hljs-title">remove</span>(<span class="hljs-params">element</span>)</span> &#123;    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head,      pre = <span class="hljs-built_in">this</span>.head    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    <span class="hljs-keyword">while</span> (cur) &#123;      <span class="hljs-keyword">if</span> (cur.element === element) &#123;        cur = cur.next;        pre.next = cur;        <span class="hljs-built_in">this</span>.length --       &#125;      pre = cur      cur = cur.next;    &#125;  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">element</span>)</span> &#123;    <span class="hljs-built_in">this</span>.element = element;    <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;  &#125;&#125;<span class="hljs-comment">// 双向链表</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DubLinkedList</span>(<span class="hljs-params">params</span>) </span>&#123;  <span class="hljs-keyword">const</span> Node = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>&#123;    <span class="hljs-built_in">this</span>.prev = <span class="hljs-literal">null</span>;    <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;    <span class="hljs-built_in">this</span>.element = element;  &#125;;  <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span>;  <span class="hljs-built_in">this</span>.tail = <span class="hljs-literal">null</span>;  <span class="hljs-built_in">this</span>.length = <span class="hljs-number">0</span>;  <span class="hljs-built_in">this</span>.append = <span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> newNode = <span class="hljs-keyword">new</span> Node(element);    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head;    <span class="hljs-keyword">if</span> (!cur) &#123;      <span class="hljs-built_in">this</span>.head = newNode;      <span class="hljs-built_in">this</span>.tail = newNode;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">while</span> (cur.next) &#123;        cur = cur.next;      &#125;      cur.next = newNode      newNode.prev = cur      <span class="hljs-built_in">this</span>.tail = newNode    &#125;    <span class="hljs-built_in">this</span>.length++;  &#125;  <span class="hljs-built_in">this</span>.insert = <span class="hljs-function">(<span class="hljs-params">position,element</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(position&gt;=<span class="hljs-number">0</span> &amp;&amp; position &lt;=<span class="hljs-built_in">this</span>.length)&#123;      <span class="hljs-keyword">let</span> newNode = <span class="hljs-keyword">new</span> Node(element)      <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head,pre      <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>      <span class="hljs-keyword">if</span>(position===<span class="hljs-number">0</span>)&#123;        <span class="hljs-comment">//头</span>        <span class="hljs-keyword">if</span>(!cur)&#123;          <span class="hljs-built_in">this</span>.head = newNode;          <span class="hljs-built_in">this</span>.tail = newNode;        &#125;<span class="hljs-keyword">else</span>&#123;          newNode.next = <span class="hljs-built_in">this</span>.head          cur.prev = newNode          <span class="hljs-built_in">this</span>.head = newNode        &#125;      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(position===<span class="hljs-built_in">this</span>.length)&#123;        <span class="hljs-comment">//尾巴</span>        cur = <span class="hljs-built_in">this</span>.tail        cur.prev = newNode        newNode.next = cur        <span class="hljs-built_in">this</span>.tail = newNode      &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">while</span>(index&lt;position)&#123;          pre = cur          cur = cur.next          index++        &#125;        cur.prev = newNode        pre.next = newNode        newNode.next = cur        newNode.prev = pre      &#125;      <span class="hljs-built_in">this</span>.length ++    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;  &#125;  <span class="hljs-built_in">this</span>.remove = <span class="hljs-function"><span class="hljs-params">position</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(position&gt;=<span class="hljs-number">0</span> &amp;&amp; position&lt;<span class="hljs-built_in">this</span>.length &amp;&amp; <span class="hljs-built_in">this</span>.length&gt;<span class="hljs-number">0</span>)&#123;      <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head,pre,index = <span class="hljs-number">0</span>      <span class="hljs-keyword">if</span>(position===<span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.length === <span class="hljs-number">1</span>)&#123;          <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span>          <span class="hljs-built_in">this</span>.tail = <span class="hljs-literal">null</span>        &#125;<span class="hljs-keyword">else</span>&#123;          cur = cur.next          cur.prev = <span class="hljs-literal">null</span>          <span class="hljs-built_in">this</span>.head = cur        &#125;      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(position===<span class="hljs-built_in">this</span>.length-<span class="hljs-number">1</span>)&#123;        cur = <span class="hljs-built_in">this</span>.tail        pre = cur.prev        pre.next = <span class="hljs-literal">null</span>        <span class="hljs-built_in">this</span>.tail = pre      &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">while</span>(index&lt;position)&#123;          pre = cur          cur = cur.next          index ++        &#125;        cur = cur.next        pre.next = cur        cur.prev = pre      &#125;      <span class="hljs-built_in">this</span>.length --      <span class="hljs-keyword">return</span> cur.element    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>    &#125;  &#125;  <span class="hljs-built_in">this</span>.search = <span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span>&#123;    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head    <span class="hljs-keyword">while</span>(cur)&#123;      <span class="hljs-keyword">if</span>(cur.element === element)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>      &#125;      cur = cur.next    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  &#125;&#125;</code></pre></div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="注意边界情况"><a href="#注意边界情况" class="headerlink" title="注意边界情况"></a>注意边界情况</h3><ul><li>链表为空</li><li>链表只有一个结点</li><li>链表只有两个结点</li><li>处理头部结点和尾部结点</li></ul><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul><li><p>单链表反转</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseLinkedList</span>(<span class="hljs-params">head</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  <span class="hljs-keyword">if</span>(!head.next) <span class="hljs-keyword">return</span> head  <span class="hljs-keyword">let</span> cur = head  <span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>  <span class="hljs-keyword">let</span> nex = head.next  <span class="hljs-keyword">while</span>(nex)&#123;    <span class="hljs-comment">// 当指针没到尾部时</span>    <span class="hljs-comment">//</span>    cur.next = pre <span class="hljs-comment">// 反转指针</span>    <span class="hljs-comment">//</span>    pre = cur    cur = nex    nex = cur.next  &#125;&#125;</code></pre></div></li><li><p>检测链表是否循环</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//</span><span class="hljs-built_in">JSON</span>.stringify() <span class="hljs-comment">//不能序列化循环链表</span><span class="hljs-comment">//标记</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isLoop</span>(<span class="hljs-params">head</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-keyword">let</span> cur = head  <span class="hljs-keyword">while</span>(cur)&#123;    <span class="hljs-keyword">if</span>(cur.flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    cur.flag = <span class="hljs-literal">true</span>    cur = cur.next  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-comment">// 快慢指针</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isLoop2</span>(<span class="hljs-params">head</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!head || !head.next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-keyword">let</span> fast = head.next.next  <span class="hljs-keyword">let</span> slow = head.next  <span class="hljs-keyword">while</span>(slow!==fast)&#123;    <span class="hljs-keyword">if</span>(!fast || !fast.next)&#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    fast = fast.next.next    slow = slow.next  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre></div></li><li><p>合并两个有序链表</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeLinkedList</span>(<span class="hljs-params">head1,head2</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!head1.value) <span class="hljs-keyword">return</span> head2  <span class="hljs-keyword">if</span>(!head2.value) <span class="hljs-keyword">return</span> head1  <span class="hljs-keyword">if</span>(head1.value&lt;=head2.value)&#123;    head1.next = mergeLinkedList(head1.next,head2)    <span class="hljs-keyword">return</span> head1  &#125;<span class="hljs-keyword">else</span>&#123;    head2.next = mergeLinkedList(head2.next,head1)    <span class="hljs-keyword">return</span> head2  &#125;&#125;</code></pre></div></li></ul><ul><li><p>实现LRU缓存淘汰策略</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">value</span>)</span>&#123;  <span class="hljs-built_in">this</span>.value = value  <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LRULinkedList</span>(<span class="hljs-params">maxSize</span>)</span>&#123;  <span class="hljs-built_in">this</span>.maxSize = maxSize  <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span>  <span class="hljs-built_in">this</span>.curSize = <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>.visit = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> n = <span class="hljs-keyword">new</span> Node(value)    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head,pre = <span class="hljs-built_in">this</span>.head    <span class="hljs-keyword">let</span> preCatch,curCatch    <span class="hljs-keyword">if</span>(!cur)&#123;      <span class="hljs-built_in">this</span>.head = n      <span class="hljs-built_in">this</span>.curSize = <span class="hljs-number">1</span>      <span class="hljs-keyword">return</span>     &#125;    <span class="hljs-keyword">if</span>(cur.value===value) <span class="hljs-keyword">return</span>     <span class="hljs-keyword">while</span>(cur)&#123;      <span class="hljs-keyword">if</span>(cur.value === value)&#123;          <span class="hljs-comment">// 找到了</span>          <span class="hljs-comment">// 从原来位置删除并作为头</span>          pre.next = cur.next          cur.next = <span class="hljs-built_in">this</span>.head          <span class="hljs-keyword">return</span>      &#125;      preCatch = pre      curCatch = cur      pre = cur      cur = cur.next    &#125;    <span class="hljs-comment">// 没找到</span>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.curSize&lt;maxSize)&#123;      <span class="hljs-comment">// 插入头部</span>      n.next = <span class="hljs-built_in">this</span>.head      <span class="hljs-built_in">this</span>.head = n      <span class="hljs-built_in">this</span>.curSize ++    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">// 删除尾部结点</span>      <span class="hljs-comment">// 插入头部</span>      preCatch.next = <span class="hljs-literal">null</span>      curCatch.next = <span class="hljs-built_in">this</span>.head      <span class="hljs-built_in">this</span>.head = curCatch    &#125;  &#125;&#125;</code></pre></div></li><li><p>字符串回文检查，字符串存储在有序链表中，怎么判断</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 单向链表</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseStrCheck</span>(<span class="hljs-params">head</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-keyword">if</span>(!head.next) <span class="hljs-keyword">return</span> head  <span class="hljs-keyword">let</span> fast = head  <span class="hljs-keyword">let</span> slow = head  <span class="hljs-keyword">let</span> pre = head  <span class="hljs-comment">// 快慢指针找出中位置</span>  <span class="hljs-comment">// 慢指针边移动边改变指针方向</span>  <span class="hljs-comment">// fast指针到头后，中位值同时正反向移动判断值是否相等</span>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span>    <span class="hljs-comment">// 缓存住当前的cur.next</span>  <span class="hljs-comment">// 变换指针方向后将cur直接赋值为缓存</span>  <span class="hljs-keyword">while</span>(slow)&#123;    pre = slow    slow = slow.next    fast = fast.next.next &amp;&amp; fast.next ? fast.next.next : fast.next    <span class="hljs-keyword">if</span>(!fast)&#123;      <span class="hljs-comment">//到头</span>      <span class="hljs-comment">//开始反向移动</span>    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre></div></li><li><p>合并两个有序链表</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1-&gt;2-&gt;4,1-&gt;3-&gt;4</span><span class="hljs-comment">// 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeLinkedList</span>(<span class="hljs-params">l1,l2</span>)</span>&#123;  <span class="hljs-keyword">if</span>(l1===<span class="hljs-literal">null</span>)&#123;    <span class="hljs-keyword">return</span> l2  &#125;  <span class="hljs-keyword">if</span>(l2===<span class="hljs-literal">null</span>)&#123;    <span class="hljs-keyword">return</span> l1  &#125;  <span class="hljs-keyword">if</span>(l1.value&lt;=l2.value)&#123;    l1.next = mergeLinkedList(l1.next,l2)    <span class="hljs-keyword">return</span> l1  &#125;<span class="hljs-keyword">else</span>&#123;    l2.next = mergeLinkedList(l2.next,l1)    <span class="hljs-keyword">return</span> l2  &#125;&#125;</code></pre></div></li><li><p>查找两个链表的公共起始点</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commonPrefix</span>(<span class="hljs-params">headA,headB</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!headA || !headB) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  <span class="hljs-keyword">while</span>(headA)&#123;    headA.flag = <span class="hljs-literal">true</span>    headA = headA.next  &#125;  <span class="hljs-keyword">while</span>(headB)&#123;    <span class="hljs-keyword">if</span>(headB.flag) <span class="hljs-keyword">return</span> headB    headB.flag =<span class="hljs-literal">true</span>    headB = headB.next  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commonPrefix2</span>(<span class="hljs-params">headA,headB</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!headA || !headB) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  <span class="hljs-keyword">let</span> n1 = headA  <span class="hljs-keyword">let</span> n2 = headB  <span class="hljs-keyword">while</span>(n1 || n2)&#123;    <span class="hljs-keyword">if</span>(n1===n2) <span class="hljs-keyword">return</span> n1    n1 = n1 === <span class="hljs-literal">null</span> ? headB : n1.next    n2 = n2 === <span class="hljs-literal">null</span> ? headA : n2.next  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>&#125;</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>待整理的js片段</title>
    <link href="/2020/08/17/js%E7%89%87%E6%AE%B5/"/>
    <url>/2020/08/17/js%E7%89%87%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<ul><li>字母的所有组合</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> anagrams = <span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> &#123;  <span class="hljs-keyword">if</span>(str.length&lt;=<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> str.length===<span class="hljs-number">2</span> ? [str , str[<span class="hljs-number">1</span>] + str[<span class="hljs-number">0</span>]] :str  <span class="hljs-comment">// 这里使用reduce的第三个参数index，正在处理的元素</span>  <span class="hljs-comment">// 如果提供了initialValue，则起始索引号为0，否则从索引1起始。</span>  <span class="hljs-keyword">return</span> str.split(<span class="hljs-string">&#x27;&#x27;</span>).reduce(<span class="hljs-function">(<span class="hljs-params">acc,cur,index</span>)=&gt;</span>&#123;    <span class="hljs-keyword">let</span> other = str.slice(<span class="hljs-number">0</span>,index)+str.slice(index+<span class="hljs-number">1</span>)    <span class="hljs-comment">// other为除了当前处理元素外的字母</span>    <span class="hljs-comment">// a bcd =&gt;</span>    <span class="hljs-comment">// b cd =&gt; bcd bdc</span>    <span class="hljs-comment">// c bd =&gt; cbd cdb</span>    <span class="hljs-comment">// d bc =&gt; dbc dcb</span>    <span class="hljs-comment">// b...</span>    <span class="hljs-keyword">return</span> acc.concat(anagrams(other).map(<span class="hljs-function"><span class="hljs-params">char</span>=&gt;</span>cur+char))    <span class="hljs-comment">// 递归至两位数数组颠倒排序,并将所有可能与当前处理元素组合</span>  &#125;,[])  <span class="hljs-comment">// 指定initialValue</span>&#125;anagrams(<span class="hljs-string">&#x27;abcd&#x27;</span>) =&gt; [  <span class="hljs-string">&#x27;abcd&#x27;</span>, <span class="hljs-string">&#x27;abdc&#x27;</span>, <span class="hljs-string">&#x27;acbd&#x27;</span>,  <span class="hljs-string">&#x27;acdb&#x27;</span>, <span class="hljs-string">&#x27;adbc&#x27;</span>, <span class="hljs-string">&#x27;adcb&#x27;</span>,  <span class="hljs-string">&#x27;bacd&#x27;</span>, <span class="hljs-string">&#x27;badc&#x27;</span>, <span class="hljs-string">&#x27;bcad&#x27;</span>,  <span class="hljs-string">&#x27;bcda&#x27;</span>, <span class="hljs-string">&#x27;bdac&#x27;</span>, <span class="hljs-string">&#x27;bdca&#x27;</span>,  <span class="hljs-string">&#x27;cabd&#x27;</span>, <span class="hljs-string">&#x27;cadb&#x27;</span>, <span class="hljs-string">&#x27;cbad&#x27;</span>,  <span class="hljs-string">&#x27;cbda&#x27;</span>, <span class="hljs-string">&#x27;cdab&#x27;</span>, <span class="hljs-string">&#x27;cdba&#x27;</span>,  <span class="hljs-string">&#x27;dabc&#x27;</span>, <span class="hljs-string">&#x27;dacb&#x27;</span>, <span class="hljs-string">&#x27;dbac&#x27;</span>,  <span class="hljs-string">&#x27;dbca&#x27;</span>, <span class="hljs-string">&#x27;dcab&#x27;</span>, <span class="hljs-string">&#x27;dcba&#x27;</span>]</code></pre></div><ul><li>大写每个单词的首字母</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> capitalizeWords = <span class="hljs-function">(<span class="hljs-params">words</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> words.replace(<span class="hljs-regexp">/\b[a-z]/g</span>, <span class="hljs-function">(<span class="hljs-params">word</span>) =&gt;</span> word.toUpperCase());  <span class="hljs-comment">// \b匹配作为单词边界的那个字符</span>  <span class="hljs-comment">// 即匹配到了每一个单词的首字母</span>&#125;;</code></pre></div><ul><li>格式化只有首字母大写</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> capitalize = <span class="hljs-function">(<span class="hljs-params">str, lowerRest = <span class="hljs-literal">false</span></span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> (    str.slice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase() +    (lowerRest ? str.slice(<span class="hljs-number">1</span>).toLowerCase() : str.slice(<span class="hljs-number">1</span>))  );&#125;;</code></pre></div><ul><li>检查回文</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 将字符串转换为toLowerCase（），并使用replace（）从中删除非字母的字符。然后，将其转换为tolowerCase（），将（&#x27;&#x27;）拆分为单独字符，reverse（），join（&#x27;&#x27;），与原始的非反转字符串进行比较，然后将其转换为tolowerCase（）。</span><span class="hljs-keyword">const</span> palindrome = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> s = str.toLowerCase().replace(<span class="hljs-regexp">/[\W_]/g</span>, <span class="hljs-string">&quot;&quot;</span>);  <span class="hljs-comment">//匹配任意不是字母，数字，下划线 + _</span>  <span class="hljs-keyword">return</span> s === s.split(<span class="hljs-string">&quot;&quot;</span>).reverse().join(<span class="hljs-string">&quot;&quot;</span>);&#125;;<span class="hljs-comment">// palindrome(&#x27;taco cat&#x27;) -&gt; true</span></code></pre></div><ul><li>出现次数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> countOccurrences = <span class="hljs-function">(<span class="hljs-params">arr, value</span>) =&gt;</span>  arr.reduce(<span class="hljs-function">(<span class="hljs-params">a, v</span>) =&gt;</span> (v === value ? a + <span class="hljs-number">1</span> : a + <span class="hljs-number">0</span>), <span class="hljs-number">0</span>);<span class="hljs-comment">// countOccurrences([1,1,2,1,2,3], 1) -&gt; 3</span></code></pre></div><ul><li>Deep flatten array</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> deepFlatten = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span>  arr.reduce(<span class="hljs-function">(<span class="hljs-params">a, v</span>) =&gt;</span> a.concat(<span class="hljs-built_in">Array</span>.isArray(v) ? deepFlatten(v) : v), []);<span class="hljs-comment">// deepFlatten([1,[2],[[3],4],5]) -&gt; [1,2,3,4,5]</span></code></pre></div><ul><li>bifurcate</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bifurcate = <span class="hljs-function">(<span class="hljs-params">arr, filter</span>) =&gt;</span>  arr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, val, i</span>) =&gt;</span> (acc[filter[i] ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>].push(val), acc), [    [],    [],  ]);bifurcate([<span class="hljs-string">&quot;beep&quot;</span>, <span class="hljs-string">&quot;boop&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>], [<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>]);<span class="hljs-comment">// [ [&#x27;beep&#x27;, &#x27;boop&#x27;, &#x27;bar&#x27;], [&#x27;foo&#x27;] ]</span></code></pre></div><ul><li>阶乘</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> factorial = <span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> (n &lt;= <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : n * factorial(n - <span class="hljs-number">1</span>));<span class="hljs-comment">// factorial(6) -&gt; 720</span></code></pre></div><ul><li>斐波那契数组生成器</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fibonacci = <span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span>  <span class="hljs-built_in">Array</span>(n)    .fill(<span class="hljs-number">0</span>)    .reduce(      (acc, val, i) =&gt; acc.concat(i &gt; <span class="hljs-number">1</span> ? acc[i - <span class="hljs-number">1</span>] + acc[i - <span class="hljs-number">2</span>] : i),      []    );<span class="hljs-comment">// fibonacci(5) -&gt; [0,1,1,2,3]</span><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">fib</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> [pre, cur] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];  <span class="hljs-keyword">for</span> (;;) &#123;    <span class="hljs-comment">// 死循环的另一种写法</span>    <span class="hljs-comment">// while(true)</span>    [pre, cur] = [cur, cur + pre];    <span class="hljs-keyword">yield</span> cur;  &#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> fib()) &#123;  <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">100</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-built_in">console</span>.log(x);&#125;</code></pre></div><ul><li>数组中唯一值</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> filterNonUnique = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span>  arr.filter(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> arr.indexOf(i) === arr.lastIndexOf(i));<span class="hljs-comment">// filterNonUnique([1,2,2,3,4,4,5]) -&gt; [1,3,5]</span></code></pre></div><ul><li>最大公约数（GCD）</li></ul><p>使用递归。基本情况是当 y 等于 0 时。在这种情况下，返回 x。否则，返回 y 的 GCD 和 x / y 的其余部分。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> gcd = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> (!y ? x : gcd(y, x % y));<span class="hljs-comment">// gcd (8, 36) -&gt; 4</span></code></pre></div><ul><li>范围内生成数组</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> initializeArrayRange = <span class="hljs-function">(<span class="hljs-params">end, start = <span class="hljs-number">0</span></span>) =&gt;</span>  <span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">Array</span>(end - start)).map(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> i + start);<span class="hljs-comment">// initializeArrayRange(5) -&gt; [0,1,2,3,4]</span></code></pre></div><ul><li>function 计时</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> timeTaken = <span class="hljs-function">(<span class="hljs-params">callback</span>) =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.time(<span class="hljs-string">&quot;timeTaken&quot;</span>);  <span class="hljs-keyword">const</span> r = callback();  <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&quot;timeTaken&quot;</span>);  <span class="hljs-keyword">return</span> r;&#125;;<span class="hljs-comment">// timeTaken(() =&gt; Math.pow(2, 10)) -&gt; 1024</span><span class="hljs-comment">// (logged): timeTaken: 0.02099609375ms</span></code></pre></div><ul><li>打乱数组</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> shuffle = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> arr.sort(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">Math</span>.random() - <span class="hljs-number">0.5</span>);<span class="hljs-comment">// shuffle([1,2,3]) -&gt; [2,3,1]</span></code></pre></div><ul><li>RGB 转十六进制</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> rgbToHex = <span class="hljs-function">(<span class="hljs-params">r, g, b</span>) =&gt;</span>  ((r &lt;&lt; <span class="hljs-number">16</span>) + (g &lt;&lt; <span class="hljs-number">8</span>) + b).toString(<span class="hljs-number">16</span>).padStart(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-comment">// rgbToHex(255, 165, 1) -&gt; &#x27;ffa501&#x27;</span></code></pre></div><ul><li>字符串按字母排序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sortCharactersInString = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span>  str    .split(<span class="hljs-string">&quot;&quot;</span>)    .sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.localeCompare(b))    .join(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">// sortCharactersInString(&#x27;cabbage&#x27;) -&gt; &#x27;aabbceg&#x27;</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>其他算法题</title>
    <link href="/2020/08/02/%E5%88%B7%E5%88%B7%E7%AE%97%E6%B3%95/"/>
    <url>/2020/08/02/%E5%88%B7%E5%88%B7%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<ol><li>两数之合 <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">arr,target</span>)</span>&#123;  <span class="hljs-keyword">let</span> res = []  <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()  <span class="hljs-comment">// 使用数值-&gt;索引建立map</span>  <span class="hljs-comment">// 每次循环计算得出当前差值</span>  <span class="hljs-comment">// 在map中查找这个差值既能得出索引</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i&lt;arr.length;i++)&#123;    <span class="hljs-keyword">let</span> k = target <span class="hljs-number">1.</span> arr[i]    <span class="hljs-keyword">if</span>(map.has(k))&#123;      res.push([map.get(k),i])    &#125;    map.set(arr[i],i)  &#125;  <span class="hljs-keyword">return</span> res.length === <span class="hljs-number">1</span> ? res[<span class="hljs-number">0</span>] : res&#125;</code></pre></div></li></ol><ol><li><p>三数之合</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">threeSum</span>(<span class="hljs-params">arr,target</span>)</span>&#123;  <span class="hljs-keyword">let</span> res = []  <span class="hljs-keyword">let</span> len = arr.length  <span class="hljs-keyword">if</span>(len&lt;<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> res  arr = arr.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>a-b)  <span class="hljs-comment">// 按大小排序</span>  <span class="hljs-comment">// 开始循环</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i&lt; len-<span class="hljs-number">1</span>;i++)&#123;    <span class="hljs-keyword">if</span>(arr[i]&gt;=target) <span class="hljs-keyword">break</span>    <span class="hljs-comment">// 第一个值就大于target后面不用想了</span>    <span class="hljs-keyword">if</span>(arr[i] === arr[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>    <span class="hljs-comment">// 跳过重复的值</span>    <span class="hljs-keyword">let</span> first = i,    second = i+<span class="hljs-number">1</span>,    third = len-<span class="hljs-number">1</span>    <span class="hljs-keyword">while</span>(second&lt;third)&#123;      <span class="hljs-keyword">const</span> sum = arr[first]+arr[second]+arr[third]      <span class="hljs-keyword">if</span>(sum===target)&#123;        res.push([arr[first],arr[second++],arr[third--]])        <span class="hljs-comment">// 移动一次指针再跳过重复项</span>        <span class="hljs-keyword">while</span>(arr[second]===arr[second-<span class="hljs-number">1</span>])&#123;          second ++        &#125;        <span class="hljs-keyword">while</span>(arr[third]===arr[third1+<span class="hljs-number">1</span>])&#123;          third --        &#125;      &#125;      <span class="hljs-comment">//移动指针</span>      <span class="hljs-keyword">if</span>(sum&gt;target) third --      <span class="hljs-keyword">if</span>(sum&lt;target) second ++    &#125;  &#125;  <span class="hljs-keyword">return</span> res&#125;</code></pre></div></li><li><p>最大面积</p><p> 给定数组，按数组index为x轴坐标,value为y轴坐标在二纬坐标系画线，连接哪两条线时得到最大面积</p><blockquote><p>面积 = 两直线中较短的高度 * 两线间距离</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxArea</span>(<span class="hljs-params">height</span>)</span>&#123;  <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> r = height.length <span class="hljs-number">1.</span> <span class="hljs-number">1</span>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>  <span class="hljs-keyword">while</span>(l&lt;r)&#123;    res = <span class="hljs-built_in">Math</span>.max(res,(r-l)*<span class="hljs-built_in">Math</span>.min(height[l],height[r]))    <span class="hljs-keyword">if</span>(height[l]&lt;height[r])&#123;      l++    &#125;<span class="hljs-keyword">else</span>&#123;      r--    &#125;  &#125;  <span class="hljs-keyword">return</span> res &#125;</code></pre></div></blockquote></li><li><p>删除排序数组中的重复项，不能使用额外空间，返回不重复的长度</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeDuplicates</span>(<span class="hljs-params">arr</span>)</span>&#123;  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> len = arr.length  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>;j&lt;len;j++)&#123;    <span class="hljs-keyword">if</span>(arr[j] !== arr[j-<span class="hljs-number">1</span>])&#123;      arr[++i] = arr[j]    &#125;  &#125;  <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>&#125;</code></pre></div></li><li><p>设计一个支持在平均时间复杂度 O(1) 下，执行以下操作的数据结构。</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript">insert(val) ：当元素 val 不存在时，向集合中插入该项。remove(val) ：元素 val 存在时，从集合中移除该项。getRandom ：随机返回现有集合中的一项。每个元素应该有 相同的概率 被返回。示例 :<span class="hljs-comment">// 初始化一个空的集合。</span>RandomizedSet randomSet = <span class="hljs-keyword">new</span> RandomizedSet();<span class="hljs-comment">// 向集合中插入 1 。返回 true 表示 1 被成功地插入。</span>randomSet.insert(<span class="hljs-number">1</span>);<span class="hljs-comment">// 返回 false ，表示集合中不存在 2 。</span>randomSet.remove(<span class="hljs-number">2</span>);<span class="hljs-comment">// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。</span>randomSet.insert(<span class="hljs-number">2</span>);<span class="hljs-comment">// getRandom 应随机返回 1 或 2 。</span>randomSet.getRandom();<span class="hljs-comment">// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。</span>randomSet.remove(<span class="hljs-number">1</span>);<span class="hljs-comment">// 2 已在集合中，所以返回 false 。</span>randomSet.insert(<span class="hljs-number">2</span>);<span class="hljs-comment">// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。</span>randomSet.getRandom();<span class="hljs-comment">// map方法</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">RandomSet</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()  <span class="hljs-built_in">this</span>.values = []&#125;RandomSet.prototype.insert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.map.has(val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-built_in">this</span>.map.set(val,values.length)  <span class="hljs-comment">// 插入后的索引（插入前的数组长度）</span>  <span class="hljs-built_in">this</span>.values.push(val)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;RandomSet.prototype.remove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.map.has(val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">this</span>.map.get(val)  <span class="hljs-comment">// 判断在尾部</span>  <span class="hljs-comment">// 似乎也可以用头部</span>  <span class="hljs-keyword">if</span>(index === <span class="hljs-built_in">this</span>.values.length <span class="hljs-number">1.</span> <span class="hljs-number">1</span>)&#123;    <span class="hljs-built_in">this</span>.map.delete(value)    <span class="hljs-built_in">this</span>.values.pop()  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-comment">// 不在尾部</span>    <span class="hljs-comment">// values用尾部元素填充该位置</span>    <span class="hljs-comment">// map中修改索引</span>    <span class="hljs-keyword">let</span> last = <span class="hljs-built_in">this</span>.values.pop()    <span class="hljs-comment">// 赋值</span>    <span class="hljs-built_in">this</span>.values[index] = last    <span class="hljs-built_in">this</span>.map.set(last,index)    <span class="hljs-built_in">this</span>.map.delete(val)  &#125;  <span class="hljs-keyword">return</span> val&#125;RandomSet.prototype.getRandom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">let</span> len = <span class="hljs-built_in">this</span>.values.length  <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random()*len)  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.values[index]&#125;<span class="hljs-comment">// set方法</span><span class="hljs-comment">// set是不重复的值的集合</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">RandomSet</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()&#125;RandomizedSet.prototype.insert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.data.has(val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-built_in">this</span>.set.add(val)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;RandomizedSet.prototype.remove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.data.has(val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-built_in">this</span>.set.delete(val)  <span class="hljs-keyword">return</span> val&#125;RandomizedSet.prototype.getRandom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">let</span> len = <span class="hljs-built_in">this</span>.values.length  <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random()*len)  <span class="hljs-keyword">return</span> [...this.data][index]&#125;</code></pre></div></li></ol><ol><li>合并两个有序数组 <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// arr1 = [1,2,5]  m=3</span><span class="hljs-comment">// arr2 = [2,3,4]  n=3</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeArr</span>(<span class="hljs-params">arr1,m,arr2,n</span>)</span>&#123;  <span class="hljs-keyword">let</span> index1 = m-<span class="hljs-number">1</span>  <span class="hljs-keyword">let</span> index2 = n-<span class="hljs-number">1</span>  <span class="hljs-keyword">let</span> index = m+n-<span class="hljs-number">1</span>  <span class="hljs-keyword">while</span>(index2&gt;=<span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">if</span>(index1&lt;<span class="hljs-number">0</span>)&#123;      arr1[index] = arr2[index2]      index --      index2 --      <span class="hljs-keyword">continue</span>    &#125;    arr1[index--] = arr1[index1]&gt;=arr2[index2]?arr1[index1--]:arr2[index2--]  &#125;&#125;</code></pre></div></li></ol><ol><li>计算两个数组的交集 <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">intersection</span>(<span class="hljs-params">arr1,arr2</span>)</span>&#123;  <span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Set</span>(arr1.filter(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>arr2.includes(item)))]&#125;</code></pre></div></li></ol><ol><li><p>计算多个数组的交集</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">intersection</span>(<span class="hljs-params">...arrs</span>)</span>&#123;  <span class="hljs-keyword">if</span>(arrs.length===<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> []  <span class="hljs-keyword">if</span>(arrs.length===<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> arrs[<span class="hljs-number">0</span>]  <span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Set</span>(arrs.reduce(<span class="hljs-function">(<span class="hljs-params">pre,next</span>)=&gt;</span>&#123;    <span class="hljs-comment">// reduce累加器，每一次的return作为下一次累加的pre，你咋这也能忘</span>    <span class="hljs-comment">// 后还能添加参数手动制定第一次累加的pre值</span>    <span class="hljs-keyword">return</span> pre.filter(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>next.includes(item))  &#125;))]&#125;</code></pre></div></li><li><p>实现一个fill函数</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// fill(3,4) =&gt; [4,4,4]</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFill</span>(<span class="hljs-params">num,size</span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">acc,size</span>)=&gt;</span>&#123;    <span class="hljs-keyword">if</span>(--size&gt;<span class="hljs-number">0</span>)&#123;      acc = acc.concat(num)    &#125;    <span class="hljs-keyword">return</span> acc  ,[]&#125;&#125;</code></pre></div></li></ol><ol><li><p>大数相加(可以输出字符串)</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bigAdd</span>(<span class="hljs-params">x, y</span>) </span>&#123;  <span class="hljs-keyword">if</span>(x===<span class="hljs-string">&#x27;0&#x27;</span>)<span class="hljs-keyword">return</span> y  <span class="hljs-keyword">if</span>(y===<span class="hljs-string">&#x27;0&#x27;</span>)<span class="hljs-keyword">return</span> x  <span class="hljs-keyword">let</span> num1;  <span class="hljs-keyword">let</span> num2;  <span class="hljs-keyword">let</span> curNum;  <span class="hljs-keyword">let</span> ix = x.length <span class="hljs-number">1.</span> <span class="hljs-number">1</span>;  <span class="hljs-keyword">let</span> iy = y.length <span class="hljs-number">1.</span> <span class="hljs-number">1</span>;  <span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> res = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// res是字符串</span>  <span class="hljs-keyword">while</span> (ix &gt;= <span class="hljs-number">0</span> || iy &gt;= <span class="hljs-number">0</span>) &#123;    num1 = x.charAt(ix--);    num2 = y.charAt(iy--);    curNum = <span class="hljs-built_in">Number</span>(num1) + <span class="hljs-built_in">Number</span>(num2) + carry    carry = <span class="hljs-number">0</span>    <span class="hljs-keyword">if</span>(curNum&gt;=<span class="hljs-number">10</span>)&#123;      carry = <span class="hljs-number">1</span>      curNum = curNum%<span class="hljs-number">10</span>    &#125;    res = curNum + res; <span class="hljs-comment">// 数字加上字符串，隐式转换为字符串拼接</span>  &#125;  <span class="hljs-keyword">return</span> carry ? carry + res : res&#125;</code></pre></div></li><li><p>大数相乘(可以输出字符串)</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bigMulti</span>(<span class="hljs-params">x,y</span>)</span>&#123;  <span class="hljs-keyword">if</span>(x===<span class="hljs-string">&#x27;0&#x27;</span> || y===<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0&#x27;</span>  <span class="hljs-keyword">if</span>(x===<span class="hljs-string">&#x27;1&#x27;</span>)<span class="hljs-keyword">return</span> y  <span class="hljs-keyword">if</span>(y===<span class="hljs-string">&#x27;1&#x27;</span>)<span class="hljs-keyword">return</span> x  <span class="hljs-keyword">const</span> len1 = x.length  <span class="hljs-keyword">const</span> len2 = y.length  <span class="hljs-keyword">const</span> pos = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len1+len2).fill(<span class="hljs-number">0</span>)  <span class="hljs-keyword">let</span> num1,num2,mulit,cur  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = len1 -<span class="hljs-number">1</span> ; i&gt;=<span class="hljs-number">0</span> ; i--)&#123;    num1 = x[i]    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = len2 <span class="hljs-number">1.</span> <span class="hljs-number">1</span> ; j &gt;= <span class="hljs-number">0</span> ;j --)&#123;      num2 = y[j]      mulit = num1*num2      cur = mulit + pos[i+j+<span class="hljs-number">1</span>]      pos[i+j+<span class="hljs-number">1</span>] = cur % <span class="hljs-number">10</span>      pos[i+j] += cur / <span class="hljs-number">10</span> | <span class="hljs-number">0</span>      <span class="hljs-comment">// 单个的 ｜ 使用二进制比较左右两个数字</span>    &#125;  &#125;  <span class="hljs-keyword">let</span> res = pos.join(<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-built_in">console</span>.log(res);  <span class="hljs-keyword">while</span>(res[<span class="hljs-number">0</span>]===<span class="hljs-string">&#x27;0&#x27;</span>)&#123;    res = res.substring(<span class="hljs-number">1</span>)  &#125;  <span class="hljs-keyword">return</span> res&#125;</code></pre></div></li><li><p>保留精度加法</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fixAdd = <span class="hljs-function">(<span class="hljs-params">x,y</span>)=&gt;</span>&#123;  <span class="hljs-keyword">const</span>  len1 = x.split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>].length  <span class="hljs-keyword">const</span>  len2 = y.split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>].length  <span class="hljs-keyword">const</span>  maxLen = len1&gt;=len2 ? len1 :len2  <span class="hljs-keyword">const</span> times = maxLen*<span class="hljs-number">10</span>  <span class="hljs-keyword">return</span> (x * times + y * times) / times;&#125;</code></pre></div></li><li><p>满9加1</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add1</span>(<span class="hljs-params">num</span>)</span>&#123;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> dig = num.length - <span class="hljs-number">1</span>;dig&gt;=<span class="hljs-number">0</span>;dig--)&#123;    <span class="hljs-keyword">if</span>(num[dig]===<span class="hljs-number">9</span>)&#123;      num[dig]=<span class="hljs-number">0</span>    &#125;<span class="hljs-keyword">else</span>&#123;      num[dig] ++      <span class="hljs-keyword">return</span> num    &#125;  &#125;  num.unshift(<span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> num&#125;</code></pre></div></li><li><p>将数组中的0全部移动到最后且非0部分保持原顺序</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move0</span>(<span class="hljs-params">num</span>)</span>&#123;  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>  <span class="hljs-keyword">while</span>(i&lt;num.length)&#123;    <span class="hljs-keyword">if</span>(num[i]!==<span class="hljs-number">0</span>)&#123;      [mim[i],num[j]] = [num[j],num[i]]      i++      j++    &#125;<span class="hljs-keyword">else</span>&#123;      i++    &#125;  &#125;&#125;</code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>1. 面试 1. javascript 1. 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象题</title>
    <link href="/2020/04/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%A2%98/"/>
    <url>/2020/04/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ul><li>打车时可以打专车或快车。任何车都有车牌号和名称。快车每公里1元，专车每公里2元。行程开始时，显示车辆信息。行程结束时，显示打车金额。行程距离为5公里。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">licence,name</span>)</span>&#123;    <span class="hljs-built_in">this</span>.licence = licence    <span class="hljs-built_in">this</span>.name = name  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastCar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Car</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">licence,name</span>)</span>&#123;    <span class="hljs-built_in">super</span>(licence,name)    <span class="hljs-built_in">this</span>.price =<span class="hljs-number">1</span>  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrivateCar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Car</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">licence,name</span>)</span>&#123;    <span class="hljs-built_in">super</span>(licence,name)    <span class="hljs-built_in">this</span>.price = <span class="hljs-number">2</span>  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">car,distance</span>)</span>&#123;    <span class="hljs-built_in">this</span>.car = car    <span class="hljs-built_in">this</span>.distance = distance  &#125;  <span class="hljs-function"><span class="hljs-title">getIn</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.car.name);    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.car.licence);  &#125;  <span class="hljs-function"><span class="hljs-title">getOff</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.car.price*<span class="hljs-built_in">this</span>.distance);  &#125;&#125;<span class="hljs-keyword">let</span> car1 = <span class="hljs-keyword">new</span> PrivateCar(<span class="hljs-string">&#x27;粤A8888888&#x27;</span>,<span class="hljs-string">&#x27;特斯拉&#x27;</span>)<span class="hljs-keyword">let</span> cost1 = <span class="hljs-keyword">new</span> Order(car1,<span class="hljs-number">5</span>).getOff()</code></pre></div><ul><li>某停车场, 分三层, 每层100 车位,每个车位都能监控到车辆的进入和离开,车辆进入前,显示每层的空余车位数量,车辆进入时,摄像头可识别车牌号和进入时间,车辆出来时,出口显示屏显示车牌号和停车时长</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">licence</span>)</span>&#123;    <span class="hljs-built_in">this</span>.licence = licence  &#125;&#125;<span class="hljs-comment">// 整个停车场</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkingLot</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">floors</span>)</span>&#123;    <span class="hljs-comment">// floors:[[300],[300],[300]]</span>    <span class="hljs-built_in">this</span>.floors = floors    <span class="hljs-built_in">this</span>.dataBase = []  &#125;  <span class="hljs-function"><span class="hljs-title">showSpace</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">this</span>.floors.length;i++)&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`第<span class="hljs-subst">$&#123;i+<span class="hljs-number">1</span>&#125;</span>层空闲车位(<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.floors[i].emptySpace()&#125;</span>)`</span>)    &#125;  &#125;  <span class="hljs-function"><span class="hljs-title">intoLot</span>(<span class="hljs-params">car,floorIndex,lotIndex</span>)</span>&#123;    <span class="hljs-comment">//车牌，时间</span>    <span class="hljs-keyword">let</span> licence = car.licence    <span class="hljs-keyword">let</span> intoTime = <span class="hljs-built_in">Date</span>.now()    <span class="hljs-keyword">let</span> space = <span class="hljs-built_in">this</span>.floors[floorIndex].lot[lotIndex]    <span class="hljs-built_in">this</span>.dataBase[licence] = &#123;intoTime,floorIndex,lotIndex&#125;    space.checkIn()  &#125;  <span class="hljs-function"><span class="hljs-title">outLot</span>(<span class="hljs-params">car</span>)</span>&#123;    <span class="hljs-keyword">let</span> outTime = <span class="hljs-built_in">Date</span>.now()    <span class="hljs-keyword">let</span> licence = car.licence    <span class="hljs-keyword">let</span> info = <span class="hljs-built_in">this</span>.dataBase[licence]    <span class="hljs-keyword">let</span> space = <span class="hljs-built_in">this</span>.floors[info.floorIndex].lot[info.lotIndex]    <span class="hljs-keyword">let</span> timeCount = <span class="hljs-built_in">parseInt</span>((outTime-info.intoTime)/<span class="hljs-number">36000000</span>)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`停车时长<span class="hljs-subst">$&#123;timeCount&#125;</span>小时`</span>)    space.checkOut()  &#125;&#125;<span class="hljs-comment">// 车位,监视驶入离开</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkingSpace</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">this</span>.free = <span class="hljs-literal">true</span>  &#125;  <span class="hljs-function"><span class="hljs-title">checkIn</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">this</span>.free = <span class="hljs-literal">false</span>  &#125;  <span class="hljs-function"><span class="hljs-title">checkOut</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">this</span>.free = <span class="hljs-literal">true</span>  &#125;&#125;<span class="hljs-comment">// 层</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkingFloor</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">floor,lot</span>)</span>&#123;    <span class="hljs-built_in">this</span>.floor = floor    <span class="hljs-built_in">this</span>.lot = lot  &#125;  <span class="hljs-function"><span class="hljs-title">emptySpace</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">//返回空闲车位</span>    <span class="hljs-keyword">let</span> freeLot = <span class="hljs-number">0</span>    <span class="hljs-built_in">this</span>.lot.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;      <span class="hljs-keyword">if</span>(item.free)&#123;        freeLot++      &#125;    &#125;);    <span class="hljs-keyword">return</span> freeLot  &#125;&#125;</code></pre></div><ul><li>一副扑克牌有54张牌，其中52张是正牌，另2张是副牌（大王和小王）。<br>52张正牌又均分为13张一组，并以黑桃、红桃、草花、方块四种花色表示各组，每组花色的牌包括从1-10（1通常表示为A）以及J、Q、K标示的13张牌。<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;J&#x27;</span>,<span class="hljs-string">&#x27;Q&#x27;</span>,<span class="hljs-string">&#x27;K&#x27;</span>]<span class="hljs-keyword">const</span> signs = [<span class="hljs-string">&#x27;♥️&#x27;</span>, <span class="hljs-string">&#x27;♦️&#x27;</span>, <span class="hljs-string">&#x27;♣️&#x27;</span>, <span class="hljs-string">&#x27;♠️&#x27;</span>]<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Poker</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">signs,numbers</span>)</span> &#123;<span class="hljs-built_in">this</span>.signs = signs<span class="hljs-built_in">this</span>.numbers = numbers<span class="hljs-built_in">this</span>.mounts = <span class="hljs-number">52</span><span class="hljs-built_in">this</span>.pokers = []&#125;<span class="hljs-function"><span class="hljs-title">initPokers</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">this</span>.signs.length;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">this</span>.numbers.length;j++)&#123;<span class="hljs-built_in">this</span>.pokers.push(<span class="hljs-keyword">new</span> Card(<span class="hljs-built_in">this</span>.signs[i],<span class="hljs-built_in">this</span>.numbers[j]))&#125;&#125;<span class="hljs-built_in">this</span>.pokers.push(<span class="hljs-keyword">new</span> Card(<span class="hljs-string">&#x27;BLACK&#x27;</span>,<span class="hljs-string">&#x27;GHOST&#x27;</span>))<span class="hljs-built_in">this</span>.pokers.push(<span class="hljs-keyword">new</span> Card(<span class="hljs-string">&#x27;RED&#x27;</span>,<span class="hljs-string">&#x27;GHOST&#x27;</span>))&#125;  <span class="hljs-function"><span class="hljs-title">shuffleCard</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-comment">// let arr = this.pokers</span><span class="hljs-comment">// let len = arr.length</span>    <span class="hljs-comment">// let temp,i</span>    <span class="hljs-comment">// while(len)&#123;</span>    <span class="hljs-comment">//   i = Math.floor(Math.random()*len--)</span>    <span class="hljs-comment">//   temp = arr[i]</span>    <span class="hljs-comment">//   arr[i] = arr[len]</span>    <span class="hljs-comment">//   arr[len] = temp</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-comment">// this.pokers = arr</span>    <span class="hljs-built_in">this</span>.pokers = <span class="hljs-built_in">this</span>.pokers.sort(<span class="hljs-function">()=&gt;</span><span class="hljs-built_in">Math</span>.random()-<span class="hljs-number">0.5</span>)  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Card</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">sign, number</span>)</span> &#123;    <span class="hljs-built_in">this</span>.sign = sign;    <span class="hljs-built_in">this</span>.number = number;  &#125;&#125;<span class="hljs-keyword">let</span> game1 = <span class="hljs-keyword">new</span> Poker(signs,numbers)game1.initPokers()game1.shuffleCard()<span class="hljs-built_in">console</span>.log(game1.pokers);game1.shuffleCard()<span class="hljs-built_in">console</span>.log(game1.pokers);</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原生js与jq</title>
    <link href="/2020/03/27/%E5%8E%9F%E7%94%9Fjs/"/>
    <url>/2020/03/27/%E5%8E%9F%E7%94%9Fjs/</url>
    
    <content type="html"><![CDATA[<ul><li><p>javascript</p><p>js 是一门函数优先的轻量级解释型语言，基于原型编程的动态脚本语言</p><ol><li>函数是一等公民（变量提升，函数可以作为函数的参数，返回值，可以赋值给变量，【函数式编程的条件】</li><li>面向对象编程</li><li>弱类型语言（变量的类型在运行时会变化，强类型语言的变量类型编译时就确定且不会改变</li><li>基于原型（区别于基于类[类和实例]，js 中万物皆为[对象]<blockquote><p>基于原型的语言具有所谓原型对象（prototypical object）的概念。原型对象可以作为一个模板，新对象可以从中获得原始的属性。任何对象都可以指定其自身的属性，任何对象都可以作为另一个对象的原型（prototype），从而允许后者共享前者的属性。</p></blockquote></li></ol></li><li><p>BOM 浏览器的编程接口</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">navigator浏览器信息location浏览器定位和导航history窗口浏览器历史screen 屏幕</code></pre></div><ul><li>DOM 文档的编程接口</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.getElementById(id);<span class="hljs-built_in">document</span>.getElementsByTagName(name);<span class="hljs-built_in">document</span>.createElement(name);parentNode.appendChild(node);element.innerHTML;<span class="hljs-comment">//innerHTML 从对象起始位置到终止位置的全部内容（包括html标签</span><span class="hljs-comment">//outerHTML 包括对象自身标签</span><span class="hljs-comment">//innerText innerHTML但不包括html标签，</span><span class="hljs-comment">//textContent 所有文本内容，包括script和style标签内</span>element.style.left;element.setAttribute();element.getAttribute();element.addEventListener();<span class="hljs-built_in">window</span>.content;<span class="hljs-built_in">window</span>.onload;<span class="hljs-built_in">window</span>.dump();<span class="hljs-built_in">window</span>.scrollTo();</code></pre></div><ul><li><p>面向对象与面向过程</p><ul><li><p>分析出解决问题的步骤，用函数分别实现各步骤</p></li><li><p>把构成问题的事物抽象分解成各个对象，用对象来描述某个事物在整个解决问题过程中的行为</p></li><li><p>面向对象三要素</p><ol><li>封装 -&gt; 利用抽象数据类型将数据和基于数据的操作封装在一起只留下接口给外部访问</li><li>继承 -&gt; 子类自动共享父类数据结构和方法</li><li>多态 -&gt; 相同的操作或函数可作用于多种类型的对象上并获得不同的结果</li></ol></li></ul></li><li><p><code>eval()</code>函数</p><ul><li>AMD 规范的 requireJS 加载模块时有使用</li><li>严格模式下的 eval()函数有作用域</li></ul></li><li><p>柯里化</p><p>把同时接受多个参数的函数改造成接受首个参数并返回接受余下参数的函数</p><ol><li>参数复用</li><li>提前确定 — isType 方法</li><li>延迟执行 — bind 方法</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript">add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);add(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">4</span>);<span class="hljs-keyword">const</span> add = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> cur = [...arguments].reduce(add);  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextAdd</span>(<span class="hljs-params"></span>) </span>&#123;    cur += [...arguments].reduce(add);    <span class="hljs-keyword">return</span> nextAdd;  &#125;  nextAdd.toString = <span class="hljs-function">() =&gt;</span> cur;  <span class="hljs-keyword">return</span> nextAdd;&#125;</code></pre></div></li><li><p>作用域/作用域链/闭包</p><ul><li>作用域：js 中的作用域是函数级的，变量在它声明的函数体以及函数体内嵌套的任意函数体内有定义</li><li>作用域链：js 执行时创建的执行上下文含有外部词法环境的引用，可以通过这个引用获取外部词法环境的变量、声明等，这些引用串联起来一直指向全局的词法环境，形成了作用域链。</li><li>闭包：函数体和其词法环境共同组成闭包。</li><li>JavaScript 中，函数在每次创建时生成闭包</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(i);  &#125;, <span class="hljs-number">1000</span> * i);&#125;</code></pre></div></li><li><p>map/flatMap/reduce</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// reduce的骚操作</span><span class="hljs-comment">// 对对象内的数据求和</span><span class="hljs-keyword">let</span> data = [  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;mmm&quot;</span>, <span class="hljs-attr">money</span>: <span class="hljs-number">120</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;mmm&quot;</span>, <span class="hljs-attr">money</span>: <span class="hljs-number">120</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;mmm&quot;</span>, <span class="hljs-attr">money</span>: <span class="hljs-number">120</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;mmm&quot;</span>, <span class="hljs-attr">money</span>: <span class="hljs-number">120</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;mmm&quot;</span>, <span class="hljs-attr">money</span>: <span class="hljs-number">120</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;mmm&quot;</span>, <span class="hljs-attr">money</span>: <span class="hljs-number">120</span> &#125;,];<span class="hljs-keyword">const</span> sumMoney = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> data.reduce(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> a + y.money, <span class="hljs-number">0</span>);&#125;;<span class="hljs-comment">//720</span><span class="hljs-comment">// 计算出现次数</span><span class="hljs-keyword">const</span> showCount = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> data.reduce(<span class="hljs-function">(<span class="hljs-params">showList, item</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (item <span class="hljs-keyword">in</span> showList) &#123;      showList[item]++;    &#125; <span class="hljs-keyword">else</span> &#123;      showList[item] = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> showList;  &#125;, &#123;&#125;);&#125;;<span class="hljs-comment">// orderBy按属性分类</span><span class="hljs-keyword">const</span> orderBy = <span class="hljs-function">(<span class="hljs-params">data, prop</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> data.reduce(<span class="hljs-function">(<span class="hljs-params">list, item</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> key = item[prop];    <span class="hljs-keyword">if</span> (!list[key]) &#123;      list[ket] = [];    &#125;    list[key].push(item);    <span class="hljs-keyword">return</span> list;  &#125;, &#123;&#125;);&#125;;<span class="hljs-comment">// 对象中取出特定数据输出新数组</span><span class="hljs-keyword">const</span> newArr = <span class="hljs-function">(<span class="hljs-params">data, prop</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> data.reduce(<span class="hljs-function">(<span class="hljs-params">arr, item</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> [...arr, ...item[prop]];  &#125;, []);&#125;;<span class="hljs-comment">// 数组去重</span><span class="hljs-keyword">const</span> reduceSet = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> arr.sort().reduce(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (!acc.length || acc[acc.length - <span class="hljs-number">1</span>] !== cur) &#123;      acc.push(cur);    &#125;    <span class="hljs-keyword">return</span> acc;  &#125;, []);&#125;;</code></pre></div></li><li><p>window</p><ul><li><code>window.ready</code>样式应用到了 DOM 上</li><li><code>window.load</code>加载完所有资源（图片</li></ul></li><li><p>进制转换</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 十进制转换为其他进制</span><span class="hljs-built_in">Number</span>(val).toString(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>);<span class="hljs-comment">// 其他进制转十进制</span><span class="hljs-built_in">parseInt</span>(val, radix);</code></pre></div><ul><li><p>严格模式<code>use strick</code></p><ul><li>严格模式通过抛出错误来消除了一些原有静默错误和编码错误。</li><li>严格模式修复了一些导致 JavaScript 引擎难以执行优化的缺陷，提高代码运行效率。</li><li>严格模式禁用了在 ECMAScript 的未来版本中可能会定义的一些关键字</li><li>无法再意外创建全局变量，全局作用域下，this 的值为 undefined。</li><li>要求函数的参数名唯一</li><li>eval()函数有自己的作用域</li></ul></li><li><p>操作字符串</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">charAt(); <span class="hljs-comment">//返回索引位置字符</span>concat(); <span class="hljs-comment">//拼接</span>indexOf(), lastIndexOf(); <span class="hljs-comment">//返回出现的索引位置</span>includes();match(); <span class="hljs-comment">//匹配正则</span>replace();split(); <span class="hljs-comment">//以xx分割字符串</span>slice(); <span class="hljs-comment">//截取返回新字符串，以索引</span>substring(); <span class="hljs-comment">//截取返回新字符串，以长度</span>trim(); <span class="hljs-comment">//删除空格</span>toLowerCase(), toUpperCase();</code></pre></div><ul><li><p>操作数组</p><ul><li>不改变原数组</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">filter();slice();concat();join(); <span class="hljs-comment">//返回字符串</span>includes();indexOf(), lastIndexOf();reduce();forEach();reduce();map();find(); <span class="hljs-comment">//返回符合条件的</span>every(); <span class="hljs-comment">//全都符合条件？</span>some(); <span class="hljs-comment">//有符合条件的</span></code></pre></div><ul><li>改变原数组</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">push();pop();shift();unshift();sort(); <span class="hljs-comment">//排序</span>reverse(); <span class="hljs-comment">//倒序</span>splice(); <span class="hljs-comment">// 删除</span>flat();</code></pre></div></li><li><p>洗牌</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shuffle</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">let</span> len = arr.length  <span class="hljs-keyword">while</span> (len) &#123;    <span class="hljs-keyword">const</span> i = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * len--);    [arr[i],arr[len]] = [arr[len],arr[i]]  &#125;  <span class="hljs-keyword">return</span> arr;&#125;</code></pre></div><ul><li>实现 EventEmitter</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 请实现下面的自定义事件 Event 对象的接口，功能见注释(测试1)</span><span class="hljs-comment">// 该 Event 对象的接口需要能被其他对象拓展复用(测试2)</span><span class="hljs-comment">// 测试1</span>Event.on(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(result);&#125;);Event.on(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;test&quot;</span>);&#125;);Event.emit(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;hello world&quot;</span>); <span class="hljs-comment">// 输出 &#x27;hello world&#x27; 和 &#x27;test&#x27;</span><span class="hljs-comment">// 测试2</span><span class="hljs-keyword">var</span> person1 = &#123;&#125;;<span class="hljs-keyword">var</span> person2 = &#123;&#125;;<span class="hljs-built_in">Object</span>.assign(person1, Event);<span class="hljs-built_in">Object</span>.assign(person2, Event);person1.on(<span class="hljs-string">&quot;call1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;person1&quot;</span>);&#125;);person2.on(<span class="hljs-string">&quot;call2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;person2&quot;</span>);&#125;);person1.emit(<span class="hljs-string">&quot;call1&quot;</span>); <span class="hljs-comment">// 输出 &#x27;person1&#x27;</span>person1.emit(<span class="hljs-string">&quot;call2&quot;</span>); <span class="hljs-comment">// 没有输出</span>person2.emit(<span class="hljs-string">&quot;call1&quot;</span>); <span class="hljs-comment">// 没有输出</span>person2.emit(<span class="hljs-string">&quot;call2&quot;</span>); <span class="hljs-comment">// 输出 &#x27;person2&#x27;</span><span class="hljs-keyword">var</span> Event = &#123;  <span class="hljs-comment">// 通过on接口监听事件eventName</span>  <span class="hljs-comment">// 如果事件eventName被触发，则执行callback回调函数</span>  on: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">eventName, callback</span>) </span>&#123;    <span class="hljs-comment">//你的代码</span>  &#125;,  <span class="hljs-comment">// 触发事件 eventName</span>  emit: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">eventName</span>) </span>&#123;    <span class="hljs-comment">//你的代码</span>  &#125;,&#125;;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Event =&#123;  on:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name,cb</span>)</span>&#123;    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.handlers)&#123;      <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">this</span>,<span class="hljs-string">&#x27;handlers&#x27;</span>,&#123;        value:&#123;&#125;,        enumerable:<span class="hljs-literal">false</span>,        configurable:<span class="hljs-literal">true</span>,        writable:<span class="hljs-literal">true</span>      &#125;)    &#125;    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.handlers[name])&#123;      <span class="hljs-built_in">this</span>.handlers[name] = []    &#125;    <span class="hljs-built_in">this</span>.handles[name].push(cb)  &#125;,  emit:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name,...args</span>)</span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.handlers[name])&#123;      <span class="hljs-built_in">this</span>.handlers[name].forEach(<span class="hljs-function"><span class="hljs-params">cb</span>=&gt;</span>&#123;        cb(...args)      &#125;)    &#125;  &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Events</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">this</span>.events = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()  &#125;  <span class="hljs-function"><span class="hljs-title">addEvent</span>(<span class="hljs-params">key,fn,isOnce,...args</span>)</span>&#123;    <span class="hljs-keyword">const</span> curEvent = <span class="hljs-built_in">this</span>.events.get(key) ? <span class="hljs-built_in">this</span>.events.get(key) : <span class="hljs-built_in">this</span>.events.set(key,<span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()).get(key)    curEvent.set(fn,<span class="hljs-function">(<span class="hljs-params">...args2</span>)=&gt;</span>&#123;      fn(...args,...args2)      <span class="hljs-keyword">if</span>(isOnce)<span class="hljs-built_in">this</span>.off(key,fn)    &#125;)  &#125;  <span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">key, fn, ...args</span>)</span> &#123;    <span class="hljs-built_in">this</span>.addEvent(key, fn, <span class="hljs-literal">false</span>, ...args)  &#125;  <span class="hljs-function"><span class="hljs-title">once</span>(<span class="hljs-params">key,fn,...args</span>)</span>&#123;    <span class="hljs-built_in">this</span>.addEvent(key,fn,<span class="hljs-literal">true</span>,...args)  &#125;  <span class="hljs-function"><span class="hljs-title">off</span>(<span class="hljs-params">key,fn</span>)</span>&#123;    <span class="hljs-built_in">this</span>.events.get(key).delete(fn)  &#125;  <span class="hljs-function"><span class="hljs-title">fire</span>(<span class="hljs-params">key,...args</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.events.get(key));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> cb <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>.events.get(key).values())&#123;      cb(...args)    &#125;  &#125;&#125;<span class="hljs-comment">// 请使用原生代码实现一个Events模块，可以实现自定义事件的订阅、触发、移除功能</span><span class="hljs-keyword">const</span> fn1 = <span class="hljs-function">(<span class="hljs-params">... args</span>)=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;I want sleep1&#x27;</span>, ... args)<span class="hljs-keyword">const</span> fn2 = <span class="hljs-function">(<span class="hljs-params">... args</span>)=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;I want sleep2&#x27;</span>, ... args)<span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> Events();event.on(<span class="hljs-string">&#x27;sleep&#x27;</span>, fn1, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);event.on(<span class="hljs-string">&#x27;sleep&#x27;</span>, fn2, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);event.fire(<span class="hljs-string">&#x27;sleep&#x27;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<span class="hljs-comment">// I want sleep1 1 2 3 4 5 6</span><span class="hljs-comment">// I want sleep2 1 2 3 4 5 6</span>event.off(<span class="hljs-string">&#x27;sleep&#x27;</span>, fn1);event.once(<span class="hljs-string">&#x27;sleep&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;I want sleep&#x27;</span>));event.fire(<span class="hljs-string">&#x27;sleep&#x27;</span>);<span class="hljs-comment">// I want sleep2 1 2 3</span><span class="hljs-comment">// I want sleep</span>event.fire(<span class="hljs-string">&#x27;sleep&#x27;</span>);<span class="hljs-comment">// I want sleep2 1 2 3</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css面试题</title>
    <link href="/2020/03/24/css%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2020/03/24/css%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h2><ul><li>IE<ul><li>双边距 <ul><li><code>display:inline</code></li></ul></li><li>默认高度<code>16px</code><ul><li><code>font-size:0</code></li><li><code>overflow:hidden</code></li></ul></li><li>超链接内img会有边框<ul><li><code>border:0</code> </li></ul></li></ul></li></ul><ul><li>3px bug<ul><li><code>display:block</code></li><li><code>vertical-align:top</code></li></ul></li></ul><h2 id="三角形2，椭圆"><a href="#三角形2，椭圆" class="headerlink" title="三角形2，椭圆"></a>三角形2，椭圆</h2><ul><li>不同边border之间45度拼接<div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;  <span class="hljs-attribute">width</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">border-top</span>:<span class="hljs-number">50px</span> red solid;  <span class="hljs-attribute">border-left</span>:<span class="hljs-number">50px</span> $(背景色) solid;  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> $(背景色) solid;&#125;</code></pre></div></li><li>border-radius属性</li></ul><h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><ul><li><p>单行文本居中，多行文本左对齐</p><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;  <span class="hljs-attribute">text-align</span>:center&#125;<span class="hljs-selector-tag">p</span>&#123;  <span class="hljs-attribute">display</span>:inline-block;  <span class="hljs-attribute">text-align</span><span class="hljs-selector-pseudo">:left</span>&#125;</code></pre></div></li><li><p>多行文本省略号</p><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>:after&#123;  content:<span class="hljs-string">&#x27;...&#x27;</span>&#125;</code></pre></div></li><li><p>单行文本溢出省略</p><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>: hidden；/* （文字长度超出限定宽度，则隐藏超出的内容） */white-space: nowrap；/* （设置文字在一行显示，不能换行） */text-overflow: ellipsis；/* （规定当文本溢出时，显示省略符号来代表被修剪的文本） */</code></pre></div></li><li><p>多行文本溢出</p><div class="hljs code-wrapper"><pre><code class="hljs css">-webkit-line-clamp: <span class="hljs-number">2</span>；/* （用来限制在一个块元素显示的文本的行数，<span class="hljs-number">2</span> 表示最多显示 <span class="hljs-number">2</span> 行。为了实现该效果，它需要组合其他的 WebKit 属性） */display: -webkit-box；/* （和 <span class="hljs-number">1</span> 结合使用，将对象作为弹性伸缩盒子模型显示 ） */-webkit-box-orient: vertical；/* （和 <span class="hljs-number">1</span> 结合使用 ，设置或检索伸缩盒对象的子元素的排列方式 ） */overflow: hidden；/* （文本溢出限定的宽度就隐藏内容） */text-overflow: ellipsis；/* （多行文本的情况下，用省略号 “…” 隐藏溢出范围的文本) */</code></pre></div></li></ul><h2 id="dpr-1px边框"><a href="#dpr-1px边框" class="headerlink" title="dpr 1px边框"></a>dpr 1px边框</h2><ul><li><code>@media</code>配合<code>transform:scale()</code></li><li>查询设备dpr等比缩放px大小<div class="hljs code-wrapper"><pre><code class="hljs css">.<span class="hljs-number">1px</span>_border:before&#123;  content:<span class="hljs-string">&#x27;&#x27;</span>;  <span class="hljs-attribute">position</span>:absolute;  <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">1px</span>;  <span class="hljs-attribute">background-color</span>:<span class="hljs-number">#000</span>;  <span class="hljs-attribute">transform-origin</span>:<span class="hljs-number">50%</span>,<span class="hljs-number">0</span>&#125;<span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio</span>: <span class="hljs-number">2</span>) &#123;  .<span class="hljs-number">1px</span>_border:before &#123;    transform: scaleY (<span class="hljs-number">0.5</span>);  &#125;<span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio</span>: <span class="hljs-number">3</span>) &#123;  .<span class="hljs-number">1px</span>_border:before &#123;    transform: scaleY (<span class="hljs-number">0.33</span>);  &#125;&#125;</code></pre></div></li></ul><h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><ol><li>50%绝对定位+负边距<blockquote><p>负边距偏移值是相对居中盒子尺寸计算</p></blockquote></li><li>50%绝对定位+50%translate负偏移<blockquote><p>translate偏移值是相对居中盒子尺寸计算</p></blockquote></li><li>绝对定位+上下左右0+margin:auto</li><li>flex+justify content+align items<blockquote><p>主轴 侧轴居中</p></blockquote></li><li>table-cell+vertical-align+margin:auto<blockquote><p>vertical-align 只在table-cell和行内元素生效</p></blockquote></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>控制台一直打印http://xxx/sockjs-node/info?t=xxx</title>
    <link href="/2020/02/04/%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%80%E7%9B%B4%E6%8A%A5%E9%94%99sockjs-node/"/>
    <url>/2020/02/04/%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%80%E7%9B%B4%E6%8A%A5%E9%94%99sockjs-node/</url>
    
    <content type="html"><![CDATA[<h3 id="sockjs-node是一个JavaScript库，提供跨浏览器JavaScript的API，创建了一个低延迟，全双工的浏览器和web服务器之间通信通道。"><a href="#sockjs-node是一个JavaScript库，提供跨浏览器JavaScript的API，创建了一个低延迟，全双工的浏览器和web服务器之间通信通道。" class="headerlink" title="sockjs-node是一个JavaScript库，提供跨浏览器JavaScript的API，创建了一个低延迟，全双工的浏览器和web服务器之间通信通道。"></a>sockjs-node是一个JavaScript库，提供跨浏览器JavaScript的API，创建了一个低延迟，全双工的浏览器和web服务器之间通信通道。</h3><h3 id="如果你的项目没有用到sockjs-vuecli3-运行npm-run-serve-之后network里面一直调用一个接口"><a href="#如果你的项目没有用到sockjs-vuecli3-运行npm-run-serve-之后network里面一直调用一个接口" class="headerlink" title="如果你的项目没有用到sockjs,vuecli3 运行npm run serve 之后network里面一直调用一个接口:"></a>如果你的项目没有用到sockjs,vuecli3 运行npm run serve 之后network里面一直调用一个接口:</h3><p><code>http://localhost:8080/sockjs-node/info?t=1556418283950</code></p><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><ol><li>开发环境中关闭此服务</li></ol><p>  <code>node_modules/sockjs-client/dist/sockjs.js</code>中注释<br><code>self.xhr.send(payload)</code></p><ol start="2"><li>webpack配置中</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript">sockHost: <span class="hljs-string">&quot; http://192.168.1.6:8080&quot;</span>,disableHostCheck: <span class="hljs-literal">true</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web安全</title>
    <link href="/2020/01/06/WEB%E5%AE%89%E5%85%A8/"/>
    <url>/2020/01/06/WEB%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>两个URl <strong>!同协议 !同域名 !同端口</strong></li><li>同源策略限制了同一个源加载的脚本和文档如何与其他源的资源进行交互，包括js脚本，缓存的读取，cookie，ajax等</li><li>三种标签不受同源限制<code>script</code> <code>link</code> <code>img</code></li></ul><h3 id="跨域的方法"><a href="#跨域的方法" class="headerlink" title="跨域的方法"></a>跨域的方法</h3><ul><li><p>代理服务器-<code>nginx,devServer等</code></p></li><li><p>更改页面的源<code>document.domain</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;someWebSite.com/dir1/pageA.html&#x27;</span><span class="hljs-string">&#x27;someWebSite.com/dir2/pageB.html&#x27;</span>都设置<span class="hljs-built_in">document</span>.domain = <span class="hljs-string">&#x27;someWebSite.com&#x27;</span>则他们之间通信将通过同源检测，并都访问父源的cookie</code></pre></div></li><li><p><code>postMessage</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// pageA通过iframe嵌入了pageB</span><span class="hljs-comment">// pageA中代码</span><span class="hljs-built_in">window</span>.iframe[i].postMessage(<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-string">&#x27;pqgeB的URL&#x27;</span>)<span class="hljs-comment">// pageB中的代码</span><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>,<span class="hljs-function"><span class="hljs-title">funciton</span>(<span class="hljs-params">e</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(e.data)     <span class="hljs-comment">// data</span>    <span class="hljs-built_in">console</span>.log(e.source)   <span class="hljs-comment">// a中window的引用</span>    <span class="hljs-built_in">console</span>.log(e.oringin)  <span class="hljs-comment">// pageA的URL</span>&#125;,<span class="hljs-literal">false</span>)<span class="hljs-comment">// 反过来pageB向pageA发送数据</span><span class="hljs-comment">// 在pageA中加入window.addEventListener</span><span class="hljs-comment">// 在pageB中e.source.postMessage</span></code></pre></div></li><li><p><code>iframe</code>+<code>hash</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// pageA通过iframe嵌入了pageB</span><span class="hljs-keyword">var</span> B = <span class="hljs-built_in">document</span>.getElementByTagName(<span class="hljs-string">&quot;iframe&quot;</span>);B.src = B.src + <span class="hljs-string">&quot;#&quot;</span> + <span class="hljs-string">&quot;data&quot;</span>;<span class="hljs-comment">// pageB中的代码</span><span class="hljs-built_in">window</span>.onhashchange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;data = <span class="hljs-built_in">window</span>.location.hash; <span class="hljs-comment">//  &lt;-  pageB就获取到了hash值</span>&#125;;</code></pre></div></li><li><p><code>jsonp</code></p></li></ul>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonp</span>(<span class="hljs-params">&#123; url, params, callback &#125;</span>) </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatParams</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> attrs = []    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [key,value] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(params))&#123;      attrs.push(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;value&#125;</span>`</span>)    &#125;    attrs.push(<span class="hljs-string">`callback=<span class="hljs-subst">$&#123;callback&#125;</span>`</span>)    <span class="hljs-keyword">return</span> attrs.join(<span class="hljs-string">&#x27;&amp;)</span><span class="hljs-string">  &#125;</span><span class="hljs-string">  return new Promise((resolve,reject)=&gt;&#123;</span><span class="hljs-string">    const script = document.createElement(&#x27;</span>script<span class="hljs-string">&#x27;)</span><span class="hljs-string">    script.src = url+&#x27;</span>?<span class="hljs-string">&#x27;+formatParams()</span><span class="hljs-string">    try&#123;</span><span class="hljs-string">      window[callback] = function(data)&#123;</span><span class="hljs-string">        resolve(data)</span><span class="hljs-string">        document.removeChild(script)</span><span class="hljs-string">      &#125;</span><span class="hljs-string">    &#125;catch(err)&#123;</span><span class="hljs-string">      reject(err)</span><span class="hljs-string">    &#125;</span><span class="hljs-string">  &#125;)</span><span class="hljs-string">&#125;</span></code></pre></div>  <div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 发送</span>jsonp(&#123;url: <span class="hljs-string">&quot;http://localhost:3000/jsptest&quot;</span>,params: &#123; <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;jsptestmessage&quot;</span> &#125;,callback: <span class="hljs-string">&quot;jsonpCallback&quot;</span>&#125;).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<span class="hljs-comment">//处理data</span>    &#125;);</code></pre></div><ul><li><p><code>imgPing</code><strong>添加img标签src中放入get请求</strong></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> Image();img.onload = img.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    alert(<span class="hljs-string">&quot;已发送&quot;</span>);&#125;;img.src = <span class="hljs-string">&quot;http://xxx.xxx.com/query?key=value&quot;</span>;<span class="hljs-comment">// 设置完src属性那一刻开始请求就发送了</span></code></pre></div></li><li><p><code>CORS</code>跨域资源共享（详见下文）</p></li><li><p><code>websocket</code>协议</p><ul><li><p>使用<code>websocket</code>协议,需要转协议</p><ol><li>客户端请求</li></ol><div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">Connection:</span> Upgrade<span class="hljs-symbol">Upgrade:</span> websocket</code></pre></div><ol start="2"><li>服务端响应协议升级</li></ol><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">101</span> Switching Protocols</code></pre></div></li><li><p>构造函数就要传入<code>绝对URL</code></p></li><li><p>全双工，双向通信</p></li><li><p>服务端推送</p></li><li><p>基于 TCP 传输协议，并复用 HTTP 的握手通道</p></li></ul></li><li><p><code>Fetch</code>新API</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postData</span>(<span class="hljs-params">url, data</span>) </span>&#123;<span class="hljs-comment">// Default options are marked with *</span>  <span class="hljs-keyword">return</span> fetch(url, &#123;      body: <span class="hljs-built_in">JSON</span>.stringify(data), <span class="hljs-comment">// must match &#x27;Content-Type&#x27; header</span>      cache: <span class="hljs-string">&quot;no-cache&quot;</span>, <span class="hljs-comment">// *default, no-cache, reload, force-cache, only-if-cached</span>      credentials: <span class="hljs-string">&quot;same-origin&quot;</span>, <span class="hljs-comment">// include, same-origin, *omit</span>      headers: &#123;        <span class="hljs-string">&quot;user-agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/4.0 MDN Example&quot;</span>,       <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>      &#125;,      method: <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-comment">// *GET, POST, PUT, DELETE, etc.</span>      mode: <span class="hljs-string">&quot;cors&quot;</span>, <span class="hljs-comment">// no-cors, cors, *same-origin</span>      redirect: <span class="hljs-string">&quot;follow&quot;</span>, <span class="hljs-comment">// manual, *follow, error</span>      referrer: <span class="hljs-string">&quot;no-referrer&quot;</span> <span class="hljs-comment">// *client, no-referrer</span>      &#125;).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json()); <span class="hljs-comment">// parses response to JSON</span>  &#125;</code></pre></div></li></ul><h3 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a><code>CORS</code>跨域</h3><p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解 - 阮一峰</a></p><p>跨源资源共享标准通过新增一系列 HTTP 头，让服务器能声明那些来源可以通过浏览器访问该服务器上的各类资源</p><h4 id="！简单请求"><a href="#！简单请求" class="headerlink" title="！简单请求"></a>！简单请求</h4><ul><li>方法<code>post get head</code>,</li><li><code>Content-Type</code>：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul><h5 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h5><ul><li>header中添加<code>Origin</code>字段</li></ul><h5 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h5><ul><li><p><code>Access-Control-Allow-Origin</code>:允许跨域访问的域，可以是一个域的列表，也可以是通配符”*“</p></li><li><p><code>Access-Control-Allow-Credentials</code>:是否允许请求带有 cookie</p><p>如果要发送<code>Cookie，Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名</p><p>并且 ajax 中要打开</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();xhr.withCredentials = <span class="hljs-literal">true</span>;  <span class="xml">&lt;-------</span></code></pre></div></li><li><p><code>Access-Control-Expose-Headers</code>: 自定义字段</p></li></ul><h4 id="！非简单请求"><a href="#！非简单请求" class="headerlink" title="！非简单请求"></a>！非简单请求</h4><ul><li>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code></li><li>正式通信前会先发起”预检”请求</li><li>一旦服务器通过了”预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样</li></ul><h5 id="请求-1"><a href="#请求-1" class="headerlink" title="请求"></a>请求</h5><ul><li><code>OPTIONS</code>询问</li><li><code>Origin</code>来源域</li><li><code>Access-Control-Request-Method</code>接下来请求的方法</li></ul><h5 id="响应-1"><a href="#响应-1" class="headerlink" title="响应"></a>响应</h5><ul><li><code>Access-Control-Allow-Origin</code>允许跨域访问的域</li><li><code>Access-Control-Allow-Methods</code>服务器支持的所有跨域请求的方法</li><li><code>Access-Control-Max-Age</code>预检请求有效期</li><li><code>Access-Control-Allow-Credentials</code>与简单请求相同</li></ul><h2 id="XSS跨域脚本攻击"><a href="#XSS跨域脚本攻击" class="headerlink" title="XSS跨域脚本攻击"></a>XSS跨域脚本攻击</h2><p><code>Cross-site scripting</code></p><ul><li><p>存储型XSS</p><p>  input, textarea等）中写入恶意脚本上传到服务器，其他人下载带有该脚本的html页面至浏览器时脚本运行</p></li><li><p>反射型XSS</p><p>  将恶意代码加入<code>URL</code>中提交给服务器，服务器返回内容就带上了恶意代码，浏览器下载页面则执行了恶意代码，服务器不存储恶意代码</p></li><li><p>DOM XSS</p><ul><li>JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等函数</li><li><code>&lt;a&gt;</code>标签的<code>href</code>属性</li><li>DOM中的内联事件监视器,<code>location</code>,<code>onclick</code>,<code>onerror</code>,<code>onload</code>等</li><li>都可以将字符串作为代码执行</li></ul></li></ul><h3 id="防范XSS"><a href="#防范XSS" class="headerlink" title="防范XSS"></a>防范XSS</h3><ul><li>设置cookie  <code>httponly</code></li><li>校验用户输入</li><li>过滤用户上传的DOM事件和script，iframe，style标签</li><li>对用户输入内容html编码</li><li>使用CSP<code>Content Security Policy</code>,服务端加入http首部或meta标签,限制该页面可以获取哪些资源和资源的来源</li><li>! <code>jsonp</code>如何防止xss<ol><li>前后端约定jsonp请求的js的回调函数名</li><li>服务器端指定返回的数据格式为json</li><li>进行referrer验证 （<code>$_SERVER[&#39;HTTP_REFERRER&#39;] 中的 host</code>）</li></ol></li></ul><h2 id="CSRF跨域请求伪造"><a href="#CSRF跨域请求伪造" class="headerlink" title="CSRF跨域请求伪造"></a>CSRF跨域请求伪造</h2><p><code>Cross-site request forgery</code><br> 利用用户的登陆状态诱导至恶意网站，以合法身份向原先网站发送恶意请求</p><h3 id="防御CSRF"><a href="#防御CSRF" class="headerlink" title="防御CSRF"></a>防御CSRF</h3><ul><li>同源检测，验证<code>http</code>请求的来源<code>origin</code>和<code>referrer</code></li><li>设置<code>cookie</code>的<code>SameSite</code>属性，使<code>cookie</code>只可被第一方使用</li><li>合法页面中加入<code>token</code>，并在合法页面的后续请求（a标签和表单）中都加上这个<code>token</code>,服务器验证</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="SQl注入"><a href="#SQl注入" class="headerlink" title="SQl注入"></a>SQl注入</h4><ol><li><p>黑客提交畸形数据改变语义提交sql查询得到非法数据</p></li><li><p>防御</p><ol><li>过滤sql保留字</li><li>减少抛出不必要的数据库错误信息</li><li>禁止动态拼接sql语句访问数据库</li></ol></li></ol><h4 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h4><ol><li>点击透明iframe</li><li>监听鼠标移动位置</li><li>H5拖拽</li><li>防御：<ol><li>服务端添加 <code>X-Frame-Options</code> 响应头</li><li>js判断顶层视口是否同源</li><li>敏感操作复杂操作（验证码，二次确认</li></ol></li></ol><h4 id="window-opener"><a href="#window-opener" class="headerlink" title="window.opener"></a><code>window.opener</code></h4><ol><li>修改<code>window.opener.location</code>可以改写来源站点的地址</li><li>防御：<ol><li>设置a标签的rel属性<code>rel=noopener</code>,禁止新页面传递源页面地址</li><li>外部链接改为经由服务器跳转</li><li>使用window.open打开外链</li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>h5pb刷题</title>
    <link href="/2019/12/01/h5bp%E5%88%B7%E9%A2%98/"/>
    <url>/2019/12/01/h5bp%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="github"><a href="#github" class="headerlink" title="github"></a><a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions">github</a></h2><h2 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML/CSS"></a>HTML/CSS</h2><ol><li><p>img标签的<code>srcset</code>属性</p><p> <code>srcset</code> 的值是一个字符串，用来定义一个或多个图像候选地址，以<code>,</code>分割，每个候选地址将在特定条件下得以使用。候选地址包含图片 URL 和一个可选的宽度描述符和像素密度描述符，该候选地址用来在特定条件下替代原始地址成为 src  的属性。</p> <div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/files/16797/clock-demo-200px.png&quot;</span></span><span class="hljs-tag"> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Clock&quot;</span></span><span class="hljs-tag"> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;/files/16864/clock-demo-200px.png 1x, /files/16797/clock-demo-400px.png 2x&quot;</span>&gt;</span></code></pre></div></li><li><p>link标签</p><ul><li>link标签用来引入外部文件</li><li>link标签不阻碍浏览器加载和解析故放在head标签内可最大化提升页面加载速度</li></ul></li><li><p>渐进增强</p><ul><li><p>_优雅降级_：Web 站点在所有新式浏览器中都能正常工作，如果用户使用的是旧式浏览器，则代码会针对旧版本的 IE 进行降级处理，使之在旧式浏览器上以某种形式降级体验而不至于完全不能使用。</p></li><li><p>_渐进增强_：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能，向页面增加不影响基础浏览器的额外样式和功能。当浏览器支持时，它们会自定地呈现出来并发挥作用。</p></li></ul></li><li><p>“resetting” and “normalizing” CSS</p><p> 都是为了兼容各浏览器在布局和渲染时的不同</p><ul><li>resetting将去掉所有的浏览器默认样式</li><li>normalizing会保留部分有用的浏览器默认样式</li><li>normalizing是模块化的</li><li>normalizing修复了浏览器的bug</li><li>normalizing不会让调试工具变得杂乱</li></ul></li><li><p>z-index和层叠上下文</p><p> <code>z-index</code>:盒模型可以沿着三维坐标系中的z轴层叠摆放，用z-index来表明当前层在z轴中的位置，数字越大，元素越接近观察者。</p><p> <img src="../images/z-index.jpg" alt="z-index"><br>我们假定用户正面向（浏览器）视窗或网页，而 HTML 元素沿着其相对于用户的一条虚构的 z 轴排开，<code>层叠上下文</code>就是对这些 HTML 元素的一个三维构想。众 HTML 元素基于其元素属性按照优先级顺序占据这个空间。</p><p> 层叠上下文中的每一个元素都有一个<code>层叠水平</code>，决定了同！一！个！层叠上下文中元素在z轴上的显示顺序。</p></li></ol><ul><li>层叠上下文可以包含在其他层叠上下文中，并且一起创建一个层叠上下文的层级。</li><li>每个层叠上下文都完全独立于它的兄弟元素：当处理层叠时只考虑子元素。</li><li>每个层叠上下文都是自包含的：当一个元素的内容发生层叠后，该元素将被作为整体在父级层叠上下文中按顺序进行层叠。</li></ul><p>  层叠上下文的形成：</p><ul><li>根元素</li><li>定位元素<code>position</code> 值非 <code>static</code>且 <code>z-index</code> 值不为 <code>auto</code> 的元素；</li><li><code>flex/grid</code>容器的子元素</li><li><code>opacity</code>小于1</li><li><code>transform</code>不为’none’</li><li><code>filter</code>不为’none’</li></ul><ol><li><p>@media查询除了screen还能查询什么</p><ul><li>print打印</li><li>speech屏幕阅读器</li></ul></li><li><p>浏览器如何解析css选择器</p><p> 将选择器从右到左匹配解析，性能优于从左到右匹配，第一步就筛选了大量dom树中的叶子节点（最右节点</p></li><li><p>pseudo-element,pseudo-class</p><ul><li>伪元素是一个附加至选择器末的关键词，允许你对被选择元素的特定部分修改样式。</li><li>伪元素不存在真实的dom树中</li><li>一个选择器中只能使用一个伪元素。伪元素必须紧跟在语句中的简单选择器/基础选择器之后。</li></ul> <div class="hljs code-wrapper"><pre><code class="hljs javascript">::after (:after)::before (:before)::cue (:cue)::first-letter (:first-letter)::first-line (:first-line)</code></pre></div><ul><li>伪类 是添加到选择器的关键字，指定要选择的元素的特殊状态</li><li>用来操作dom中存在的实际元素</li></ul> <div class="hljs code-wrapper"><pre><code class="hljs javascript">:active:<span class="hljs-keyword">default</span>:checked:first-child:first-<span class="hljs-keyword">of</span>-type:focus:hover:last-child:last-<span class="hljs-keyword">of</span>-type:left:link:nth-child():nth-col() :nth-last-child():nth-last-col() :nth-last-<span class="hljs-keyword">of</span>-type():nth-<span class="hljs-keyword">of</span>-type():only-child:only-<span class="hljs-keyword">of</span>-type:visited</code></pre></div></li><li><p>盒模型</p><p> 在一个文档中，每个元素都被表示为一个矩形的盒子。确定这些盒子的尺寸, 属性和位置是渲染引擎的目标，css中用盒模型来描述这些盒子中的每一个所占的空间。</p></li><li><p>标准盒模型和IE盒模型</p><ul><li>content-box设置的宽高只是content的大小，整个盒子的尺寸还要加上内边距和边框</li><li>border-box设置宽高都是直接的可见宽高（包含内边距和边框</li><li>margin的大小计入盒模型的尺寸，该数值只影响盒子的外部空间</li></ul></li><li><p>display 属性</p><p> 指定了元素的显示类型，用于指定元素怎样生成盒模型 -&gt; 外部显示类型定义了元素怎样参与流式布局的处理，内部显示类型定义了元素内子元素的布局方式</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//外部显示类型</span>display: block;<span class="hljs-comment">// 块级元素，独占一行，默认填满父元素宽度，可以设置宽高和所有边距</span>display: inline;<span class="hljs-comment">// 行内元素，不能更改宽高，大小由内容撑开，只能设置左右的边距效果</span>display: inline-block;<span class="hljs-comment">// 块级行内元素，不占满一行，也可以设置所有宽高边距</span><span class="hljs-comment">//内部显示类型</span>display: flow;display: flow-root;display: table;display: flex;display: grid;<span class="hljs-comment">// </span>display: none;<span class="hljs-comment">//不显示</span>display: inherit;<span class="hljs-comment">//继承父元素的display属性</span></code></pre></div></li><li><p>nth-child和nth-of-type</p><ul><li><code>div:nth-child</code>父元素的第n个子元素div，！！如果第n个元素不是div元素则不生效</li><li><code>div:nth-of-type</code>父元素的第n个子div</li></ul></li><li><p>relative, fixed, absolute and statica</p><ul><li>relative  相对于其正常位置定位</li><li>fixed 相对于浏览器窗口定位</li><li>absolute 相对于static以外的第一个父元素进行定位</li><li>static 正常流中，忽略 top, bottom, left, right 或者 z-index 声明</li><li>inherit 继承自父元素</li></ul></li><li><p>响应式网站和移动端优先策略</p><ul><li>采用响应式设计，在不同设备中，网站会重新排列，展现出不同的设计风格，以完美的适配任何尺寸的屏幕</li><li>移动优先的响应式布局采用的是渐进增强原则，制作响应式网站时，先搞定手机版，然后再去为更大设备去设计和开发更复杂的功能。特征是使用min-width匹配页面宽度。书写样式时，首先考虑的是移动设备的使用场景，默认查询的是最窄的情况，再依次考虑设备屏幕逐渐变宽的情况</li></ul></li><li><p>视网膜屏幕，多倍屏</p><ul><li>媒体查询</li><li>svg图</li><li>多倍图</li></ul></li><li><p>translate和绝对定位加上left/top的区别</p><ul><li>translate改变元素的位置不会影响offsetTop和offsetLeft</li><li>改变translate不会导致页面重排</li></ul></li></ol><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><ol><li><p>console.log(“foo” &amp;&amp; “bar”)</p></li><li><p>console.log(“hello” || “world”)</p><ul><li>以下内容会被当成false处理：”” , false , 0 , null , undefined , NaN</li><li>布尔值的运算，运算到谁的时候-&gt;!得!出!结!果!&lt;-就返回谁</li></ul></li><li><p>IIFE立即执行函数</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//1</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;)()<span class="hljs-comment">//2</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;())</code></pre></div></li><li><p>this</p><p> <a href="https://medium.com/@arnav_aggarwal">https://medium.com/@arnav_aggarwal</a></p><p> 函数的调用方式决定了this的值</p><ol><li><code>new()</code>关键字函数内的this是一个全新的对象</li><li><code>apply/call/bind</code>方法函数内的this是传入的参数对象</li><li>函数作为方法被调用时，this是调用该函数的对象</li><li>都不符合则指向全局对象<code>window/global</code>,严格模式下为<code>undefined</code></li><li><code>箭头函数</code>的this是创建它的上下文</li><li>符合上述多个规则，按照优先级决定this的值得(1&gt;2&gt;3&gt;4)</li></ol></li><li><p><code>use strick</code>严格模式</p><ul><li>严格模式通过抛出错误（eg删除不可删除的属性）来消除了一些原有静默错误和编码错误。</li><li>严格模式修复了一些导致 JavaScript引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。</li><li>严格模式禁用了在ECMAScript的未来版本中可能会定义的一些语法。</li><li>无法再意外创建全局变量，全局作用域下，this的值为undefined。</li><li>要求函数的参数名卫唯一</li><li>在js文件顶部或function内部第一行声明使用严格模式</li></ul></li><li><p>undedined/null和未声明变量</p><ul><li>未声明变量：会脱离当前作用域变成全局下的变量，严格模式下会报错</li><li><code>undefined</code>：声明变量未赋值 / 无返回值的函数执行结果赋值给变量,只能用全等于和<code>typeof</code>来检查</li><li><code>null</code>只能显示赋值给变量，只能用全等于来检查</li></ul> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> foo === <span class="hljs-string">&#x27;undefined&#x27;</span>); <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span></code></pre></div></li></ol><ol><li><p>forEach和map</p><ul><li>遍历数组中的元素</li><li>为每个元素执行回调</li><li>都不修改原数组</li><li>forEach返回undefined</li><li>map返回映射出的新数组</li></ul></li><li><p>宿主对象</p><ul><li><p>原生对象是由 ECMAScript 规范定义的 JavaScript 内置对象，比如String、Math、RegExp、Object、Function等等。</p></li><li><p>宿主对象是由运行时环境（浏览器或 Node）提供，比如window、XMLHttpRequest等等。</p></li></ul></li><li><p>Ajax（异步js和XML，asynchronous JavaScript and XML）是描述使用现有技术标准(HTML,DOM,XMLHttpRequest,XML等)的新方法，网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面。js可以在后台异步与服务器进行数据交换并更新视图，目前普遍使用JSON格式来打包这些信息</p><ul><li>优点<ul><li>交互性更好。来自服务器的新内容可以动态更改，无需重新加载整个页面。</li><li>减少与服务器的连接，因为脚本和样式只需要被请求一次。</li><li>状态可以维护在一个页面上。JavaScript 变量和 DOM 状态将得到保持，因为主容器页面未被重新加载。</li></ul></li><li>缺点<ul><li>动态网页很难收藏。</li><li>如果 JavaScript 已在浏览器中被禁用，则不起作用。</li><li>有些网络爬虫不执行 JavaScript，也不会看到 JavaScript 加载的内容。</li></ul></li></ul></li><li><p>ajax的核心是通过<code>XmlHttpRequest API</code>获取非本页内容，而<code>jsonp</code>的核心则是动态添加<code>script标签</code>。</p></li><li><p>变量提升</p><ul><li>使用var关键字声明或初始化的变量，会将声明语句“提升”到当前作用域的顶部。赋值语句不提升</li><li>函数声明会提升整个函数体，函数表达式遵循变量提升规则</li></ul></li><li><p>==&amp;===</p><p> ===不会进行类型转换</p></li><li><p>同源</p><ul><li><p>同协议+同主机名+同端口</p></li><li><p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。如<code>Cookie</code>,<code>LocalStorage</code>,<code>indexDB</code>的读取，<code>DOM</code>的获取，<code>Ajax请求</code></p></li></ul></li><li><p>请解释单页应用是什么，如何使其对 SEO 友好。</p><ul><li><p>在过去，浏览器从服务器接收 HTML 并渲染。当用户导航到其它 URL 时，需要整页刷新，服务器会为新页面发送新的 HTML。这被称为服务器端渲染。</p></li><li><p>然而，在现代的 SPA 中，客户端渲染取而代之。浏览器从服务器加载初始页面、整个应用程序所需的脚本（框架、库、应用代码）和样式表。当用户导航到其他页面时，不会触发页面刷新。该页面的 URL 通过 HTML5 History API 进行更新。浏览器通过 AJAX 请求向服务器检索新页面所需的数据（通常采用 JSON 格式）。然后，SPA 通过 JavaScript 来动态更新页面，这些 JavaScript 脚本在初始页面加载时已经下载。这种模式类似于原生移动应用的工作方式。</p></li><li><p>好处：</p><ul><li>用户感知响应更快，用户切换页面时，不再看到因页面刷新而导致的白屏。</li><li>对服务器进行的 HTTP 请求减少，因为对于每个页面加载，不必再次下载相同的资源。</li><li>客户端和服务器之间的关注点分离。可以为不同平台（例如手机、聊天机器人、智能手表）建立新的客户端，而无需修改服务器代码。只要 API 没有修改，可以单独修改客户端和服务器上的代码。</li></ul></li><li><p>坏处：</p><ul><li>由于加载了多个页面所需的框架、应用代码和资源，导致初始页面加载时间较长。</li><li>服务器还需要进行额外的工作，需要将所有请求路由配置到单个入口点，然后由客户端接管路由。</li><li>SPA 依赖于 JavaScript 来呈现内容，但并非所有搜索引擎都在抓取过程中执行 JavaScript，可能抓不到内容</li></ul></li><li><p>spa的seo优化—&gt; SSR服务端渲染，将SEO关键信息在后端先渲染进HTML</p></li></ul></li><li><p><code>事件循环</code>是一个单线程循环，用于监视<code>调用栈</code>并检查是否有工作即将在<code>任务队列</code>中完成。如果<code>调用栈</code>为空并且<code>任务队列</code>中有<code>回调函数</code>，则将<code>回调函数</code>出队并推送到<code>调用栈</code>中执行。</p></li><li><p>es5和es6的构造函数方式</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// ES5 构造函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name, studentId</span>) </span>&#123;<span class="hljs-comment">// 调用父类的构造函数来初始化父类的成员变量</span>Person.call(<span class="hljs-built_in">this</span>, name);<span class="hljs-comment">// 初始化子类自己的成员变量</span><span class="hljs-built_in">this</span>.studentId = studentId;&#125;Student.prototype = <span class="hljs-built_in">Object</span>.create(Person.prototype);Student.prototype.constructor = Student;<span class="hljs-comment">// ES6 类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, studentId</span>)</span> &#123;    <span class="hljs-built_in">super</span>(name);    <span class="hljs-built_in">this</span>.studentId = studentId;&#125;&#125;</code></pre></div></li><li><p>一般函数的this只能在运行时确定，箭头函数的this则静态绑定了书写时的上下文</p></li><li><p>高阶函数</p><p> 函数作为参数进行数据处理或者返回函数</p><p> （forEach，filte人，reduce）</p></li><li><p>解构</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 数组解构</span><span class="hljs-comment">// 变量赋值</span><span class="hljs-keyword">const</span> foo = [<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>];<span class="hljs-keyword">const</span> [one, two, three] = foo;<span class="hljs-built_in">console</span>.log(one); <span class="hljs-comment">// &quot;one&quot;</span><span class="hljs-built_in">console</span>.log(two); <span class="hljs-comment">// &quot;two&quot;</span><span class="hljs-built_in">console</span>.log(three); <span class="hljs-comment">// &quot;three&quot;</span><span class="hljs-comment">// 变量交换</span><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> b = <span class="hljs-number">3</span>;[a, b] = [b, a];<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 3</span><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 1</span><span class="hljs-comment">// 对象解构</span><span class="hljs-comment">// 变量赋值</span><span class="hljs-keyword">const</span> o = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">42</span>, <span class="hljs-attr">q</span>: <span class="hljs-literal">true</span> &#125;;<span class="hljs-keyword">const</span> &#123; p, q &#125; = o;<span class="hljs-built_in">console</span>.log(p); <span class="hljs-comment">// 42</span><span class="hljs-built_in">console</span>.log(q); <span class="hljs-comment">// true</span></code></pre></div></li><li><p>es6模版字符串</p><ul><li>多行字符串</li><li>字符串插值</li></ul></li><li><p>静态类成员（属性或方法）不绑定到某个类的特定实例，不管哪个实例引用它，都具有相同的值。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>地址中输入URL回车发生了什么</title>
    <link href="/2019/09/05/%E8%BE%93%E5%85%A5URL%E5%9B%9E%E8%BD%A6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <url>/2019/09/05/%E8%BE%93%E5%85%A5URL%E5%9B%9E%E8%BD%A6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<ol><li><p>分析请求资源</p><ul><li><p>chrome资源分类</p></li><li><p>安全策略检查 </p><p>  网页安全政策（Content Security Policy，缩写 CSP）   是由浏览器提供的一种白名单制度。开发者通过配置，来告诉浏   览器各类外部资源的加载和执行限制，来提高网页的安全性。一种最常用的应用就是通过限制非信任域名脚本的加载来预防XSS攻击。</p><p>  可以通过两种方式来配置CSP：</p><ol><li>HTTP请求头的<code>Content-Security-Policy</code></li><li><code>meta</code>标签<div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;meta http-equiv=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> content=<span class="hljs-string">&quot;script-src &#x27;self&#x27;; style-src nos.netease.com kaola.com;&quot;</span>&gt;</code></pre></div></li></ol></li><li><p>资源优先级计算</p><ol><li><code>html,font,css</code></li><li><code>preload</code></li><li><code>img,pic,video</code></li><li><code>prefetch</code></li></ol></li><li><p>顺序调整</p><ol><li>同步XHR请求优先级调整到最高</li><li>图片根据是否出现在可视区域</li><li><code>async/defer</code>的<code>script</code>标签请求优先级降低<blockquote><p>async 异步加载js，加载完后运行js并暂停页面解析</p></blockquote></li></ol><blockquote><p>defer 异步加载js，页面解析完时运行</p></blockquote></li></ul></li></ol><div class="hljs code-wrapper"><pre><code>- 按照调整后的顺序请求资源</code></pre></div><ol><li><p>DNS解析</p><ul><li>查找本地DNS缓存</li><li>查找HOST文件</li><li>请求本地DNS服务器</li><li>查询本地DNS服务器缓存</li><li>本地服务器询向根域名服务器请求</li></ul></li><li><p>对应IP，端口建立TCP连接，发送HTTP请求</p><ul><li>TCP三次握手  <div class="hljs code-wrapper"><pre><code class="hljs javascript">client:SYN_Send-[ISN(c)]-&gt; server <span class="hljs-comment">// 半连接队列</span>client &lt;-[ISN(s)+ACK[ISN(c)+<span class="hljs-number">1</span>]]- server:REVDclient =[ACK[ISN(s)+<span class="hljs-number">1</span>]][请求]-&gt; server</code></pre></div></li><li>四次挥手断开TCP  <div class="hljs code-wrapper"><pre><code class="hljs javascript">client -[FIN_1]-&gt; server</code></pre></div></li></ul></li><li><p>应用缓存策略</p><ul><li>强缓存</li><li>协商缓存</li></ul></li><li><p>服务器响应请求返回资源，html，js，css</p></li><li><p>处理html标记，生成DOM树，所有标签都会包含在内</p><ul><li>解析完一个节点的所有子元素才会解析他的兄弟元素</li><li>构建过程中遇到js则执行js，暂停构建</li></ul></li><li><p>处理css标记（不管是内外联），生成CSSOM树</p><ul><li>构建过程中遇到js，js要等待CSSOM构建完才会执行</li><li>由于CSSOM负责存储渲染信息，浏览器必须保证在合成渲染树之前，CSSOM是完整的，这种完备是指所有的CSS（内联、内部和外部）都已经下载完，并解析完，只有CSSOM和DOM的解析完全结束，浏览器才会进入下一步的渲染，这就是传说中的CSS阻塞渲染。</li></ul></li></ol><ol><li><p>合成Render树，只包含DOM树中的可见元素(忽略像<code>display：none/&lt;header&gt;</code>)，并找到与其匹配的CSSOM规则并应用</p></li><li><p>【layout】浏览器依据Render树和设备屏幕信息<em>重排</em>一次，计算出每个节点的尺寸和在屏幕上的位置</p></li><li><p>【paint】绘制Render树像素信息</p></li><li><p>GPU合成各图层【composite】并显示在屏幕上</p></li></ol><h3 id="独立渲染层"><a href="#独立渲染层" class="headerlink" title="独立渲染层"></a>独立渲染层</h3><ul><li><p><code>will-change</code>属性</p></li><li><p><code>video</code>标签</p></li><li><p><code>canvas</code></p></li><li><p><code>WebGl</code></p></li><li><p><code>CSS3</code> 3D变换</p></li><li><p><code>CSS3</code> filter滤镜</p></li><li><p><code>z-index</code>大于兄弟元素</p></li><li><p><code>opacity</code></p></li><li><p>将原先的浏览器使用CPU绘制位图来实现的动画效果转为让GPU使用图层合成（composite）来实现，如果两张图层内部没有发生改变，浏览器就不再进行布局和绘制，直接使用GPU的缓存来绘制每个图层，GPU只负责将各个图层合成来实现动画，这就可以充分利用GPU的资源和优势，减轻CPU的负载，可以使动画更流畅。</p></li></ul><h3 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h3><ul><li>从 <code>&lt;html&gt;标签</code> 开始递归往下，依次计算所有的节点几何尺寸和位置</li><li>有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow，而是会把这样的操作积攒一批，然后做一次 处理，这又叫异步 reflow 或增量异步 reflow。但是在有些情况下，比如resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。</li><li>除了渲染树的直接变化，当获取一些属性时，浏览器为取得 正确的值也会触发重排。这样就使得浏览器的优化失效了。</li><li>这些属性包括：<code>offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、 clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。</code></li></ul><h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。</p><h3 id="优化性能"><a href="#优化性能" class="headerlink" title="优化性能"></a>优化性能</h3><blockquote><p>GPU硬件加速就是把会触发重排重绘的元素提升到独立渲染层</p></blockquote><ol><li>DOM style修改用css class代替</li><li><code>display:none</code>后修改,只有隐藏和显示两次重排</li><li>操作<code>Document Fragment</code>对象,<code>Document Fragment</code>是脱离真实DOM树结构的</li><li><code>opacity</code>代替<code>visibility</code></li><li>需要多次重排的元素使其脱离文档流<code>position:fixed/absolute</code></li><li>缓存需要读取的DOM属性，而不是读写写在一起<code>div.style.left = div.offsetLeft + 10 + &quot;px&quot;;</code></li><li>使用<code>transform</code>动画代替设置<code>left，right</code></li><li>避免table布局</li><li>虚拟DOM</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Intersection Observer API</title>
    <link href="/2019/07/17/Intersection%20Observer%20API/"/>
    <url>/2019/07/17/Intersection%20Observer%20API/</url>
    
    <content type="html"><![CDATA[<p><a href="MDN">https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API</a><br>一直以来，检测元素的可视状态或者两个元素的相对可视状态都不是件容易事，毕竟大部分解决办法并非完全可靠，也极易拖慢整个网站的性能。然而，随着网页发展，对上述检测的需求也随之增加了。多种情况下都需要用到元素交集变化的信息，比如：</p><ul><li>当页面滚动时，懒加载图片或其他内容。</li><li>实现“可无限滚动”网站，也就是当用户滚动网页时直接加载更多内容，无需翻页。</li><li>为计算广告收益，检测其广告元素的曝光情况。</li><li>根据用户是否已滚动到相应区域来灵活开始执行任务或动画。</li></ul><p>过去，交集检测通常需要涉及到事件监听，以及对每个目标元素执行<code>Element.getBoundingClientRect()</code> 方法以获取所需信息。可是这些代码都在主线程上运行，所以任何一点都可能造成性能问题。当网页遍布这些代码时就显得比较丑陋了。</p><h2 id="Intersection-Observer-API"><a href="#Intersection-Observer-API" class="headerlink" title="Intersection Observer API"></a><code>Intersection Observer API</code></h2><ul><li><p><code>Intersection Observer API</code> 允许你配置一个回调函数，每当目标(<code>target</code>)元素与设备视窗或者其他指定元素发生交集的时候执行。</p></li><li><p>设备视窗或者其他元素我们称它为根元素或根(<code>root</code>)。通常，您需要关注文档最接近的可滚动祖先元素的交集更改，如果元素不是可滚动元素的后代，则默认为设备视窗。如果要观察相对于根(<code>root</code>)元素的交集，请指定根(<code>root</code>)元素为<code>null</code>。</p></li><li><p><code>target element</code> 和 <code>root</code>的相交程度我们用<code>intersection ratio</code>来描述，它的取值在0.0和1.0之间。</p></li></ul><h2 id="option"><a href="#option" class="headerlink" title="option"></a><code>option</code></h2><ul><li><p><code>root</code></p><p>指定根(root)元素，用于检查目标的可见性。必须是目标元素的父级元素。如果未指定或者为null，则默认为浏览器视窗。</p></li><li><p><code>rootMargin</code></p><p>root元素的外边距。类似于css中的 margin 属性</p></li><li><p><code>threshold</code></p><p><code>target</code>元素和<code>root</code>元素<em>相交程度</em>达到该值的时候<code>IntersectionObserver</code>注册的回调函数将会被执行。</p><p>如果你只是想要探测当target元素的在root元素中的可见性超过50%的时候，你可以指定该属性值为0.5。如果你想要target元素在root元素的可见程度每多25%就执行一次回调，那么你可以指定一个数组[0, 0.25, 0.5, 0.75, 1]。默认值是0(意味着只要有一个target像素出现在root元素中，回调函数将会被执行)。该值为1.0含义是当target完全出现在root元素中时候 回调才会被执行。</p></li></ul><h2 id="IntersectionObserverEntry"><a href="#IntersectionObserverEntry" class="headerlink" title="IntersectionObserverEntry"></a><code>IntersectionObserverEntry</code></h2><p>只要目标满足为IntersectionObserver指定的阈值，就会调用回调。回调接收 IntersectionObserverEntry对象和观察者的列表：</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> callback = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">entries, observer</span>) </span>&#123;   entries.forEach(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> &#123;    <span class="hljs-comment">// Each entry describes an intersection change for one observed</span>    target element:      entry.boundingClientRect      entry.intersectionRatio      entry.intersectionRect      entry.isIntersecting      entry.rootBounds      entry.target      entry.time  &#125;);&#125;;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>dom</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据类型的判断与转换</title>
    <link href="/2019/07/15/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD%E4%B8%8E%E8%BD%AC%E6%8D%A2/"/>
    <url>/2019/07/15/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD%E4%B8%8E%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="ECAMScript-中不能自定义数据类型，只能为下列-7-种"><a href="#ECAMScript-中不能自定义数据类型，只能为下列-7-种" class="headerlink" title="ECAMScript 中不能自定义数据类型，只能为下列 7 种"></a>ECAMScript 中不能自定义数据类型，只能为下列 7 种</h1><h2 id="简单数据类型（原始类型）"><a href="#简单数据类型（原始类型）" class="headerlink" title="简单数据类型（原始类型）"></a>简单数据类型（原始类型）</h2><ul><li><p><code>String</code></p></li><li><p><code>Number</code></p><ul><li>特殊的<code>NaN</code><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">NaN</span> === <span class="hljs-string">&#x27;number&#x27;</span>唯一一个自相反的值<span class="hljs-literal">NaN</span> !== <span class="hljs-literal">NaN</span></code></pre></div></li></ul></li><li><p><code>Boolean</code></p><ul><li>在条件判断时，除了 <code>undefined</code>， <code>null</code>， <code>false</code>， <code>NaN</code>， <code>&#39;&#39;</code>， <code>0</code>， <code>-0</code>，其他所有值都转为 true，包括所有对象。</li></ul></li><li><p><code>Null</code></p><ul><li><code>typeof null = object</code>,<em>null 表示一个空对象指针</em></li><li>null 必须手动设置，常用于作为参数传入，说明该参数不是对象</li><li>设置为 null 的变量或者对象会被内存收集器回收</li><li>null 转为数字类型值为 0</li><li>Null 和 Undefined</li><li>if 为 false</li></ul></li><li><p><code>Undefined</code></p><ul><li>调用一个值而它本身没有赋值</li><li><code>undefined == null</code> 两个等号</li><li>undefined 转为数字类型为 NaN</li><li>if 为 false</li></ul></li><li><p><code>Symbol</code>[ES6 新增]</p><ul><li>表示独一无二的值</li></ul></li></ul><h2 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h2><p><code>Object</code></p><ul><li>引用类型的值是指向保存在堆中的对象的指针</li><li>使用时要先从栈中读取内存地址，再沿着指针找到堆中的对象</li><li>Object</li><li>Array<ul><li>数组的每一项可以用来保存任何类型的数据</li></ul></li><li>Function<ul><li>每个函数都是 Function 的实例</li></ul></li></ul><h1 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h1><h2 id="typeOf"><a href="#typeOf" class="headerlink" title="typeOf"></a><code>typeOf</code></h2><ul><li>对未声明的变量，只能执行一个有用的操作，就是对它调用<code>typeof</code>,不报错，return <code>undefined</code></li><li>特殊的几个</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// &#x27;undefined&#x27;</span><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span>(); <span class="hljs-comment">// &#x27;symbol&#x27;</span><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// &#x27;object&#x27;</span><span class="hljs-keyword">typeof</span> <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// number</span></code></pre></div><h2 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN"></a><code>isNaN</code></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">NaN</span>));    <span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-number">10</span>));     <span class="hljs-comment">//false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;10&quot;</span>));   <span class="hljs-comment">//  false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;blue&quot;</span>)); <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">true</span>));   <span class="hljs-comment">// false</span></code></pre></div><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h2><p><code>instanceof</code> 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性，但它不能检测<code>null</code> 和 <code>undefined</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript">[] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> <span class="hljs-comment">// true</span>&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span> <span class="hljs-comment">// true</span><span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>() <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span> <span class="hljs-comment">// true</span><span class="hljs-literal">null</span> <span class="hljs-keyword">instanceof</span> Null <span class="hljs-comment">// error</span><span class="hljs-literal">undefined</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-literal">undefined</span> <span class="hljs-comment">// error</span></code></pre></div><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><code>constructor</code></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [];<span class="hljs-keyword">const</span> obj = &#123;&#125;;<span class="hljs-built_in">console</span>.log(arr.constructor); <span class="hljs-comment">// [Function: Array]</span><span class="hljs-built_in">console</span>.log(obj.constructor); <span class="hljs-comment">// [Function: Object]</span></code></pre></div><h2 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a><code>Object.prototype.toString.call()</code></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.toString.call(); <span class="hljs-comment">// [object Undefined]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// [object String]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-number">1</span>); <span class="hljs-comment">// [object Number]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">true</span>); <span class="hljs-comment">// [object Boolean]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// [object Undefined]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">null</span>); <span class="hljs-comment">// [object Null]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>()); <span class="hljs-comment">// [object Function]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()); <span class="hljs-comment">// [object Date]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>()); <span class="hljs-comment">// [object RegExp]</span><span class="hljs-built_in">Object</span>.prototype.toString.call([]); <span class="hljs-comment">// [object Array]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(&#123;&#125;); <span class="hljs-comment">// [object Object]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>()); <span class="hljs-comment">// [object Error]</span></code></pre></div><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="转为数值"><a href="#转为数值" class="headerlink" title="转为数值"></a>转为数值</h2><h3 id="Number-适用于任何类型"><a href="#Number-适用于任何类型" class="headerlink" title="Number() 适用于任何类型"></a>Number() 适用于任何类型</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;Hello world!&quot;</span>);  <span class="hljs-comment">// NaN</span><span class="hljs-keyword">let</span> num2 = <span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 0</span><span class="hljs-keyword">let</span> num3 = <span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;000011&quot;</span>); <span class="hljs-comment">// 11</span><span class="hljs-keyword">let</span> num4 = <span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 1</span></code></pre></div><h3 id="parseInt-主要用于字符串"><a href="#parseInt-主要用于字符串" class="headerlink" title="parseInt() 主要用于字符串"></a>parseInt() 主要用于字符串</h3><ul><li>如果第一个字符不是数值字符、加号或减号，立即返回NaN<br>。这意味着空字符串也会返回 <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num2 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;&quot;</span>);  <span class="hljs-comment">// NaN</span><span class="hljs-keyword">let</span> num3 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;0xA&quot;</span>); <span class="hljs-comment">// 10</span><span class="hljs-keyword">let</span> num4 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-number">22.5</span>); <span class="hljs-comment">//22</span><span class="hljs-keyword">let</span> num5 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">// NaN</span><span class="hljs-keyword">let</span> num6 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;123abc&quot;</span>) <span class="hljs-comment">// 123</span></code></pre></div><h3 id="parseFloat-主要用于字符串"><a href="#parseFloat-主要用于字符串" class="headerlink" title="parseFloat() 主要用于字符串"></a>parseFloat() 主要用于字符串</h3></li><li>只解析十进制</li><li>忽略其次出现的小数点<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;1234blue&quot;</span>); <span class="hljs-comment">// 1234</span><span class="hljs-keyword">let</span> num2 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;0xA&quot;</span>); <span class="hljs-comment">// 0</span><span class="hljs-keyword">let</span> num3 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;22.5&quot;</span>); <span class="hljs-comment">// 22.5</span><span class="hljs-keyword">let</span> num4 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;22.34.5&quot;</span>); <span class="hljs-comment">// 22.34</span><span class="hljs-keyword">let</span> num5 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;0908.5&quot;</span>);  <span class="hljs-comment">//908.5</span><span class="hljs-keyword">let</span> num6 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;3.125e7&quot;</span>); <span class="hljs-comment">// 31250000</span></code></pre></div></li></ul><h2 id="转为字符串"><a href="#转为字符串" class="headerlink" title="转为字符串"></a>转为字符串</h2><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><ul><li>null和undefined没有toString()方法<br>String()<h3 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h3></li><li><em>优先调用toString()</em></li><li>null 转换为 ‘null’</li><li>undefined 转换为 ‘undefined’</li></ul><h2 id="转为布尔值"><a href="#转为布尔值" class="headerlink" title="转为布尔值"></a>转为布尔值</h2><ul><li>Boolean()<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//除了以下六个转为 false 其他全部都为 true</span><span class="hljs-literal">undefined</span><span class="hljs-literal">null</span><span class="hljs-number">0</span><span class="hljs-literal">NaN</span><span class="hljs-string">&#x27;&#x27;</span></code></pre></div></li></ul><h1 id="隐式转换介绍"><a href="#隐式转换介绍" class="headerlink" title="隐式转换介绍"></a>隐式转换介绍</h1><ul><li>在 js 中，当运算符在运算时，如果两边数据不统一，CPU 就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算</li><li>这种无需程序员手动转换，而由编译器自动转换的方式就称为隐式转换</li><li>例如 1 &gt; “0”这行代码在 js 中并不会报错，编译器在运算符时会先把右边的”0”转成数字 0`然后在比较大小</li></ul><h2 id="隐式转换规则"><a href="#隐式转换规则" class="headerlink" title="隐式转换规则"></a>隐式转换规则</h2><ul><li>转成 string 类型： +（字符串连接符）</li><li>转成 number 类型：++/–(自增自减运算符) + - * / %(算术运算符) &gt; &lt; &gt;= &lt;= == != === !=== (关系运算符)</li><li>转成 boolean 类型：!（逻辑非运算符）</li></ul><h2 id="字符串连接符与算术运算符隐式转换规则混淆"><a href="#字符串连接符与算术运算符隐式转换规则混淆" class="headerlink" title="字符串连接符与算术运算符隐式转换规则混淆"></a>字符串连接符与算术运算符隐式转换规则混淆</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 常见面试题如下</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-string">&quot;true&quot;</span>); <span class="hljs-comment">// ‘1true‘’</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-literal">true</span>); <span class="hljs-comment">//2</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-literal">undefined</span>); <span class="hljs-comment">//   NaN</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-literal">null</span>); <span class="hljs-comment">//1</span></code></pre></div><ol><li>字符串连接符+：会把其他数据类型调用 String()方法转成字符串然后拼接</li><li>算术运算符+ ：会把其他数据类型调用 Number（）方法转成数字然后做加法计算</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//+是字符串连接符： String(1) + &#x27;true&#x27; = &#x27;1true&#x27;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-string">&quot;true&quot;</span>); <span class="hljs-comment">//1true</span><span class="hljs-comment">//+是算术运算符 ： 1 + Number(true) = 1 + 1 = 2</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-literal">true</span>); <span class="hljs-comment">//2</span><span class="hljs-comment">// +是算术运算符 ： 1 + Number(undefined) = 1 + NaN = NaN</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-literal">undefined</span>); <span class="hljs-comment">//   NaN</span><span class="hljs-comment">// +是算术运算符 ： 1 + Number(null) = 1 + 0 = 1</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-literal">null</span>); <span class="hljs-comment">//1</span><span class="hljs-comment">//</span></code></pre></div><h2 id="关系运算符：会把其他数据类型转换成-number-之后再比较关系"><a href="#关系运算符：会把其他数据类型转换成-number-之后再比较关系" class="headerlink" title="关系运算符：会把其他数据类型转换成 number 之后再比较关系"></a>关系运算符：会把其他数据类型转换成 number 之后再比较关系</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 常见面试题如下</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> &gt; <span class="hljs-number">10</span>); <span class="hljs-comment">//false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> &gt; <span class="hljs-string">&quot;10&quot;</span>); <span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;abc&quot;</span> &gt; <span class="hljs-string">&quot;b&quot;</span>); <span class="hljs-comment">//false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;abc&quot;</span> &gt; <span class="hljs-string">&quot;aad&quot;</span>); <span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">NaN</span> == <span class="hljs-literal">NaN</span>); <span class="hljs-comment">//false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-literal">null</span>); <span class="hljs-comment">//true</span></code></pre></div><ol><li>当关系运算符两边有一边是字符串的时候，会将其他数据类型使用 Number()转换，然后比较关系<br><code>console.log ( &quot;2&quot; &gt; 10 );//false Number(&#39;2&#39;) &gt; 10 = 2 &gt; 10 = false</code></li><li>当关系运算符两边都是字符串的时候，此时同时转成 number 然后比较关系<br><em>此时并不是按照 Number()的形式转成数字，而是按照字符串对应的 unicode 编码来转成数字</em><blockquote><p>使用这个方法可以查看字符的 unicode 编码： 字符串.charCodeAt(字符下标，默认为 0)</p></blockquote></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> &gt; <span class="hljs-string">&quot;10&quot;</span>); <span class="hljs-comment">//true     &#x27;2&#x27;.charCodeAt() &gt; &#x27;10&#x27;.charCodeAt() = 50 &gt; 49 = true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span>.charCodeAt()); <span class="hljs-comment">//数字50</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;10&quot;</span>.charCodeAt()); <span class="hljs-comment">//数字49（默认返回第一个字符的编码，如果想要查询第二个字符可以传参下标）</span><span class="hljs-comment">//多个字符从左往右依次比较</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;abc&quot;</span> &gt; <span class="hljs-string">&quot;b&quot;</span>); <span class="hljs-comment">//false     先比较&#x27;a&#x27; 和 &#x27;b&#x27;， &#x27;a&#x27; 与 &#x27;b&#x27;不等，则直接得出结果</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;abc&quot;</span> &gt; <span class="hljs-string">&quot;aad&quot;</span>); <span class="hljs-comment">//true     先比较&#x27;a&#x27;和&#x27;a&#x27;，两者相等，继续比较第二个字符 &#x27;b&#x27; 与 &#x27;a&#x27; ,得出结果</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a&quot;</span>.charCodeAt()); <span class="hljs-comment">//数字97</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;b&quot;</span>.charCodeAt()); <span class="hljs-comment">//数字98</span><span class="hljs-comment">//2.3 特殊情况(无视规则)：如果数据类型是undefined与null，，得出固定的结果</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-literal">undefined</span>); <span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-literal">null</span>); <span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">null</span>); <span class="hljs-comment">//true</span><span class="hljs-comment">//2.4 特殊情况（无视规则）：NaN与任何数据比较都是NaN</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">NaN</span> == <span class="hljs-literal">NaN</span>); <span class="hljs-comment">//false</span></code></pre></div><h2 id="复杂数据类型在隐式转换时会先转成-String，然后再转成-Number-运算"><a href="#复杂数据类型在隐式转换时会先转成-String，然后再转成-Number-运算" class="headerlink" title="复杂数据类型在隐式转换时会先转成 String，然后再转成 Number 运算"></a>复杂数据类型在隐式转换时会先转成 String，然后再转成 Number 运算</h2><p>复杂数据类型转 number 顺序如下</p><ol><li>先使用<code>valueOf()</code>方法获取其原始值，如果原始值不是<code>number</code>类型，则使用 <code>toString()</code>方法转成<code>string</code></li><li>再将 string 转成 number 运算</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] == <span class="hljs-string">&quot;1,2&quot;</span>); <span class="hljs-comment">//true     先将左边数组转成string，然后右边也是string则转成unicode编码运算</span><span class="hljs-built_in">console</span>.log([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].valueOf()); <span class="hljs-comment">// [1,2]</span><span class="hljs-built_in">console</span>.log([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].toString()); <span class="hljs-comment">// &#x27;1,2&#x27;</span><span class="hljs-keyword">var</span> a = &#123;&#125;;<span class="hljs-built_in">console</span>.log(a == <span class="hljs-string">&quot;[object Object]&quot;</span>); <span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(a.valueOf().toString()); <span class="hljs-comment">//[object Object]</span><span class="hljs-comment">//分析：逻辑与运算一假则假，要想if分支语句小括号条件成立，则必须要让a的值同时等于1 且 等于 2 且等于3乍看之下，好像根本不可能实现，但是复杂数据类型会先调用valueOf()方法,然后转成number运算而对象的</span></code></pre></div><h2 id="逻辑非隐式转换与关系运算符隐式转换搞混淆"><a href="#逻辑非隐式转换与关系运算符隐式转换搞混淆" class="headerlink" title="逻辑非隐式转换与关系运算符隐式转换搞混淆"></a>逻辑非隐式转换与关系运算符隐式转换搞混淆</h2><ul><li>空数组的 toString()方法会得到空字符串，而空对象的 toString()方法会得到字符串<code>[object Object]</code> （注意第一个小写 o，第二个大写 O 哟）</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>([])); <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(![])); <span class="hljs-comment">// false</span><span class="hljs-comment">//大坑</span><span class="hljs-built_in">console</span>.log([] == <span class="hljs-number">0</span>); <span class="hljs-comment">//true []转数字为0</span><span class="hljs-built_in">console</span>.log(![] == <span class="hljs-number">0</span>); <span class="hljs-comment">//true  ![]转布尔false，转数字为0</span><span class="hljs-comment">//神坑</span><span class="hljs-built_in">console</span>.log([] == ![]); <span class="hljs-comment">//true</span><span class="hljs-comment">// [object Object] == false</span><span class="hljs-built_in">console</span>.log([] == []); <span class="hljs-comment">//false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(!&#123;&#125;)); <span class="hljs-comment">// false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(&#123;&#125;)); <span class="hljs-comment">//  true</span><span class="hljs-comment">//史诗级坑</span><span class="hljs-built_in">console</span>.log(&#123;&#125; == !&#123;&#125;); <span class="hljs-comment">//false</span><span class="hljs-comment">// [object Object] == false</span><span class="hljs-built_in">console</span>.log(&#123;&#125; == &#123;&#125;); <span class="hljs-comment">//false</span></code></pre></div><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><ol><li><p>关系运算符：将其他数据类型转成数字</p></li><li><p>逻辑非：将其他数据类型使用<code>Boolean()</code>转成布尔类型</p></li><li><p>以下八种情况转换为布尔类型会得到 false</p><p><code>0 、-0、NaN、undefined、null、&#39;&#39;(空字符串)、false、document.all()</code></p></li><li><p>除以上八种情况之外所有数据都会得到 true</p></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript">[].valueOf().toString(); <span class="hljs-comment">// 得到空字符串</span><span class="hljs-comment">// Number(&#x27;&#x27;) == 0 成立</span><span class="hljs-built_in">console</span>.log([] == <span class="hljs-number">0</span>); <span class="hljs-comment">//true</span>------------------------------------------------<span class="hljs-comment">// 原理 :本质是 `![]` 逻辑非表达式结果 与   0 比较关系</span><span class="hljs-comment">// (1)逻辑非优先级高于关系运算符</span>![] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 空数组转布尔得到true，然后取反得到false</span><span class="hljs-comment">// (2)false == 0 成立</span><span class="hljs-built_in">console</span>.log(![] == <span class="hljs-number">0</span>); <span class="hljs-comment">//true</span>------------------------------------------------<span class="hljs-comment">// 原理 ：本质其实是 `空对象&#123;&#125;`   与   `!&#123;&#125;`   这个逻辑非表达式结果做比较</span>&#123;&#125;.valueOf().toString(); <span class="hljs-comment">// &#x27;[object Object]&#x27;</span>!&#123;&#125; = <span class="hljs-literal">false</span>;<span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;[object Object]&quot;</span>) == <span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>);<span class="hljs-built_in">console</span>.log(&#123;&#125; == !&#123;&#125;); <span class="hljs-comment">//false</span>------------------------------------------------<span class="hljs-comment">// 引用类型数据存在堆中，栈中存储的是地址，所以他们的结果是false</span><span class="hljs-built_in">console</span>.log(&#123;&#125; == &#123;&#125;); <span class="hljs-comment">//false</span>------------------------------------------------<span class="hljs-comment">// 原理：本质是 `空数组[]`与 `![]` 这个逻辑非表达式结果做比较</span>[].valueOf().toString(); <span class="hljs-comment">// &#x27;&#x27;</span>![] = <span class="hljs-literal">false</span>;<span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;&quot;</span>) == <span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 0 == 0</span><span class="hljs-built_in">console</span>.log([] == ![]); <span class="hljs-comment">//true</span>------------------------------------------------<span class="hljs-comment">// 引用类型数据存在堆中，栈中存储的是地址，所以他们的结果是false</span><span class="hljs-built_in">console</span>.log([] == []); <span class="hljs-comment">//false</span>------------------------------------------------<span class="hljs-built_in">console</span>.log(  &#123;&#125;.valueOf().toString()); <span class="hljs-comment">//[object Object]</span><span class="hljs-built_in">console</span>.log([].valueOf().toString()); <span class="hljs-comment">//&#x27;&#x27; 空字符串</span></code></pre></div><h1 id="类型转换的场景"><a href="#类型转换的场景" class="headerlink" title="类型转换的场景"></a>类型转换的场景</h1><h3 id="转换为-String-的场景"><a href="#转换为-String-的场景" class="headerlink" title="转换为 String 的场景"></a>转换为 String 的场景</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">//21</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> + <span class="hljs-literal">true</span>); <span class="hljs-comment">// 2true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> + <span class="hljs-literal">null</span>); <span class="hljs-comment">// 2null</span><span class="hljs-keyword">var</span> obj2 = &#123;  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a&quot;</span>;  &#125;,&#125;;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> + obj2); <span class="hljs-comment">// 2a</span><span class="hljs-keyword">var</span> obj1 = &#123;  a: <span class="hljs-number">1</span>,  b: <span class="hljs-number">2</span>,&#125;;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> + obj1); <span class="hljs-comment">//2obj1</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> + &#123;&#125;); <span class="hljs-comment">// 2[object Object]</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> + []); <span class="hljs-comment">// 2[object Object]</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> + <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;); <span class="hljs-comment">// 2</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> + [<span class="hljs-string">&quot;msy&quot;</span>, <span class="hljs-number">123</span>]); <span class="hljs-comment">// 2msy,123</span></code></pre></div><h3 id="转换为-Number-的场景"><a href="#转换为-Number-的场景" class="headerlink" title="转换为 Number 的场景"></a>转换为 Number 的场景</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>)); <span class="hljs-comment">// 0</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>)); <span class="hljs-comment">// 1</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 2</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> + <span class="hljs-string">&quot;5&quot;</span>); <span class="hljs-comment">// 25</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> - <span class="hljs-number">6</span>); <span class="hljs-comment">// -6</span><span class="hljs-built_in">console</span>.log([] * <span class="hljs-number">6</span>); <span class="hljs-comment">// 0</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> / <span class="hljs-string">&quot;5&quot;</span>); <span class="hljs-comment">// 0.2</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> / <span class="hljs-number">5</span>); <span class="hljs-comment">// 0.2</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> / <span class="hljs-number">5</span>); <span class="hljs-comment">// 0</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;abc&quot;</span>)); <span class="hljs-comment">// NaN</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>)); <span class="hljs-comment">// 0</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// NaN</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-literal">true</span>); <span class="hljs-comment">//abctrue</span></code></pre></div><h3 id=""><a href="#" class="headerlink" title="[]"></a>[]</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">[] == ![]; <span class="hljs-comment">// true</span><span class="hljs-comment">// &#x27;&#x27; == 0</span><span class="hljs-built_in">console</span>.log(![]); <span class="hljs-comment">// false</span><span class="hljs-built_in">console</span>.log([]); <span class="hljs-comment">// []</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(![])); <span class="hljs-comment">// 0</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([])); <span class="hljs-comment">// 0</span></code></pre></div><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>什么时候返回 NaN （开篇第二道题也得到解决）</p><ul><li>无穷大除以无穷大</li><li>给任意负数做开方运算</li><li>算数运算符与不是数字或无法转换为数字的操作数一起使用</li><li>字符串解析成数字</li><li>一元运算符</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(+<span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">// NaN</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;abc&quot;</span>);</code></pre></div><h3 id="String-和-toString"><a href="#String-和-toString" class="headerlink" title="String 和 toString"></a>String 和 toString</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// toString()可以将数据都转为字符串，但是null和undefined不可以转换。</span><span class="hljs-comment">// 可以转进制</span><span class="hljs-literal">null</span>.toString(); <span class="hljs-comment">//报错</span><span class="hljs-literal">undefined</span>.toString(); <span class="hljs-comment">//报错</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// String()可以将null和undefined转换为字符串，但是没法转进制字符串</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>(<span class="hljs-literal">null</span>));<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>(<span class="hljs-literal">undefined</span>));</code></pre></div><h2 id="值的比较"><a href="#值的比较" class="headerlink" title="值的比较"></a>值的比较</h2><h3 id="es6-新增Object-is-判断"><a href="#es6-新增Object-is-判断" class="headerlink" title="es6 新增Object.is()判断"></a>es6 新增<code>Object.is()</code>判断</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// true</span><span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span><span class="hljs-built_in">Object</span>.is(<span class="hljs-number">0</span>, -<span class="hljs-number">0</span>); <span class="hljs-comment">// false</span><span class="hljs-built_in">Object</span>.is(<span class="hljs-number">0</span>, +<span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><span class="hljs-built_in">Object</span>.is(-<span class="hljs-number">0</span>, -<span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">NaN</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// false</span><span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">NaN</span>, <span class="hljs-number">0</span> / <span class="hljs-number">0</span>); <span class="hljs-comment">// true</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_Object</span>.<span class="hljs-title">is</span>(<span class="hljs-params">x,y</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Object</span>.is)&#123;    <span class="hljs-keyword">if</span>(x===y)&#123;      <span class="hljs-keyword">return</span> x!==<span class="hljs-number">0</span> || <span class="hljs-number">1</span>/x === <span class="hljs-number">1</span>/y    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-keyword">return</span> x!==x &amp;&amp; y!== y    &#125;  &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vuex</title>
    <link href="/2019/07/14/vuex/"/>
    <url>/2019/07/14/vuex/</url>
    
    <content type="html"><![CDATA[<h2 id="vue全局的状态管理器，每个应用唯一"><a href="#vue全局的状态管理器，每个应用唯一" class="headerlink" title="vue全局的状态管理器，每个应用唯一"></a>vue全局的状态管理器，每个应用唯一</h2><h2 id="State"><a href="#State" class="headerlink" title="State"></a><code>State</code></h2><ul><li><p>子组件通过<code>computed</code>读取state，</p></li><li><p><code>mapState</code>辅助函数展开以混入计算属性中  </p><div class="hljs code-wrapper"><pre><code class="hljs javascript">computed: &#123;  localComputed () &#123; <span class="hljs-comment">/* ... */</span> &#125;,  <span class="hljs-comment">// 使用对象展开运算符将此对象混入到外部对象中</span>  ...mapState(&#123;  <span class="hljs-comment">// ...</span>    <span class="hljs-string">&#x27;count&#x27;</span>    <span class="hljs-comment">// 映射 this.count 为 store.state.count</span>  &#125;)&#125;</code></pre></div></li></ul><h2 id="getter"><a href="#getter" class="headerlink" title="getter"></a><code>getter</code></h2><ul><li><p>相当于store的计算属性</p></li><li><p>接受<code>state</code>作为其第一个参数</p></li><li><p>通过属性访问（被缓存，依赖改变才计算）</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;  state: &#123;    todos: [&#123;        id: <span class="hljs-number">1</span>,        text: <span class="hljs-string">&#x27;...&#x27;</span>,        done: <span class="hljs-literal">true</span>      &#125;,      &#123;        id: <span class="hljs-number">2</span>,        text: <span class="hljs-string">&#x27;...&#x27;</span>,        done: <span class="hljs-literal">false</span>      &#125;    ]  &#125;,  getters: &#123;    doneTodos: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> state.todos.filter(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.done)    &#125;  &#125;&#125;)store.getters.doneTodos <span class="hljs-comment">// -&gt; [&#123; id: 1, text: &#x27;...&#x27;, done: true &#125;]</span></code></pre></div></li><li><p>通过方法访问（每次调用都计算,不缓存结果）</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">getters: &#123;  <span class="hljs-comment">// ...</span>  getTodoById: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> state.todos.find(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.id === id)  &#125;&#125;store.getters.getTodoById(<span class="hljs-number">2</span>) <span class="hljs-comment">// -&gt; &#123; id: 2, text: &#x27;...&#x27;, done: false &#125;</span></code></pre></div></li><li><p>组件中一样的展开<code>...mapGetters</code>到局部计算属性中</p></li></ul><h2 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a><code>Mutations</code></h2><ul><li><p>更改<code>state</code>的唯一方法是提交<code>mutation</code></p></li><li><p>你不能直接调用一个 <code>mutation handler</code>。需要以相应的 <code>type</code> 调用 <code>store.commit</code> 方法</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 载荷风格</span>store.commit(<span class="hljs-string">&#x27;increment&#x27;</span>,&#123;  amount:<span class="hljs-number">10</span>&#125;)<span class="hljs-comment">// 对象风格的提交</span>store.commit(&#123;  type: <span class="hljs-string">&#x27;increment&#x27;</span>,  amount: <span class="hljs-number">10</span>&#125;)mutations: &#123;  <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params">state, payload</span>)</span> &#123;    state.count += payload.amount  &#125;&#125;</code></pre></div></li><li><p><code>mutation</code>必须是同步函数,<code>mutation</code>中对<code>state</code>的修改立即完成</p></li><li><p>组件中一样的展开<code>...Mutations</code>到局部计算属性中</p></li></ul><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a><code>Action</code></h2><ul><li><p><code>Action</code> 函数接受一个与<code>store</code>实例具有相同方法和属性的 <code>context</code> 对象，不是 <code>store </code>实例本身</p></li><li><p><code>context.commit</code> 提交一个 <code>mutation</code>，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 <code>state</code> 和 <code>getters</code></p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">actions: &#123;    increment (context) &#123;      context.commit(<span class="hljs-string">&#x27;increment&#x27;</span>)    &#125;  &#125;<span class="hljs-comment">// 参数解构</span>actions: &#123;  increment (&#123; commit &#125;) &#123;    commit(<span class="hljs-string">&#x27;increment&#x27;</span>)  &#125;&#125;</code></pre></div><ul><li><p><code>Action</code> 提交的是 <code>mutation</code>，而不是直接变更状态。</p></li><li><p><code>Action</code> 可以包含任意异步操作。</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 以载荷形式分发</span>store.dispatch(<span class="hljs-string">&#x27;incrementAsync&#x27;</span>, &#123;  amount: <span class="hljs-number">10</span>&#125;)<span class="hljs-comment">// 以对象形式分发</span>store.dispatch(&#123;  type: <span class="hljs-string">&#x27;incrementAsync&#x27;</span>,  amount: <span class="hljs-number">10</span>&#125;)</code></pre></div></li><li><p>组件中分发<code>...mapActions</code></p></li></ul><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a><code>Module</code></h2><p>将 <code>store</code> 分割成模块（<code>module</code>）。每个模块拥有自己的<code>state、mutation、action、getter、</code>甚至是嵌套子模块</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> moduleA = &#123;  state: &#123; ... &#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;,  getters: &#123; ... &#125;&#125;<span class="hljs-keyword">const</span> moduleB = &#123;  state: &#123; ... &#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;&#125;<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;  modules: &#123;    a: moduleA,    b: moduleB  &#125;&#125;)</code></pre></div><ul><li>内部的<code>mutation</code> 接收的<code>state</code>是<em>模块的局部状态对象</em></li><li>内部的<code>getter</code>,<em>模块的局部状态对象</em><code>state</code>，<em>根节点状态</em><code>rootState</code></li><li>模块内部的 <code>action</code>，<em>局部状态</em>通过 <code>context.state</code> 暴露出来，<em>根节点状态</em>则为 <code>context.rootState</code></li></ul><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><ul><li><code>namespaced:true</code></li><li>命名空间中的方法只会访问本模块的内容</li></ul><h4 id="在带命名空间的模块内访问全局内容"><a href="#在带命名空间的模块内访问全局内容" class="headerlink" title="在带命名空间的模块内访问全局内容"></a>在带命名空间的模块内访问全局内容</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">modules: &#123;  foo: &#123;    namespaced: <span class="hljs-literal">true</span>,    getters: &#123;      <span class="hljs-comment">// 在这个模块的 getter 中，`getters` 被局部化了</span>      <span class="hljs-comment">// 你可以使用 getter 的第四个参数来调用 `rootGetters`</span>      someGetter (state, getters, rootState, rootGetters) &#123;        getters.someOtherGetter <span class="hljs-comment">// -&gt; &#x27;foo/someOtherGetter&#x27;</span>        rootGetters.someOtherGetter <span class="hljs-comment">// -&gt; &#x27;someOtherGetter&#x27;</span>      &#125;,      someOtherGetter: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123; ... &#125;    &#125;,    actions: &#123;      <span class="hljs-comment">// 在这个模块中， dispatch 和 commit 也被局部化了</span>      <span class="hljs-comment">// 他们可以接受 `root` 属性以访问根 dispatch 或 commit</span>      someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;        getters.someGetter <span class="hljs-comment">// -&gt; &#x27;foo/someGetter&#x27;</span>        rootGetters.someGetter <span class="hljs-comment">// -&gt; &#x27;someGetter&#x27;</span>        dispatch(<span class="hljs-string">&#x27;someOtherAction&#x27;</span>) <span class="hljs-comment">// -&gt; &#x27;foo/someOtherAction&#x27;</span>        dispatch(<span class="hljs-string">&#x27;someOtherAction&#x27;</span>, <span class="hljs-literal">null</span>, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;) <span class="hljs-comment">// -&gt; &#x27;someOtherAction&#x27;</span>        commit(<span class="hljs-string">&#x27;someMutation&#x27;</span>) <span class="hljs-comment">// -&gt; &#x27;foo/someMutation&#x27;</span>        commit(<span class="hljs-string">&#x27;someMutation&#x27;</span>, <span class="hljs-literal">null</span>, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;) <span class="hljs-comment">// -&gt; &#x27;someMutation&#x27;</span>      &#125;,      someOtherAction (ctx, payload) &#123; ... &#125;    &#125;  &#125;&#125;</code></pre></div><h4 id="带命名空间的绑定函数"><a href="#带命名空间的绑定函数" class="headerlink" title="带命名空间的绑定函数"></a>带命名空间的绑定函数</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">methods: &#123;  ...mapActions([    <span class="hljs-string">&#x27;some/nested/module/foo&#x27;</span>, <span class="hljs-comment">// -&gt; this[&#x27;some/nested/module/foo&#x27;]()</span>    <span class="hljs-string">&#x27;some/nested/module/bar&#x27;</span> <span class="hljs-comment">// -&gt; this[&#x27;some/nested/module/bar&#x27;]()</span>  ])&#125;---&gt;methods: &#123;  ...mapActions(<span class="hljs-string">&#x27;some/nested/module&#x27;</span>, [    <span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-comment">// -&gt; this.foo()</span>    <span class="hljs-string">&#x27;bar&#x27;</span> <span class="hljs-comment">// -&gt; this.bar()</span>  ])&#125;</code></pre></div><h4 id="createNamespacedHelpers"><a href="#createNamespacedHelpers" class="headerlink" title="createNamespacedHelpers"></a>createNamespacedHelpers</h4><p>使用 <code>createNamespacedHelpers</code> 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数</p>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript常见设计模式</title>
    <link href="/2019/07/13/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/07/13/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式的定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。"><a href="#设计模式的定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。" class="headerlink" title="设计模式的定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。"></a>设计模式的定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><ol><li><p>设计思想：将 new 操作单独封装，只对外提供相应接口</p></li><li><p>作用：隐藏创建实例的复杂度，将构造函数和创建者分离</p></li><li><p>举例：jQ的选择器</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name=<span class="hljs-string">&#x27;&#x27;</span>,age=<span class="hljs-number">0</span></span>)</span>&#123;    <span class="hljs-built_in">this</span>.name = name    <span class="hljs-built_in">this</span>.age = age  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">User</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name,age</span>)</span>&#123;    <span class="hljs-built_in">super</span>(name,age)  &#125;  <span class="hljs-function"><span class="hljs-title">create</span>(<span class="hljs-params">type</span>)</span>&#123;    <span class="hljs-keyword">switch</span>(type)&#123;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;male&#x27;</span>:        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserFactory(<span class="hljs-string">&#x27;boy&#x27;</span>,<span class="hljs-number">29</span>)        <span class="hljs-keyword">break</span>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;female&#x27;</span>:        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserFactory(<span class="hljs-string">&#x27;girl&#x27;</span>,<span class="hljs-number">18</span>)        <span class="hljs-keyword">break</span>      <span class="hljs-keyword">default</span>:        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;type indeed&#x27;</span>)      &#125;  &#125;&#125;</code></pre></div></li></ol><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ol><li>保证该类只有一个实例</li><li>如果已经创建过实例对象则放回该对象</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// </span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginForm</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&#x27;hide&#x27;</span>    &#125;    <span class="hljs-function"><span class="hljs-title">show</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&#x27;show&#x27;</span>) &#123;            alert(<span class="hljs-string">&#x27;已经显示&#x27;</span>)            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&#x27;show&#x27;</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;登录框已显示&#x27;</span>)    &#125;    <span class="hljs-function"><span class="hljs-title">hide</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&#x27;hide&#x27;</span>) &#123;            alert(<span class="hljs-string">&#x27;已经隐藏&#x27;</span>)            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&#x27;hide&#x27;</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;登录框已隐藏&#x27;</span>)    &#125;&#125;LoginForm.getInstance = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// 使用instance这个变量来保存</span>    <span class="hljs-keyword">let</span> instance    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span> (!instance) &#123;            instance = <span class="hljs-keyword">new</span> LoginForm();        &#125;        <span class="hljs-keyword">return</span> instance    &#125;&#125;)()<span class="hljs-comment">// 一个页面中调用登录框</span><span class="hljs-keyword">let</span> login1 = LoginForm.getInstance()login1.show()<span class="hljs-comment">// login1.hide()</span><span class="hljs-comment">// 另一个页面中调用登录框</span><span class="hljs-keyword">let</span> login2 = LoginForm.getInstance()login2.show()<span class="hljs-comment">// 两者是否相等</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;login1 === login2&#x27;</span>, login1 === login2)</code></pre></div><h2 id="观察者模式-发布订阅模式"><a href="#观察者模式-发布订阅模式" class="headerlink" title="观察者模式/发布订阅模式"></a>观察者模式/发布订阅模式</h2><ol><li>1对N的数据联动</li><li>观察者模式中，被观察者的改变直接通知观察者，观察者自己保留</li><li>发布订阅模式中，发布者和订阅者之前不直接通信不知道彼此存在，发布者发布消息至【消息中心】，由【消息中心】通知订阅者，同时订阅者是向【消息中心】订阅</li><li>MVVM框架的viewmodel</li><li>addEventListener</li></ol><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ol><li>顾名思义，为对象的访问提供代理控制对对象的访问</li><li>ES6的Proxy</li></ol><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><ol><li>装饰者(decorator)模式能够在不改变对象自身的基础上，在程序运行期间给对像动态的添加职责（方法或属性）。与继承相比，装饰者是一种更轻便灵活的做法。</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">this</span>.type = <span class="hljs-string">&#x27;正常人&#x27;</span>  &#125;  <span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;23岁 是学生&#x27;</span>)  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MakeUp</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">human</span>)</span>&#123;    <span class="hljs-built_in">this</span>.human = human    <span class="hljs-built_in">this</span>.human.type = <span class="hljs-string">&#x27;赛亚人&#x27;</span>  &#125;  <span class="hljs-function"><span class="hljs-title">sayAgain</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">this</span>.human.say()    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我不当人了&#x27;</span>)  &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络分层模型</title>
    <link href="/2019/07/12/OSI%E6%A8%A1%E5%9E%8B%E4%B8%8ETCPIP%E6%A8%A1%E5%9E%8B/"/>
    <url>/2019/07/12/OSI%E6%A8%A1%E5%9E%8B%E4%B8%8ETCPIP%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h2><p><code>OSI参考模型（OSI/RM）</code>的全称是开放系统互连参考模型<code>（Open System Interconnection Reference Model，OSI/RM）</code>，它是由国际标准化组织（International Standard Organization，ISO）提出的一个网络系统互连模型。</p><ul><li><p>在这个 OSI 七层模型中，每一层都为其上一层提供服务、并为其上一层提供一个访问接口或界面。</p></li><li><p>不同主机之间的相同层次称为<strong>对等层</strong>。如主机 A 中的表示层和主机 B 中的表示层互为对等层、主机 A 中的会话层和主机 B 中的会话层互为对等层等。</p></li><li><p>对等层之间互相通信需要遵守一定的规则，如通信的内容、通信的方式，我们将其称为<strong>协议</strong>（Protocol）。</p></li><li><p>我们将某个主机上运行的某种协议的集合称为<strong>协议栈</strong>。主机正是利用这个协议栈来接收和发送数据的。</p></li><li><p>OSI 参考模型通过将协议栈划分为不同的层次，可以简化问题的分析、处理过程以及网络系统设计的复杂性。</p></li></ul><h3 id="OSI-参考模型中各层的作用"><a href="#OSI-参考模型中各层的作用" class="headerlink" title="OSI 参考模型中各层的作用"></a>OSI 参考模型中各层的作用</h3><ul><li><p>物理层<code>Physical Layer</code></p><ul><li>利用传输介质为数据链路层提供物理连接，实现比特流的透明传输</li><li><strong>透明传输</strong>不关心传输的细节</li><li>数据的单位称为比特<code>bit</code></li></ul></li><li><p>数据链路层<code>Data Link Layer</code></p><ul><li>物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</li><li>数据的单位称为帧<code>frame</code></li></ul></li><li><p>网络层<code>Network Layer</code></p><ul><li>数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。</li><li>数据的单位称为数据包<code>packet</code></li><li><code>IP</code>协议</li></ul></li><li><p>传输层<code>Transport Layer</code></p><ul><li>向用户提供可靠的“面向连接”和不可靠的“面向无连接”的数据传输服务、差错控制和流量控制。</li><li>数据的单位称为数据段<code>segment</code></li><li><code>TCP</code>协议,<code>UDP</code>协议</li></ul></li><li><p>会话层<code>Session Layer</code></p><ul><li>用户应用程序和网络之间的接口</li><li>向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话</li><li>组织和协调两个会话进程之间的通信，并对数据交换进行管理。</li></ul></li><li><p>表示层<code>Presentation Layer</code></p><ul><li>处理用户信息的表示问题，如编码、数据格式转换和加密解密</li></ul></li><li><p>应用层<code>Application Layer</code></p><ul><li><p>为计算机用户，以及各种应用程序和网络之间提供访问网络服务的接口。</p></li><li><p><code>HTTP</code>（Hyper text transfer protocol）、<code>FTP</code>（file transfer protocol）、<code>SMTP</code>（simple mail transfer rotocol）、<code>POP3</code>（post office protocol 3）、<code>IMAP4</code>（Internet mail access protocol）</p></li></ul></li></ul><h2 id="TCP-IP-分层模型"><a href="#TCP-IP-分层模型" class="headerlink" title="TCP/IP 分层模型"></a>TCP/IP 分层模型</h2><ul><li><p>TCP/IP 分层模型（TCP/IP Layening Model）被称作因特网分层模型(Internet Layering Model)、因特网参考模型(Internet Reference Model)</p></li><li><p>OSI 参考模型的概念划分清晰，但过于复杂，层次过多，划分意义不大但增加了复杂性。</p></li><li><p>OSI 是一个理论上的网络通信模型，而 TCP/IP 则是实际运行的网络协议</p></li></ul><h3 id="TCP-IP-中各层的作用"><a href="#TCP-IP-中各层的作用" class="headerlink" title="TCP/IP 中各层的作用"></a>TCP/IP 中各层的作用</h3><ul><li><p>链路层</p><blockquote><p>对应着 OSI/RM 的数据链路层和物理层</p></blockquote><blockquote><p>用来处理连接网络的硬件部分，包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。</p></blockquote><ul><li><code>ARP</code>（Address Resolution Protocol，地址解析协议）</li><li><code>RARP</code>（Reverse Address Resolution Protocol，逆地址解析协议）</li></ul></li><li><p>网络层</p><blockquote><p>规定了数据通过怎样的传输路线到达对方计算机传送给对方，如</p></blockquote><ul><li><p><code>IP</code> 协议（Internet Protocol，网际协议）</p></li><li><p><code>ICMP</code> 协议（Internet Control Message Protocol，网际控制报文协议）</p></li><li><p><code>IGMP</code> 协议（Internet Group Management Protocol，网际组管理协议）</p></li></ul></li><li><p>传输层</p><blockquote><p>传输层对接上层应用层，提供处于网络连接中两台计算机之间的数据传输所使用的协议。</p></blockquote><ul><li><p><code>TCP</code>协议是全双工的，即发送数据和接收数据是同步进行的，就好像我们打电话一样，说话的同时也能听见。TCP 协议在建立和断开连接时有三次握手和四次挥手，因此在传输的过程中更稳定可靠但同时就没 UDP 那么高效了。</p></li><li><p><code>UDP</code>协议是面向无连接的，也就是说在正式传递数据之前不需要先建立连接。UDP 协议不保证有序且不丢失的传递到对端，也就是说不够稳定，但也正因如此，UDP 协议比 TCP 更加高效和轻便。</p></li></ul></li><li><p>应用层</p><blockquote><p>大体上对应着 OSl/RM 模型的应用层、表示层和会话层</p></blockquote><blockquote><p>为用户及各种应用程序提供访问网络的接口</p></blockquote><ul><li><p><code>FTP</code>（File Transfer Protocol，文件传输协议）,</p></li><li><p><code>DNS</code>（Domain Name System，域名系统）,</p></li><li><p><code>HTTP</code>（Hyper Text Transfer Protocol，超文本传输协议）,</p></li><li><p><code>SMTP</code>（Simple Mail Transfer Protocol，简单邮件传输协议）</p></li></ul></li></ul><h2 id="发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除。"><a href="#发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除。" class="headerlink" title="发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除。"></a>发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除。</h2>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise</title>
    <link href="/2019/07/11/promise/"/>
    <url>/2019/07/11/promise/</url>
    
    <content type="html"><![CDATA[<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>Promise 对象用于处理异步操作，它表示一个尚未完成且预计在未来完成的异步操作。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>解决回调地狱</li><li>统一的 API 接口处理异步任务</li><li>链式调用</li><li>返回值穿透</li><li>错误冒泡</li></ul><h2 id="Promise-对象有以下两个特点"><a href="#Promise-对象有以下两个特点" class="headerlink" title="Promise 对象有以下两个特点"></a>Promise 对象有以下两个特点</h2><ol><li><p>对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p></li><li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p></li></ol><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="resolve-函数的参数是一个-Promise-实例"><a href="#resolve-函数的参数是一个-Promise-实例" class="headerlink" title="resolve 函数的参数是一个 Promise 实例"></a>resolve 函数的参数是一个 Promise 实例</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;  <span class="hljs-comment">// ...</span>&#125;);<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;  <span class="hljs-comment">// ...</span>  resolve(p1);&#125;);<span class="hljs-comment">//p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。</span><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;fail&quot;</span>)), <span class="hljs-number">3000</span>);&#125;);<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(p1), <span class="hljs-number">1000</span>);&#125;);p2.then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(result)).catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(error));<span class="hljs-comment">// Error: fail</span><span class="hljs-comment">// 上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。</span></code></pre></div><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><ul><li>为 Promise 实例添加状态改变时的回调函数</li><li>then 方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数</li><li>then 方法返回的是一个新的 Promise 实例,可以 then 方法后面再调用另一个 then 方法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">getJSON(<span class="hljs-string">&quot;/post/1.json&quot;</span>)  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">post</span>) </span>&#123;    <span class="hljs-keyword">return</span> getJSON(post.commentURL);  &#125;)  .then(    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">funcA</span>(<span class="hljs-params">comments</span>) </span>&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;resolved: &quot;</span>, comments);    &#125;,    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">funcB</span>(<span class="hljs-params">err</span>) </span>&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;rejected: &quot;</span>, err);    &#125;  );<span class="hljs-comment">// 第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。</span></code></pre></div><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><ul><li><p>指定发生错误时的回调函数</p></li><li><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。</span><span class="hljs-comment">// bad</span>promise.then(  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;    <span class="hljs-comment">// success</span>  &#125;,  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;    <span class="hljs-comment">// error</span>  &#125;);<span class="hljs-comment">// good</span>promise  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;    <span class="hljs-comment">//cb</span>    <span class="hljs-comment">// success</span>  &#125;)  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;    <span class="hljs-comment">// error</span>  &#125;);</code></pre></div><ul><li><p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应</p></li><li><p>catch 方法返回的还是一个 Promise 对象，因此后面还可以接着调用 then 方法</p></li></ul><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><ul><li><p>finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作</p></li><li><p>finally 方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是 fulfilled 还是 rejected。这表明，finally 方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p></li></ul><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><ul><li>Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例</li></ul><p><code>const p = Promise.all([p1, p2, p3]);</code></p><ul><li>p 的状态由 p1、p2、p3 决定，分成两种情况。</li></ul><ol><li><p>只有 p1、p2、p3 的状态都变成<code>fulfilled</code>，p 的状态才会变成<code>fulfilled</code>，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。</p></li><li><p>只要 p1、p2、p3 之中有一个被<code>rejected</code>，p 的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给 p 的回调函数</p></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// example</span><span class="hljs-keyword">const</span> databasePromise = connectDatabase();<span class="hljs-keyword">const</span> booksPromise = databasePromise.then(findAllBooks);<span class="hljs-keyword">const</span> userPromise = databasePromise.then(getCurrentUser);<span class="hljs-built_in">Promise</span>.all([booksPromise, userPromise]).then(<span class="hljs-function">(<span class="hljs-params">[books, user]</span>) =&gt;</span>  pickTopRecommendations(books, user));</code></pre></div><ul><li>如果作为参数的 Promise 实例，自己定义了 catch 方法，那么它一旦被 rejected，并不会触发 Promise.all()的 catch 方法</li></ul><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><p><code>const p = Promise.race([p1, p2, p3]);</code></p><p>上面代码中，只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//example</span><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.race([  fetch(<span class="hljs-string">&quot;/resource-that-may-take-a-while&quot;</span>),  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;request timeout&quot;</span>)), <span class="hljs-number">5000</span>);  &#125;), <span class="hljs-comment">// 5s内请求不resolve则抛出错误</span>]);p.then(<span class="hljs-built_in">console</span>.log).catch(<span class="hljs-built_in">console</span>.error);</code></pre></div><h3 id="promise-try"><a href="#promise-try" class="headerlink" title="promise.try()"></a>promise.try()</h3><p>不想区分，函数 f 是同步函数还是异步操作，但是想用 Promise 来处理它</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;  database.users.get(&#123;<span class="hljs-attr">id</span>: userId&#125;)  .then(...)  .catch(...) <span class="hljs-comment">// promise错误</span>&#125; <span class="hljs-keyword">catch</span> (e) &#123; <span class="hljs-comment">// 同步错误</span>  <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// try catch捕获同步错误</span><span class="hljs-comment">// 用promise.try改写</span><span class="hljs-built_in">Promise</span>.try(<span class="hljs-function">() =&gt;</span> database.users.get(&#123;<span class="hljs-attr">id</span>: userId&#125;))  .then(...)  .catch(...)</code></pre></div><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ul><li>立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行</li></ul><blockquote><p>Promise.resolve()方法允许调用时不带参数，直接返回一个 resolved 状态的 Promise 对象。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;three&quot;</span>);&#125;, <span class="hljs-number">0</span>);<span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;two&quot;</span>);&#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;one&quot;</span>);<span class="hljs-comment">// one</span><span class="hljs-comment">// two</span><span class="hljs-comment">// three</span></code></pre></div><ul><li><p><code>Promise.reject()</code>方法的参数，会原封不动地作为 reject 的理由，变成后续方法的参数</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> thenable = &#123;  <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">resolve, reject</span>)</span> &#123;    reject(<span class="hljs-string">&quot;出错了&quot;</span>);  &#125;,&#125;;<span class="hljs-built_in">Promise</span>.reject(thenable).catch(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(e);&#125;);<span class="hljs-comment">// catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。</span></code></pre></div></li></ul><h2 id="手写一个-Promise"><a href="#手写一个-Promise" class="headerlink" title="手写一个 Promise"></a>手写一个 Promise</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 符合A+规范的promise</span><span class="hljs-comment">// promises-aplus-tests</span><span class="hljs-keyword">const</span> isComplex = <span class="hljs-function">(<span class="hljs-params">o</span>) =&gt;</span>  o !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">&quot;function&quot;</span> || <span class="hljs-keyword">typeof</span> o === <span class="hljs-string">&quot;object&quot;</span>);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">executor</span>) </span>&#123;  <span class="hljs-built_in">this</span>.status = <span class="hljs-string">&quot;pending&quot;</span>;  <span class="hljs-built_in">this</span>.data = <span class="hljs-literal">null</span>;  <span class="hljs-built_in">this</span>.onResolvedCallback = [];  <span class="hljs-built_in">this</span>.onRejectedCallback = [];  <span class="hljs-keyword">const</span> resolve = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;      <span class="hljs-keyword">return</span> value.then(resolve, reject);    &#125;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-string">&quot;pending&quot;</span>) &#123;        <span class="hljs-built_in">this</span>.status = <span class="hljs-string">&quot;resolved&quot;</span>;        <span class="hljs-built_in">this</span>.data = value;        <span class="hljs-built_in">this</span>.onResolvedCallback.forEach(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> cb(value));      &#125;    &#125;);  &#125;;  <span class="hljs-keyword">const</span> reject = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-string">&quot;pending&quot;</span>) &#123;        <span class="hljs-built_in">this</span>.status = <span class="hljs-string">&quot;rejected&quot;</span>;        <span class="hljs-built_in">this</span>.data = reason;        <span class="hljs-built_in">this</span>.onRejectedCallback.forEach(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> cb(reason));      &#125;    &#125;);  &#125;;  <span class="hljs-keyword">try</span> &#123;    executor(resolve, reject);  &#125; <span class="hljs-keyword">catch</span> (e) &#123;    reject(e);  &#125;&#125;<span class="hljs-built_in">Promise</span>.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onResolved, onRejected</span>) </span>&#123;  onResolved = <span class="hljs-keyword">typeof</span> onResolved === <span class="hljs-string">&quot;function&quot;</span> ? onResolved : <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> value;  onRejected =    <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span>      ? onRejected      : <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;          <span class="hljs-keyword">throw</span> err;        &#125;;  <span class="hljs-keyword">let</span> promise2;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-string">&quot;resolved&quot;</span>) &#123;    <span class="hljs-keyword">return</span> (promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">let</span> x = onResolved(<span class="hljs-built_in">this</span>.data);          resolvePromise(promise2, x, resolve, reject);        &#125; <span class="hljs-keyword">catch</span> (e) &#123;          reject(e);        &#125;      &#125;);    &#125;));  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-string">&quot;rejected&quot;</span>) &#123;    <span class="hljs-keyword">return</span> (promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">let</span> x = onRejected(<span class="hljs-built_in">this</span>.data);          resolvePromise(promise2, x, resolve, reject);        &#125; <span class="hljs-keyword">catch</span> (e) &#123;          reject(e);        &#125;      &#125;);    &#125;));  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-string">&quot;pending&quot;</span>) &#123;    <span class="hljs-keyword">return</span> (promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-built_in">this</span>.onResolvedCallback.push(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">let</span> x = onResolved(<span class="hljs-built_in">this</span>.data);          resolvePromise(promise2, x, resolve, reject);        &#125; <span class="hljs-keyword">catch</span> (e) &#123;          reject(e);        &#125;      &#125;);      <span class="hljs-built_in">this</span>.onRejectedCallback.push(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">let</span> x = onRejected(<span class="hljs-built_in">this</span>.data);          resolvePromise(promise2, x, resolve, reject);        &#125; <span class="hljs-keyword">catch</span> (e) &#123;          reject(e);        &#125;      &#125;);    &#125;));  &#125;&#125;;<span class="hljs-built_in">Promise</span>.prototype.catch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onRejected</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">null</span>, onRejected);&#125;;<span class="hljs-built_in">Promise</span>.promise.finally = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(    (value) =&gt; &#123;      <span class="hljs-built_in">Promise</span>.resolve(callback()).then(<span class="hljs-function">() =&gt;</span> value);    &#125;,    (reason) =&gt; &#123;      <span class="hljs-built_in">Promise</span>.resolve(callback()).then(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">throw</span> reason;      &#125;);    &#125;  );&#125;;<span class="hljs-built_in">Promise</span>.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;      <span class="hljs-keyword">return</span> value.then(resolve, reject);    &#125; <span class="hljs-keyword">else</span> &#123;      resolve(value);    &#125;  &#125;);&#125;;<span class="hljs-built_in">Promise</span>.reject = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    reject(reason);  &#125;);&#125;;<span class="hljs-built_in">Promise</span>.race = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    arr.forEach(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> p.then(resolve, reject));  &#125;);&#125;;<span class="hljs-built_in">Promise</span>.all = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">const</span> len = arr.length;  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> [    arr.forEach(<span class="hljs-function">(<span class="hljs-params">cb, index</span>) =&gt;</span> &#123;      cb.then(        (value) =&gt; &#123;          res[index] = value;          <span class="hljs-keyword">if</span> (++i === len) <span class="hljs-keyword">return</span> resolve(res);        &#125;,        (reason) =&gt; reject(reason)      );    &#125;),  ]);&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) </span>&#123;  <span class="hljs-keyword">if</span> (promise2 === x) &#123;    <span class="hljs-comment">// 循环引用</span>    <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;cycle quotes detected&quot;</span>));  &#125;  <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;    <span class="hljs-keyword">if</span> (x.status === <span class="hljs-string">&quot;pending&quot;</span>) &#123;      x.then(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> resolvePromise(promise2, v, resolve, reject), reject);    &#125; <span class="hljs-keyword">else</span> &#123;      x.then(resolve, reject);    &#125;    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-keyword">if</span> (isComplex(x)) &#123;    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">let</span> then = x.then;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&quot;function&quot;</span>) &#123;        then.call(          x,          (y) =&gt; &#123;            <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span>;            flag = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">return</span> resolvePromise(promise2, y, resolve, reject);          &#125;,          (r) =&gt; &#123;            <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span>;            flag = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">return</span> reject(r);          &#125;        );      &#125; <span class="hljs-keyword">else</span> &#123;        resolve(x);      &#125;    &#125; <span class="hljs-keyword">catch</span> (e) &#123;      <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span>;      flag = <span class="hljs-literal">true</span>;      <span class="hljs-keyword">return</span> reject(e);    &#125;  &#125; <span class="hljs-keyword">else</span> &#123;    resolve(x);  &#125;&#125;</code></pre></div><h2 id="同步函数-promise-化"><a href="#同步函数-promise-化" class="headerlink" title="同步函数 promise 化"></a>同步函数 promise 化</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promisify = <span class="hljs-function">(<span class="hljs-params">func</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    args.push(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, value</span>) </span>&#123;      <span class="hljs-keyword">if</span> (err) reject(err);      <span class="hljs-keyword">else</span> resolve(value);    &#125;);    func.apply(<span class="hljs-literal">null</span>, args);  &#125;);</code></pre></div><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>async/await本质上是generator函数的语法糖</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>&lt;<span class="hljs-title">name</span>&gt;?&lt;<span class="hljs-title">arguments</span>&gt;&lt;<span class="hljs-title">body</span>&gt;</span><span class="hljs-function">---&gt;</span><span class="hljs-function"><span class="hljs-function"><span class="hljs-keyword">function</span>&lt;<span class="hljs-title">name</span>&gt;?&lt;<span class="hljs-title">arguments</span>&gt;</span>&#123;</span><span class="hljs-function">  <span class="hljs-title">return</span> <span class="hljs-title">spawn</span>(<span class="hljs-params"><span class="hljs-keyword">function</span>*()&lt;body&gt;</span>)</span><span class="hljs-function">&#125;</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-title">generator</span>函数自执行器</span><span class="hljs-function"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">spawn</span>(<span class="hljs-params">genF</span>)</span>&#123;</span><span class="hljs-function">  <span class="hljs-title">return</span> <span class="hljs-title">new</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">(resolve,reject)=&gt;&#123;</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">const</span> gen = genF()</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">function</span> step(nextF)&#123;</span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">let</span> next</span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">try</span>&#123;</span></span><span class="hljs-function"><span class="hljs-params">        next = nextF()</span></span><span class="hljs-function"><span class="hljs-params">      &#125;<span class="hljs-keyword">catch</span>(err)&#123;</span></span><span class="hljs-function"><span class="hljs-params">        reject(err)</span></span><span class="hljs-function"><span class="hljs-params">      &#125;</span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">if</span>(next.done)&#123;</span></span><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">return</span> resolve(next.value)</span></span><span class="hljs-function"><span class="hljs-params">      &#125;</span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-built_in">Promise</span>.resolve(next.value).then(v=&gt;&#123;</span></span><span class="hljs-function"><span class="hljs-params">        step(()=&gt;gen.next(v))</span></span><span class="hljs-function"><span class="hljs-params">      &#125;,e=&gt;&#123;</span></span><span class="hljs-function"><span class="hljs-params">        step(()=&gt;gen.<span class="hljs-keyword">throw</span>(e))</span></span><span class="hljs-function"><span class="hljs-params">      &#125;)</span></span><span class="hljs-function"><span class="hljs-params">    &#125;</span></span><span class="hljs-function"><span class="hljs-params">    step(()=&gt;gen.next(<span class="hljs-literal">undefined</span>))</span></span><span class="hljs-function"><span class="hljs-params">  &#125;</span>)</span><span class="hljs-function">&#125;</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>es6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组方法</title>
    <link href="/2019/07/10/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
    <url>/2019/07/10/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 字面量</span><span class="hljs-keyword">let</span> arr = []<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<span class="hljs-comment">// 构造函数</span><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>()<span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-regexp">/传入数组代表数组长度/</span>)<span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">&#x27;item1&#x27;</span>,<span class="hljs-string">&#x27;item2&#x27;</span>/传入元素/)<span class="hljs-keyword">let</span> arr = <span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>)/省略<span class="hljs-keyword">new</span>操作符/<span class="hljs-comment">// Array.of</span><span class="hljs-built_in">Array</span>.of(<span class="hljs-number">7</span>) 创建一个具有单个元素 <span class="hljs-number">7</span> 的数组，而<span class="hljs-built_in">Array</span>(<span class="hljs-number">7</span>) 创建一个长度为<span class="hljs-number">7</span>的空数组<span class="hljs-comment">// Array.from</span><span class="hljs-built_in">Array</span>.from(arrayLike[, mapFn[, thisArg]])</code></pre></div><h2 id="变异方法（改变原数组）"><a href="#变异方法（改变原数组）" class="headerlink" title="变异方法（改变原数组）"></a>变异方法（改变原数组）</h2><ul><li><code>pop()</code>删除最后一个元素</li><li><code>shift()</code>删除第一个元素</li><li><code>push()</code>添加元素至末尾</li><li><code>unshift()</code>添加元素至首位</li><li><code>splice(start,delCount,new1,new2...)</code>往数组索引为 start 位置删除 delCont 个元素，并从该位置加入 new 新元素</li><li><code>sort()</code>排序</li><li><code>reverse()</code>倒序,返回新数组<blockquote><p>es6</p></blockquote></li><li><code>copyWithin(target,start,end)</code>拷贝数组中索引从 start 到 end（end）的元素添加至 target</li><li><code>fill(value,start,end)</code>将数组中索引 start 到 end（不含）的位置填充为 value 元素</li></ul><h2 id="非变异方法"><a href="#非变异方法" class="headerlink" title="非变异方法"></a>非变异方法</h2><ul><li><code>slice(start,end)</code>潜拷贝，返回索引从 start 到 end（不含）的元素组成新数组</li><li><code>join()</code>指定分隔符将数字元素连成字符串</li><li><code>concat()</code>合并数组</li><li><code>indexOf()/lastIndexOf()</code>查找元素索引,可传入起始位置</li><li><code>includes()</code>查找是否包含元素返回Boolean,可传入起始位置</li><li><code>...</code>展开运算符</li></ul><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><blockquote><p>遍历数组的方法回调mapFn包含自动传入的参数(currentValue,currentIndex,thisArr)</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript">解释了[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>].map(<span class="hljs-built_in">parseInt</span>)=&gt; <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-number">0</span>),<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-number">1</span>),<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-number">2</span>)=&gt; <span class="hljs-number">1</span>,<span class="hljs-literal">NaN</span>,<span class="hljs-literal">NaN</span></code></pre></div><ul><li><p><code>map()</code>创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果</p></li><li><p><code>flatmap()</code>使用映射函数映射每个元素，然后将结果压缩成一个新数组</p></li><li><p><code>some()</code>方法测试是否至少有一个元素可以通过被提供的函数方法。该方法返回一个 Boolean 类型的值</p></li><li><p><code>every()</code>检测数组所有元素是否都符合判断条件,<br>如果数组中检测到有一个元素不满足, 则整个表达式返回 false,且停止遍历</p></li><li><p><code>forEach()</code>对数组的每个元素执行一次提供的函数。*<em>无法中途退出循环</em>*  </p></li><li><p><code>filter()</code>返回过滤后的数组</p></li><li><p><code>find()</code>返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined</p></li><li><p><code>findIndex()</code>返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1</p></li><li><p><code>reduce()和reduceRight()</code>累加器,累加函数的 return 作为下一次累加的 pre 值，并可指定初始值</p></li><li><p><code>flat(deepth)</code>按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回（<em>会移除数组中的空项</em>）</p></li><li><p><code>keys()</code></p></li><li><p><code>values()</code></p></li><li><p><code>entries()</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index <span class="hljs-keyword">of</span> [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>].keys()) &#123;  <span class="hljs-built_in">console</span>.log(index);&#125;<span class="hljs-comment">// 0</span><span class="hljs-comment">// 1</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> elem <span class="hljs-keyword">of</span> [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>].values()) &#123;  <span class="hljs-built_in">console</span>.log(elem);&#125;<span class="hljs-comment">// &#x27;a&#x27;</span><span class="hljs-comment">// &#x27;b&#x27;</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [index, elem] <span class="hljs-keyword">of</span> [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>].entries()) &#123;  <span class="hljs-built_in">console</span>.log(index, elem);&#125;<span class="hljs-comment">// 0 &quot;a&quot;</span><span class="hljs-comment">// 1 &quot;b&quot;</span></code></pre></div></li></ul><h2 id="判断数组"><a href="#判断数组" class="headerlink" title="判断数组"></a>判断数组</h2><ol><li><code>arr.constructor===Array</code></li><li><code>arr instanceof Array</code></li><li><code>Array.prototype.isPrototypeOf(arr)</code><blockquote><p>查找原型的方法，如果手动更改对象的原型也可欺骗过检测</p></blockquote></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [];<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.prototype.isPrototypeOf(arr));<span class="hljs-built_in">console</span>.log(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>);<span class="hljs-built_in">console</span>.log(arr.constructor === <span class="hljs-built_in">Array</span>);arr = &#123;  __proto__: <span class="hljs-built_in">Array</span>.prototype,&#125;;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.prototype.isPrototypeOf(arr));<span class="hljs-built_in">console</span>.log(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>);<span class="hljs-built_in">console</span>.log(arr.constructor === <span class="hljs-built_in">Array</span>);</code></pre></div><ol><li><code>Object.prototype.toString.call(arr)===&#39;[object Array]&#39;</code></li><li><code>Array.isArray()</code></li></ol><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>];<span class="hljs-comment">// 1</span><span class="hljs-keyword">let</span> uni1 = <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr));<span class="hljs-comment">// 2</span><span class="hljs-keyword">let</span> uni2 = [...new <span class="hljs-built_in">Set</span>(arr)];<span class="hljs-comment">// 3</span><span class="hljs-keyword">let</span> uni3 = arr.sort().reduce(<span class="hljs-function">(<span class="hljs-params">init, cur</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (init.length === <span class="hljs-number">0</span> || init[init.length - <span class="hljs-number">1</span>] !== cur) &#123;    init.push(cur);  &#125;  <span class="hljs-keyword">return</span> init;&#125;, []);<span class="hljs-comment">// 4</span><span class="hljs-keyword">let</span> uni4 = arr.filter(<span class="hljs-function">(<span class="hljs-params">item,index</span>)=&gt;</span>&#123;  <span class="hljs-keyword">return</span> arr.indexOf(item) === index&#125;)</code></pre></div><h2 id="计算数组中元素出现的次数"><a href="#计算数组中元素出现的次数" class="headerlink" title="计算数组中元素出现的次数"></a>计算数组中元素出现的次数</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>];<span class="hljs-comment">//reduce</span><span class="hljs-keyword">let</span> countArr = arr.reduce(<span class="hljs-function">(<span class="hljs-params">obj, i</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> obj) &#123;    obj[i]++;  &#125; <span class="hljs-keyword">else</span> &#123;    obj[i] = <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">return</span> obj;&#125;, &#123;&#125;);<span class="hljs-comment">// &#123; &#x27;1&#x27;: 2, &#x27;2&#x27;: 2, &#x27;3&#x27;: 2, &#x27;4&#x27;: 4 &#125;</span><span class="hljs-comment">// 循环</span><span class="hljs-keyword">let</span> obj = &#123;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> arr) &#123;  <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> obj) &#123;    obj[i]++;  &#125; <span class="hljs-keyword">else</span> &#123;    obj[i] = <span class="hljs-number">1</span>;  &#125;&#125;</code></pre></div><h2 id="对于-obj-按照属性分类"><a href="#对于-obj-按照属性分类" class="headerlink" title="对于 obj 按照属性分类"></a>对于 obj 按照属性分类</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 面试题教你归类json</span><span class="hljs-comment">// JSON.parse(jsonStr)</span><span class="hljs-keyword">let</span> person = [  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">21</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">21</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Hank&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Jery&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">19</span> &#125;,];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">groupBy</span>(<span class="hljs-params">objArr, prop</span>) </span>&#123;  <span class="hljs-keyword">return</span> objArr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, obj</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> key = obj[prop];    <span class="hljs-keyword">if</span> (!acc[key]) &#123;      acc[key] = [];    &#125;    acc[key].push(obj);    <span class="hljs-keyword">return</span> acc;  &#125;, &#123;&#125;);&#125;<span class="hljs-keyword">let</span> res = groupBy(person, <span class="hljs-string">&quot;age&quot;</span>);</code></pre></div><h2 id="扁平化数组"><a href="#扁平化数组" class="headerlink" title="扁平化数组"></a>扁平化数组</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1 reduce</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat1</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function">(<span class="hljs-params">res, item</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> res.concat(<span class="hljs-built_in">Array</span>.isArray(item) ? flat1(item) : item);  &#125;, []);&#125;<span class="hljs-comment">//2 递归</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat2</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">let</span> res = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr) &#123;    <span class="hljs-built_in">Array</span>.isArray(item) ? (res = res.concat.flat2(item)) : res.push(item);  &#125;  <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 3 展开运算符</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat3</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">while</span> (arr.some(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> <span class="hljs-built_in">Array</span>.isArray(item))) &#123;    arr = [].concat(...arr);  &#125;  <span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-comment">// 4 toString</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat4</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">return</span> arr    .toString()    .split(<span class="hljs-string">&quot;,&quot;</span>)    .map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(item));&#125;<span class="hljs-comment">// 5 join</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat5</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">return</span> arr    .join(<span class="hljs-string">&quot;,&quot;</span>)    .split(<span class="hljs-string">&quot;,&quot;</span>)    .map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> <span class="hljs-built_in">Number</span>(item));&#125;<span class="hljs-comment">// 6 flat()</span>flat(<span class="hljs-literal">Infinity</span>);</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>for...of</title>
    <link href="/2019/07/10/for...of/"/>
    <url>/2019/07/10/for...of/</url>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组原生具备iterator接口（即默认部署了Symbol.iterator属性），for…of循环本质上就是调用这个接口产生的遍历器</p><h3 id="for…of循环可以代替数组实例的forEach方法"><a href="#for…of循环可以代替数组实例的forEach方法" class="headerlink" title="for…of循环可以代替数组实例的forEach方法"></a>for…of循环可以代替数组实例的forEach方法</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>];arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element, index</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(element); <span class="hljs-comment">// red green blue</span>  <span class="hljs-built_in">console</span>.log(index);   <span class="hljs-comment">// 0 1 2</span>&#125;);</code></pre></div><h3 id="for…in循环读取键名，for…of循环读取键值"><a href="#for…in循环读取键名，for…of循环读取键值" class="headerlink" title="for…in循环读取键名，for…of循环读取键值"></a>for…in循环读取键名，for…of循环读取键值</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a <span class="hljs-keyword">in</span> arr) &#123;  <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 0 1 2 3</span>&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a <span class="hljs-keyword">of</span> arr) &#123;  <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// a b c d</span>&#125;</code></pre></div><h3 id="for…of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性"><a href="#for…of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性" class="headerlink" title="for…of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性"></a>for…of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>];arr.foo = <span class="hljs-string">&#x27;hello&#x27;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> arr) &#123;  <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span>&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> arr) &#123;  <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">//  &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span>&#125;<span class="hljs-comment">// 上面代码中，for...of循环不会返回数组arr的foo属性。</span></code></pre></div><h3 id="如果要通过for-of循环获取数组的索引，可以借助数组实例的entries方法和keys方法"><a href="#如果要通过for-of循环获取数组的索引，可以借助数组实例的entries方法和keys方法" class="headerlink" title="如果要通过for...of循环获取数组的索引，可以借助数组实例的entries方法和keys方法"></a>如果要通过<code>for...of</code>循环获取数组的索引，可以借助数组实例的<code>entries</code>方法和<code>keys</code>方法</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pair <span class="hljs-keyword">of</span> arr) &#123;  <span class="hljs-built_in">console</span>.log(pair);&#125;<span class="hljs-comment">// a</span><span class="hljs-comment">// b</span><span class="hljs-comment">// c</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pair <span class="hljs-keyword">of</span> arr.entries()) &#123;  <span class="hljs-built_in">console</span>.log(pair);&#125;<span class="hljs-comment">// [0, &#x27;a&#x27;]</span><span class="hljs-comment">// [1, &#x27;b&#x27;]</span><span class="hljs-comment">// [2, &#x27;c&#x27;]</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> pair <span class="hljs-keyword">of</span> arr.keys()) &#123;  <span class="hljs-built_in">console</span>.log(pair);&#125;<span class="hljs-comment">// 0</span><span class="hljs-comment">// 1</span><span class="hljs-comment">// 2</span></code></pre></div><h2 id="set和map"><a href="#set和map" class="headerlink" title="set和map"></a>set和map</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> engines = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&quot;Gecko&quot;</span>, <span class="hljs-string">&quot;Trident&quot;</span>, <span class="hljs-string">&quot;Webkit&quot;</span>, <span class="hljs-string">&quot;Webkit&quot;</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> e <span class="hljs-keyword">of</span> engines) &#123;  <span class="hljs-built_in">console</span>.log(e);&#125;<span class="hljs-comment">// Gecko</span><span class="hljs-comment">// Trident</span><span class="hljs-comment">// Webkit</span><span class="hljs-keyword">var</span> es6 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();es6.set(<span class="hljs-string">&quot;edition&quot;</span>, <span class="hljs-number">6</span>);es6.set(<span class="hljs-string">&quot;committee&quot;</span>, <span class="hljs-string">&quot;TC39&quot;</span>);es6.set(<span class="hljs-string">&quot;standard&quot;</span>, <span class="hljs-string">&quot;ECMA-262&quot;</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> [name, value] <span class="hljs-keyword">of</span> es6) &#123;  <span class="hljs-built_in">console</span>.log(name + <span class="hljs-string">&quot;: &quot;</span> + value);  <span class="xml">&lt;-----按照添加的顺序</span><span class="xml">&#125;</span><span class="xml">// edition: 6</span><span class="xml">// committee: TC39</span><span class="xml">// standard: ECMA-262</span></code></pre></div><h2 id="类数组的对象"><a href="#类数组的对象" class="headerlink" title="类数组的对象"></a>类数组的对象</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 字符串</span><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> s <span class="hljs-keyword">of</span> str) &#123;  <span class="hljs-built_in">console</span>.log(s); <span class="hljs-comment">// h e l l o</span>&#125;<span class="hljs-comment">// DOM NodeList对象</span><span class="hljs-keyword">let</span> paras = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;p&quot;</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> p <span class="hljs-keyword">of</span> paras) &#123;  p.classList.add(<span class="hljs-string">&quot;test&quot;</span>);&#125;<span class="hljs-comment">// arguments对象</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printArgs</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> <span class="hljs-built_in">arguments</span>) &#123;    <span class="hljs-built_in">console</span>.log(x);  &#125;&#125;printArgs(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>);<span class="hljs-comment">// &#x27;a&#x27;</span><span class="hljs-comment">// &#x27;b&#x27;</span></code></pre></div><h3 id="使用Array-from-将类数组对象转为数组"><a href="#使用Array-from-将类数组对象转为数组" class="headerlink" title="使用Array.from()将类数组对象转为数组"></a>使用Array.from()将类数组对象转为数组</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arrayLike = &#123; <span class="hljs-attr">length</span>: <span class="hljs-number">2</span>, <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span> &#125;;<span class="hljs-comment">// 报错</span><span class="hljs-comment">// for (let x of arrayLike) &#123;</span><span class="hljs-comment">//   console.log(x);</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// 正确</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> <span class="hljs-built_in">Array</span>.from(arrayLike)) &#123;  <span class="hljs-built_in">console</span>.log(x);&#125;<span class="hljs-comment">// a</span><span class="hljs-comment">// b</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>es6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾回收机制</title>
    <link href="/2019/07/09/js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2019/07/09/js%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="javascript具有自动垃圾收集机制"><a href="#javascript具有自动垃圾收集机制" class="headerlink" title="javascript具有自动垃圾收集机制"></a>javascript具有自动垃圾收集机制</h2><p>执行环境会负责管理代码执行过程中使用的内存\</p><blockquote><p>垃圾收集器是周期性运行的，触发垃圾收集的阈值是动态设定的</p></blockquote><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><ul><li>最主流的垃圾收集算法</li><li>离开作用域，没有被引用的值被标记为可以回收。在垃圾收集期间被删除</li></ul><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><ul><li>跟踪记录被引用的次数</li><li>次数为0的值所占的内存会被下次垃圾收集回收</li></ul><h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">objA.obj = objBobjB.obj = objAa/b中都包含指向对方的指针</code></pre></div><h2 id="手动解除变量的引用"><a href="#手动解除变量的引用" class="headerlink" title="手动解除变量的引用"></a>手动解除变量的引用</h2><ul><li>当数据不再有用，将其设置为<code>null</code>，释放其引用</li><li>解除了引用的值脱离了执行环境，下次垃圾收集期间会被回收</li></ul><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。</p><h3 id="引起内存泄漏的情况"><a href="#引起内存泄漏的情况" class="headerlink" title="引起内存泄漏的情况"></a>引起内存泄漏的情况</h3><ol><li><p>全局变量</p></li><li><p>闭包</p></li><li><p>循环引用</p></li><li><p>未清除的定时器</p></li><li><p>控制台日志</p></li></ol><h3 id="ES6中的weak"><a href="#ES6中的weak" class="headerlink" title="ES6中的weak"></a>ES6中的weak</h3><p>weakset和weakmap不被垃圾收集机制的引用计数</p>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包</title>
    <link href="/2019/07/08/%E9%97%AD%E5%8C%85/"/>
    <url>/2019/07/08/%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h2><ul><li><p>函数与对其词法环境的引用共同构成 <em>闭包（closure）</em> 。</p><blockquote><p>ECMAScript规范中对词法环境的描述如下：词法环境是用来定义 基于词法嵌套结构的ECMAScript代码内的标识符与变量值和函数值之间的关联关系 的一种规范类型。一个词法环境由环境记录（Environment Record）和一个可能为null的对外部词法环境的引用（outer）组成。</p></blockquote></li><li><p>js的词法作用域为静态作用域，在书写完成后函数词法环境就被确定，与调用位置无关</p></li><li><p>闭包函数会保持对外部词法环境的引用，使外部变量常驻内存不可回收</p></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCounter</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>; <span class="hljs-comment">// 执行结束后不会被清除</span>  <span class="hljs-keyword">const</span> myFunction = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    counter = counter + <span class="hljs-number">1</span>; <span class="hljs-comment">// myFunction函数可以读取add函数内部的变量</span>    <span class="hljs-keyword">return</span> counter;  &#125;;  <span class="hljs-keyword">return</span> myFunction;&#125;<span class="hljs-keyword">const</span> increment = addCounter();<span class="hljs-keyword">const</span> c1 = increment();<span class="hljs-keyword">const</span> c2 = increment();<span class="hljs-keyword">const</span> c3 = increment();<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;increment:&quot;</span>, c1, c2, c3);<span class="hljs-comment">// increment: 1 2 3</span></code></pre></div><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(i)  &#125;, <span class="hljs-number">1000</span> * i)&#125;<span class="hljs-comment">// 6 6 6 6 6 6</span><span class="hljs-comment">// 创建的6个setTimeout闭包共享一个词法作用域</span>**闭包只能取得包含函数中任何变量赋值最后一个值** <span class="hljs-comment">// 6</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;  (<span class="hljs-function">(<span class="hljs-params">j</span>) =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(j)    &#125;, <span class="hljs-number">1000</span> * j)  &#125;)(i)&#125;<span class="hljs-comment">// 1 2 3 4 5 6</span><span class="hljs-comment">// 6个setTimeout闭包有自己独立的词法环境</span><span class="hljs-comment">// 闭包读取到不同的i值</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span> ;i&lt;<span class="hljs-number">7</span>;i++)&#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">j</span>=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(j);  &#125;,<span class="hljs-number">1000</span>*i,i)&#125;<span class="hljs-comment">// setTimeout 可以接受一个参数当函数调用时传入</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">num2</span>) </span>&#123;  <span class="hljs-keyword">var</span> num = <span class="hljs-number">15</span>;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">abc</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 函数作为返回值</span>    num++;    <span class="hljs-keyword">return</span>(num + num2);  &#125;  <span class="hljs-keyword">return</span> abc;&#125;<span class="hljs-keyword">var</span> aa = fn(<span class="hljs-number">20</span>); <span class="hljs-comment">//  没有引用？？</span>aa(); <span class="hljs-comment">//16+20</span>aa(); <span class="hljs-comment">//17+20</span>fn(<span class="hljs-number">20</span>)(); <span class="hljs-comment">//36</span>fn(<span class="hljs-number">20</span>)(); <span class="hljs-comment">//36</span></code></pre></div><h2 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h2><h3 id="作用域：变量可以起作用的范围"><a href="#作用域：变量可以起作用的范围" class="headerlink" title="作用域：变量可以起作用的范围"></a>作用域：变量可以起作用的范围</h3><h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><div class="hljs code-wrapper"><pre><code>全局变量对应的作用域`全局变量`：在任何地方都可以访问到的变量，全局变量关闭网页或浏览器才会销毁(生命周期)</code></pre></div><h4 id="局部作用域（函数作用域）"><a href="#局部作用域（函数作用域）" class="headerlink" title="局部作用域（函数作用域）"></a>局部作用域（函数作用域）</h4><div class="hljs code-wrapper"><pre><code>函数内部就是一个局部作用域`局部变量`：只在固定的代码片段内可访问到的变量，变量退出作用域之后会销毁</code></pre></div><h4 id="块级作用域（es5）"><a href="#块级作用域（es5）" class="headerlink" title="块级作用域（es5）"></a>块级作用域（es5）</h4><div class="hljs code-wrapper"><pre><code>任何一对花括号（｛和｝）中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为 `块级作用域`</code></pre></div><h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><div class="hljs code-wrapper"><pre><code>变量的作用域是在定义时决定而不是执行时决定，也就是说词法作用域取决于源码，通过静态分析就能确定(书写时就已经确定)，因此词法作用域也叫做静态作用域</code></pre></div><p><em>在 js 中词法作用域规则:</em></p><ul><li>函数允许访问函数外的数据.</li><li>整个代码结构中只有函数可以限定作用域</li><li>作用域规则首先使用提升规则分析</li><li>如果当前作用规则中有名字了, 就不考虑外面的名字</li></ul><h3 id="自由变量"><a href="#自由变量" class="headerlink" title="自由变量"></a>自由变量</h3><ul><li><p>当前作用域没有定义的变量，这成为<code>自由变量</code>。</p></li><li><p>自由变量向父级作用域中寻找</p></li><li><p><strong>自由变量从作用域链中去寻找，依据的是函数定义时的作用域链，而不是函数执行时的作用域</strong></p></li></ul><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>只有函数可以制造作用域结构， 那么只要是代码，就至少有一个作用域, 即全局作用域。凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。</p><p>将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。</p><h2 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h2><ul><li>实现数据(变量和方法)私有化</li><li>函数柯里化（函数式编程</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>compose函数</title>
    <link href="/2019/07/04/compose%E5%87%BD%E6%95%B0/"/>
    <url>/2019/07/04/compose%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>接受函数参数，返回函数</li><li>作为参数的函数自右向左依次执行</li><li>第一个函数接受参数</li><li>其他函数的参数是上一个函数的执行结果</li><li>执行到最后return出一个函数才算执行结束</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="lodash"><a href="#lodash" class="headerlink" title="lodash"></a>lodash</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> flow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">funcs</span>) </span>&#123;    <span class="hljs-keyword">var</span> length = funcs.length    <span class="hljs-keyword">var</span> index = length    <span class="hljs-keyword">while</span> (index--) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> funcs[index] !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Expected a function&#x27;</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;        <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>        <span class="hljs-keyword">var</span> result = length ? funcs[index].apply(<span class="hljs-built_in">this</span>, args) : args[<span class="hljs-number">0</span>]        <span class="hljs-keyword">while</span> (++index &lt; length) &#123;            result = funcs[index].call(<span class="hljs-built_in">this</span>, result)        &#125;        <span class="hljs-keyword">return</span> result    &#125;&#125;<span class="hljs-keyword">var</span> flowRight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">funcs</span>) </span>&#123;    <span class="hljs-keyword">return</span> flow(funcs.reverse())&#125;</code></pre></div><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span>(<span class="hljs-params">...funcs</span>) </span>&#123;  <span class="hljs-keyword">if</span> (funcs.length === <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> arg  &#125;  <span class="hljs-keyword">if</span> (funcs.length === <span class="hljs-number">1</span>) &#123;    <span class="hljs-keyword">return</span> funcs[<span class="hljs-number">0</span>]  &#125;  <span class="hljs-comment">// 哭了就只用reduce一句。。。。</span>  <span class="hljs-keyword">return</span> funcs.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> a(b(...args)))&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>函数式编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动端适配</title>
    <link href="/2019/07/04/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"/>
    <url>/2019/07/04/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="设备像素比-dpr"><a href="#设备像素比-dpr" class="headerlink" title="设备像素比 dpr"></a>设备像素比 dpr</h2><ul><li><code>物理像素</code>即设备上真实的物理像素单元</li><li><code>逻辑像素</code> = css像素，软件使用的直觉上的尺寸大小，是抽象概念<ol><li>苹果提出视网膜屏幕之前移动设备都是直接使用物理像素来进行展示</li><li>即1个逻辑像素1个物理像素显示</li></ol></li></ul><ul><li><p>高分辨率屏幕出现后，UI元素（例如 按钮）在低密度屏幕上看起来较大，在高密度屏幕上看起来较小。这些 密度相关的大小变化可能给应用布局和易用性带来问题</p></li><li><p><code>设备独立像素</code>（又称设备无关像素 Device Independent Pixels 、密度独立性 Density Independent，简称DIP或DP），是一种物理测量单位</p><ul><li> 由底层程序计算后将逻辑像素转化为设备独立像素进行显示，保证不同分辨率的屏幕显示UI大致相同（实现密度独立性）</li><li></li></ul></li><li><p><code>设备像素比</code> device pixel ratio简称 dpr，即<code>物理像素</code>和<code>设备独立像素</code>的比值</p><ol><li>在 web中，浏览器为我们提供了 window.devicePixelRatio来帮助我们获取 dpr。</li><li>在 css中，可以使用媒体查询 min-device-pixel-ratio，区分 dpr：</li></ol><p>  <code>@media(-webkit-min-device-pixel-ratio:2),(min-device-pixel-ratio:2)&#123;...css...&#125;</code></p></li><li><p>css像素 = dp像素 = logic像素</p></li><li><p>以iphone6为例，物理分辨率为<code>750*1334</code>，逻辑分辨率为 <code>375*667</code>，dpr = 2</p></li></ul><h2 id="1px问题"><a href="#1px问题" class="headerlink" title="1px问题"></a>1px问题</h2><p>在设备像素比大于 1的屏幕上，我们写的 1px实际上是被多个物理像素渲染，这就会出现 1px在有些屏幕上看起来很粗的现象。</p><p>解决方案：</p><ul><li><p>border-image</p><div class="hljs code-wrapper"><pre><code class="hljs css">border_1px &#123;  <span class="hljs-attribute">border-bottom</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>;&#125;<span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio</span>: <span class="hljs-number">2</span>) &#123;  . border_1px &#123;    <span class="hljs-attribute">border-bottom</span>:none;    <span class="hljs-attribute">border-width</span>:<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-number">0</span>;    <span class="hljs-attribute">border-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">../ img / 1pxline . png</span>) <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> stretch;  &#125;&#125;</code></pre></div></li><li><p>background-image</p><div class="hljs code-wrapper"><pre><code class="hljs css">border_1px &#123;  <span class="hljs-attribute">border-bottom</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>;&#125;<span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio</span>: <span class="hljs-number">2</span>) &#123;  . border_1px &#123;    <span class="hljs-attribute">background</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">../ img / 1pxline . png</span>) repeat - x left bottom;    <span class="hljs-attribute">background-size</span>:<span class="hljs-number">100%</span> <span class="hljs-number">1px</span>;  &#125;&#125;</code></pre></div></li><li><p>box-shadow</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.border_1px</span> &#123;  <span class="hljs-attribute">box-shadow</span>: inset <span class="hljs-number">0px</span>-<span class="hljs-number">1px</span>1px-<span class="hljs-number">1px</span><span class="hljs-number">#d4d6d7</span>&#125;<span class="hljs-comment">/* 颜色会变浅 */</span></code></pre></div><ul><li><p>伪类 trasnform</p><div class="hljs code-wrapper"><pre><code class="hljs css">. border_1px: before &#123;  content: <span class="hljs-string">&#x27;&#x27;</span>;  <span class="hljs-attribute">position</span>: absolute;  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">1px</span>;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100</span> %;  <span class="hljs-attribute">background</span> - <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;  <span class="hljs-attribute">transform</span> - origin: <span class="hljs-number">50</span> % <span class="hljs-number">0</span> %;&#125;<span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio</span>: <span class="hljs-number">2</span>) &#123;  . border_1px: before &#123;    transform: scaleY (<span class="hljs-number">0.5</span>);  &#125;&#125;<span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio</span>: <span class="hljs-number">3</span>) &#123;  . border_1px: before &#123;    transform: scaleY (<span class="hljs-number">0.33</span>);  &#125;&#125;</code></pre></div></li><li><p>svg</p><p>-&gt; 借助 PostCSS的 postcss-write-svg我们能直接使用 border-image和 background-image创建 svg的 1px边框</p></li><li><p>改写viewport</p><p>-&gt; 整个页面布局大小都改变了</p></li></ul><h2 id="移动端适配方案"><a href="#移动端适配方案" class="headerlink" title="移动端适配方案"></a>移动端适配方案</h2><h3 id="小程序的rpx单位"><a href="#小程序的rpx单位" class="headerlink" title="小程序的rpx单位"></a>小程序的rpx单位</h3><ul><li>小程序使用<code>750rpx</code>作为设计稿, 在不同设备上将转换为不同的css尺寸</li><li>以iphone6为例，css宽度为<code>375px</code>，<code>1rpx = 375/750 = 0.5px</code></li><li>iphone6 plus为例,css宽度为<code>414px</code>,<code>1rpx = 414/750 = 0.552px</code></li></ul><h3 id="flexible"><a href="#flexible" class="headerlink" title="flexible"></a>flexible</h3><p>flexible方案是阿里早期开源的一个移动端适配解决方案，引用 flexible后，我们在页面上统一使用 rem来布局。</p><p>rem是相对于font-size大小的单位</p><p>将 html节点的 font-size设置为页面 clientWidth(布局视口)的 1/10，即 1rem就等于页面布局视口的 1/10，这就意味着我们后面使用的 rem都是按照页面比例来计算的。</p><blockquote><p>PostCSS的 px2rem插件</p></blockquote><p>以 iPhone6为例：布局视口为 375px，则 1rem=37.5px，这时 UI给定一个元素的宽为 75px（设备独立像素），我们只需要将它设置为 75/37.5=2rem。</p><h3 id="vh-vw方案"><a href="#vh-vw方案" class="headerlink" title="vh,vw方案"></a>vh,vw方案</h3><p>vh、vw方案即将视觉视口宽度 window.innerWidth和视觉视口高度 window.innerHeight 等分为 100 份。</p><p>上面的 flexible方案就是模仿这种方案，因为早些时候 vw还没有得到很好的兼容。</p><ul><li><code>vw(Viewport&#39;s width)</code>： 1vw等于视觉视口的 1%</li><li><code>vh(Viewport&#39;s height)</code>: 1vh 为视觉视口高度的 1%</li><li><code>vmin</code> : vw 和 vh 中的较小值</li><li><code>vmax</code> : 选取 vw 和 vh 中的较大值</li></ul><p>如果视觉视口为 375px，那么 1vw=3.75px，这时 UI给定一个元素的宽为 75px（设备独立像素），我们只需要将它设置为 75/3.75=20vw。</p><blockquote><p>PostCSS的 postcss-px-to-viewport 插件</p></blockquote><p>缺陷：</p><ul><li><p>px转换成 vw不一定能完全整除，因此有一定的像素差。</p></li><li><p>比如当容器使用 vw， margin采用 px时，很容易造成整体宽度超过 100vw，从而影响布局效果。当然我们也是可以避免的，例如使用 padding代替 margin，结合 calc()函数使用等等…</p></li></ul><h2 id="异型屏"><a href="#异型屏" class="headerlink" title="异型屏"></a>异型屏</h2><blockquote><p>刘海，打孔，水滴屏</p></blockquote><p>iOS11新增了两个 CSS函数 env、constant，用于设定安全区域与边界的距离。<br>函数内部可以是四个常量：</p><ul><li>safe-area-inset-left：安全区域距离左边边界距离</li><li>safe-area-inset-right：安全区域距离右边边界距离</li><li>safe-area-inset-top：安全区域距离顶部边界距离</li><li>safe-area-inset-bottom：安全区域距离底部边界距离</li></ul><p>注意：我们必须指定 viweport-fit后才能使用这两个函数：</p><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;viewport-fit=cover&quot;&gt;</code></p><p>constant在 iOS&lt;11.2的版本中生效， env在 iOS&gt;=11.2的版本中生效，这意味着我们往往要同时设置他们，将页面限制在安全区域内：</p><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">padding</span> - <span class="hljs-attribute">bottom</span>:    constant (safe - area - inset - bottom);  <span class="hljs-attribute">padding</span> - <span class="hljs-attribute">bottom</span>:    env (safe - area - inset - bottom);&#125;</code></pre></div><p>当使用底部固定导航栏时，我们要为他们设置 padding值：</p><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">padding</span> - <span class="hljs-attribute">bottom</span>:    constant (safe - area - inset - bottom);  <span class="hljs-attribute">padding</span> - <span class="hljs-attribute">bottom</span>:    env (safe - area - inset - bottom);&#125;</code></pre></div><h2 id="横屏检测"><a href="#横屏检测" class="headerlink" title="横屏检测"></a>横屏检测</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;resize&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.orientation === <span class="hljs-number">180</span> || <span class="hljs-built_in">window</span>.orientation === <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// 正常方向或屏幕旋转180度</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;竖屏&#x27;</span>);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.orientation === <span class="hljs-number">90</span> || <span class="hljs-built_in">window</span>.orientation === -<span class="hljs-number">90</span>) &#123;    <span class="hljs-comment">// 屏幕顺时钟旋转90度或屏幕逆时针旋转90度</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;横屏&#x27;</span>);  &#125;&#125;);</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">orientation</span>: portrait) &#123;  <span class="hljs-comment">/*竖屏...*/</span>&#125;<span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">orientation</span>: landscape) &#123;  <span class="hljs-comment">/*横屏...*/</span>&#125;</code></pre></div><h2 id="图片模糊问题"><a href="#图片模糊问题" class="headerlink" title="图片模糊问题"></a>图片模糊问题</h2><p>在 dpr&gt;1的屏幕上，位图的一个像素可能由多个物理像素来渲染，然而这些物理像素点并不能被准确的分配上对应位图像素的颜色，只能取近似值，所以相同的图片在 dpr&gt;1的屏幕上就会模糊:</p><p>解决方法：</p><ul><li><p>使用不同分辨率的图片</p><ul><li><p>@media查询改url(<strong>backgroundimgae</strong>)</p></li><li><p>-webkit-image-set(<strong>backgroundimgae</strong>)</p><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;foo.png&quot;</span>);  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">-webkit-image-set</span>(<span class="hljs-string">&quot;foo.png&quot;</span><span class="hljs-number">1</span>x,      <span class="hljs-string">&quot;foo-2x.png&quot;</span><span class="hljs-number">2</span>x,      <span class="hljs-string">&quot;foo-print.png&quot;</span><span class="hljs-number">600dpi</span>);  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">image-set</span>(<span class="hljs-string">&quot;foo.png&quot;</span><span class="hljs-number">1</span>x,      <span class="hljs-string">&quot;foo-2x.png&quot;</span><span class="hljs-number">2</span>x,      <span class="hljs-string">&quot;foo-print.png&quot;</span><span class="hljs-number">600dpi</span>);&#125;&lt; !-- 由于一些浏览器不支持image-set，所以先写常规的url方式。对于识别这个属性的，浏览器会在普通屏下显示<span class="hljs-number">1</span>x的图像；Retina屏幕下显示<span class="hljs-number">2</span>x的图像；更高分辨率（比如印刷）显示<span class="hljs-number">600dpi</span>图像。 --&gt;</code></pre></div></li><li><p>srcset</p><p>以最合适的src去匹配不同屏幕</p><div class="hljs code-wrapper"><pre><code class="hljs css">&lt;img src=&quot;source.jpg&quot; srcset=&quot;source_2x.jpg 2x, source_3x.jpg 3x&quot;&gt;</code></pre></div></li><li><p>使用js拼接图片src<br>先查询处当前设备dpr,正则替换掉文件名</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dpr = <span class="hljs-built_in">window</span>.devicePixelRatio;<span class="hljs-keyword">const</span> images = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;img&#x27;</span>);images.forEach(<span class="hljs-function">(<span class="hljs-params">img</span>) =&gt;</span> &#123;    img.src.replace(<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">`@<span class="hljs-subst">$&#123;dpr&#125;</span>x.`</span>);&#125;)</code></pre></div></li><li><p>使用svg</p><p><em>可缩放矢量图（ ScalableVectorGraphics）</em></p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>webapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现一个sleep()函数</title>
    <link href="/2019/07/03/%E5%AE%9E%E7%8E%B0sleep()/"/>
    <url>/2019/07/03/%E5%AE%9E%E7%8E%B0sleep()/</url>
    
    <content type="html"><![CDATA[<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h2><blockquote><p>执行挂起，延迟执行函数</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">funciton <span class="hljs-function"><span class="hljs-title">sleep</span>(<span class="hljs-params">delay</span>)</span> &#123;  <span class="hljs-keyword">let</span> start = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime()  <span class="hljs-keyword">while</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime() - start &lt; delay) &#123;    <span class="hljs-keyword">continue</span>  &#125;&#125;sleep(<span class="hljs-number">3000</span>)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;sleep&#x27;</span>)<span class="hljs-comment">// 3000ms后打印sleep</span></code></pre></div><h3 id="Promise-then"><a href="#Promise-then" class="headerlink" title="Promise + then"></a>Promise + then</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">delay</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve,delay))&#125;sleep(<span class="hljs-number">3000</span>).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;sleep&#x27;</span>))<span class="hljs-comment">// 3000ms后打印sleep</span></code></pre></div><h3 id="async-await"><a href="#async-await" class="headerlink" title="async + await"></a>async + await</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">delay</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve,delay))&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">demo</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a&#x27;</span>)  <span class="hljs-keyword">await</span> sleep(<span class="hljs-number">3000</span>).then(<span class="hljs-function">()=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;b&#x27;</span>)  &#125;)  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;c&#x27;</span>)&#125;demo()<span class="hljs-comment">// a</span><span class="hljs-comment">// 3000ms后</span><span class="hljs-comment">// b c</span></code></pre></div><h3 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">sleep</span>(<span class="hljs-params">delay</span>) </span>&#123;  <span class="hljs-keyword">yield</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, delay))&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a&#x27;</span>)sleep(<span class="hljs-number">3000</span>).next().value.then( <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;b&#x27;</span>)&#125;)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;c&#x27;</span>)<span class="hljs-comment">// a c</span><span class="hljs-comment">// 3000ms</span><span class="hljs-comment">// b</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
      <tag>es6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css选择器</title>
    <link href="/2019/07/03/css%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <url>/2019/07/03/css%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>!important&gt;行内样式&gt;id选择器&gt;类选择器&gt;标签选择器&gt;通配符&gt;继承</p><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><ul><li><p><code>E[attribute]</code> 表示存在attr属性即可</p><p><code>div[class]</code></p></li><li><p><code>E[attr=val]</code> 表示属性值完全等于val</p><p><code>div[class=mydemo]</code></p></li><li><p><code>E[attr|=val]</code> 表示属性值中以val值开始，val不是字符而是完整单词</p><p><code>div[class|=mydemo]</code><br><code>div class=&quot;smike mmydemo&quot;不会生效</code></p></li><li><p><code>E[attr*=val]</code> 表示的属性值里包含val字符并且在“任意”位置</p><p><code>div[class*=mydemo]</code></p></li><li><p><code>E[attr^=val]</code> 表示的属性值里包含val字符并且在“开始”位置</p><p><code>div[class^=mydemo]</code></p></li><li><p><code>E[attr$=val]</code> 表示的属性值里包含val字符并且在“结束”位置</p><p><code>div[class$=demos]</code></p></li></ul><h2 id="伪类选择器-伪元素选择器"><a href="#伪类选择器-伪元素选择器" class="headerlink" title="伪类选择器/伪元素选择器"></a>伪类选择器/伪元素选择器</h2><ul><li><p>伪类 指定要选择的元素的特殊状态（根据状态改变样式）。例如，a标签的<code>:link</code>,<code>:visited</code>,<code>:hover</code>,<code>:active</code>; 以及<code>:first-child</code>,<code>:last-child</code>等。</p></li><li><p>伪元素 对被选择元素的//特定部分//修改样式。例如<code>::before</code>,<code>::after</code>,<code>::first-letter</code>,<code>::first-line</code>。css3只新增了一个伪元素<code>::selection</code>（改变用户所选取部分的样式）。</p></li></ul><h3 id="a标签的伪类顺序"><a href="#a标签的伪类顺序" class="headerlink" title="a标签的伪类顺序"></a>a标签的伪类顺序</h3><p>LVHA-<code>a:link a:visited a:hover a:active</code></p><h3 id="以某元素相对于其父元素或兄弟元素的位置来获取无素的结构伪类-css3"><a href="#以某元素相对于其父元素或兄弟元素的位置来获取无素的结构伪类-css3" class="headerlink" title="以某元素相对于其父元素或兄弟元素的位置来获取无素的结构伪类   // css3"></a>以某元素相对于其父元素或兄弟元素的位置来获取无素的结构伪类   // css3</h3><ul><li>E:first-child:查找E这个元素的父元素的第一个子元素E  </li><li>E:last-child:最后一个子元素  // css3</li><li>E:nth-child(n): 第n个子元素，计算方法是E元素的全部兄弟元素  </li><li>E:nth-last-child(n): 同E:nth-child(n) 相似，只是倒着计算  </li><li>E:nth-child(even): 所有的偶数</li><li>E:nth-child(odd): 所有的奇数</li><li>E:nth-of-type(n):指定类型</li><li>E:empty 选中没有任何子节点的E元素，注意，空格也算子元素</li><li>E:target 结合锚点进行使用，处于当前锚点的元素会被选中</li></ul><blockquote><p>n遵循线性变化，其取值0、1、2、3、4、… 但是当n&lt;=0时，选取无效</p></blockquote><h4 id="其他伪类"><a href="#其他伪类" class="headerlink" title="其他伪类"></a>其他伪类</h4><ul><li>::enabled ::disabled控制表单控件的禁用状态</li><li>:checked单选框或复选框被选中</li></ul><h4 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h4><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/*第一个li元素*/</span><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first</span>-child&#123;    <span class="hljs-attribute">color</span>: red;&#125;<span class="hljs-comment">/*最后一个元素*/</span><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:last-child</span>&#123;    <span class="hljs-attribute">color</span>: green;&#125;<span class="hljs-comment">/*获取第10个元素*/</span><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">10</span>)&#123;    <span class="hljs-attribute">color</span>: orange;&#125;<span class="hljs-comment">/*获取倒数第3个li元素*/</span><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-last-child</span>(<span class="hljs-number">3</span>)&#123;    <span class="hljs-attribute">color</span>: purple;&#125;<span class="hljs-comment">/*获取索引顺序为6的倍数的li元素*/</span><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">6</span>n)&#123;    <span class="hljs-attribute">text-decoration</span>: underline;    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;&#125;<span class="hljs-comment">/*获取所有索引为偶数的li元素*/</span><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child</span>(even)&#123;    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;&#125;<span class="hljs-comment">/*获取前5个li元素*/</span><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child</span>(-n+<span class="hljs-number">5</span>)&#123;    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ddd</span>;&#125;</code></pre></div><h4 id="n可是多种形式：nth-child-2n-、nth-child-2n-1-、nth-child-n-5-等"><a href="#n可是多种形式：nth-child-2n-、nth-child-2n-1-、nth-child-n-5-等" class="headerlink" title="n可是多种形式：nth-child(2n)、nth-child(2n+1)、nth-child(-n+5)等"></a>n可是多种形式：nth-child(2n)、nth-child(2n+1)、nth-child(-n+5)等</h4><h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><h4 id="E-before、E-after-css3"><a href="#E-before、E-after-css3" class="headerlink" title="E::before、E::after   // css3"></a>E::before、E::after   // css3</h4><ul><li>行内元素，需要转换成块:<code>display:block</code>   float:**  position:</li><li>必须添加content,哪怕不设置内容，也需要<code>content:&quot;&quot;</code></li><li>E:after、E:before 在旧版本里是伪类，在新版本里是伪元素，<code>新版本下E:after、E:before会被自动识别为E::after、E::before</code>，按伪元素来对待，这样做的目的是用来做兼容处理</li><li><code>E::before</code>: 定义在一个元素的内容之前插入content属性定义的内容与样式</li><li><code>E::after</code>: 定义在一个元素的内容之后插入content属性定义的内容与样式</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>IE6、IE7与IE8（<code>怪异模式Quirks mode</code>）不支持此伪元素</li><li>CSS2中E:before或者E:after，是属于伪类的，并且没有伪元素的概念，CSS3中 提出伪元素的概念E::before和E::after，并且归属到了伪元素当中，伪类里就不再存在E:before或者   E:after伪类</li><li><code>E::first-letter</code>文本的第一个字母或字(不是词组)</li><li><code>E::first-line</code> 文本第一行</li><li><code>E::selection</code> 可改变选中文本的样式</li></ul><h2 id="其他选择器"><a href="#其他选择器" class="headerlink" title="其他选择器"></a>其他选择器</h2><h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h3><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-id">#idname</span>&#123;&#125;<span class="hljs-comment">/* id选择器只能选择一次 */</span><span class="hljs-comment">/* 第一个设置该id的生效  */</span></code></pre></div><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.classname</span>&#123;&#125;<span class="hljs-selector-class">.class1</span><span class="hljs-selector-class">.class2</span>&#123;&#125; <span class="hljs-comment">/* 多个类选择，中间没有空格 */</span></code></pre></div><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.dv1</span> <span class="hljs-selector-tag">li</span>&#123;&#125;<span class="hljs-comment">/* class为dv1的div后代中所有的li元素都被选中 */</span></code></pre></div><h3 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h3><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&gt;<span class="hljs-selector-tag">span</span>&#123;&#125;<span class="hljs-comment">/* 只有div的直系子元素span被选中 */</span><span class="hljs-comment">/* div中的ul中的span不会被选中 */</span></code></pre></div><h3 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="兄弟选择器"></a>兄弟选择器</h3><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.dv1</span>+<span class="hljs-selector-tag">div</span>&#123;&#125; <span class="hljs-comment">/* class为dv1的div相邻的div被选中  */</span> <span class="hljs-comment">/* 相邻的排在其后面的第一个兄弟生效 */</span>&lt;<span class="hljs-selector-tag">ul</span>&gt;    &lt;<span class="hljs-selector-tag">li</span>&gt;List item <span class="hljs-number">1</span>&lt;/<span class="hljs-selector-tag">li</span>&gt;    &lt;<span class="hljs-selector-tag">li</span>&gt;List item <span class="hljs-number">2</span>&lt;/<span class="hljs-selector-tag">li</span>&gt;    &lt;<span class="hljs-selector-tag">li</span>&gt;List item <span class="hljs-number">3</span>&lt;/<span class="hljs-selector-tag">li</span>&gt;  &lt;/<span class="hljs-selector-tag">ul</span>&gt;这里的 <span class="hljs-selector-tag">li</span> + <span class="hljs-selector-tag">li</span> 则后面两个<span class="hljs-selector-tag">li</span>都生效</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Koa</title>
    <link href="/2019/06/18/koa/"/>
    <url>/2019/06/18/koa/</url>
    
    <content type="html"><![CDATA[<h2 id="中间件机制"><a href="#中间件机制" class="headerlink" title="中间件机制"></a>中间件机制</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript">app.use(<span class="hljs-keyword">async</span>(ctx,next)=&gt;&#123;  ctx.body = <span class="hljs-string">&#x27;hello koa!&#x27;</span>  next()  ctx.body += <span class="hljs-string">&#x27;onion back step2&#x27;</span>&#125;)app.use(<span class="hljs-keyword">async</span>(ctx,next)=&gt;&#123;  ctx.body += <span class="hljs-string">&#x27;onion back step1&#x27;</span>  next()  ctx.body += <span class="hljs-string">&#x27;hello next&#x27;</span>&#125;)<span class="hljs-comment">// 洋葱圈模型</span>hello koa!onion back step1hello nextonion back step2</code></pre></div><h2 id="async-wait"><a href="#async-wait" class="headerlink" title="async/wait"></a>async/wait</h2><h3 id="js异步处理的发展"><a href="#js异步处理的发展" class="headerlink" title="js异步处理的发展"></a>js异步处理的发展</h3><ol><li>callbackHell </li><li>Promis</li><li>async/wait</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>node</tag>
      
      <tag>Koa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript</title>
    <link href="/2019/06/16/typescript/"/>
    <url>/2019/06/16/typescript/</url>
    
    <content type="html"><![CDATA[<h2 id="TypeScript-is-a-typed-superset-of-JavaScript-that-compiles-to-plain-JavaScript-ts是js的超集，相比js添加了可选的静态类型和基于类的面向对象编程"><a href="#TypeScript-is-a-typed-superset-of-JavaScript-that-compiles-to-plain-JavaScript-ts是js的超集，相比js添加了可选的静态类型和基于类的面向对象编程" class="headerlink" title="TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. ts是js的超集，相比js添加了可选的静态类型和基于类的面向对象编程"></a>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. ts是js的超集，相比js添加了可选的静态类型和基于类的面向对象编程</h2><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>string(字符串)</li><li>number(数字)</li><li>boolean(布尔)</li><li>array(数组)</li><li>tuple(元祖)</li><li>enum(枚举)</li><li>any(任意)</li><li>null</li><li>undefined</li><li>void</li><li>never</li></ul><h2 id="类型校验"><a href="#类型校验" class="headerlink" title="类型校验"></a>类型校验</h2><p> 不按照定义的数据类型赋值报错</p><h3 id="array-数组"><a href="#array-数组" class="headerlink" title="array/数组"></a>array/数组</h3>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//第一种</span><span class="hljs-keyword">var</span> arr1:number:[] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-comment">//第二种</span><span class="hljs-keyword">var</span> arr2:<span class="hljs-built_in">Array</span>&lt;number&gt; = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]</code></pre></div><ul><li><p>数组的项中不能出现其他类型</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fibonacci: number[] = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>];<span class="hljs-comment">// = 后的类型被推断为number|string，前面是number，报错</span></code></pre></div></li><li><p>数组的一些方法的参数类型也会受到限制</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">number[]的数组中push(<span class="hljs-string">&#x27;abc&#x27;</span>)报错<span class="hljs-comment">// abc是字符串</span></code></pre></div></li><li><p>数组泛型</p></li><li><p>用接口表示数组</p></li><li><p>any/任意类型的数组</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> list: any[] = [<span class="hljs-string">&#x27;Xcat Liu&#x27;</span>, <span class="hljs-number">25</span>, &#123; <span class="hljs-attr">website</span>: <span class="hljs-string">&#x27;http://xcatliu.com&#x27;</span> &#125;];</code></pre></div></li><li><p>类数组/Array-like Object<br>常见的类数组都有自己的接口定义</p></li></ul><h3 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple/元组"></a>tuple/元组</h3><p>元组按一定顺序预定义数组结构中的重数据类型</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> tuple1: [number,string,boolean];tuple1 = [<span class="hljs-number">666</span>,<span class="hljs-string">&#x27;字符串&#x27;</span>,<span class="hljs-literal">true</span>]</code></pre></div><h3 id="enum-枚举"><a href="#enum-枚举" class="headerlink" title="enum/枚举"></a>enum/枚举</h3><p>实现考虑到某一变量可能的值，尽量用自然语言中含义清楚的单词来表达他的每一个值。这种方法叫做枚举方法，用这种方法定义的数据类型</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">enum Flag  &#123;  success = <span class="hljs-number">1</span>,  error = <span class="hljs-number">2</span>&#125;<span class="hljs-keyword">let</span> s:Flag = Flag.success<span class="hljs-built_in">console</span>.log(s) <span class="hljs-comment">// 1</span><span class="hljs-comment">// 未赋值则打印下标</span></code></pre></div><h3 id="任意值类型-any"><a href="#任意值类型-any" class="headerlink" title="任意值类型 any"></a>任意值类型 any</h3><blockquote><p>ts中的普通类型在赋值过程中不能改变类型</p></blockquote>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> myFavoriteNumber: string = <span class="hljs-string">&#x27;seven&#x27;</span>;myFavoriteNumber = <span class="hljs-number">7</span>;<span class="hljs-comment">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not  assignable to type &#x27;string&#x27;.</span><span class="hljs-comment">// any类型就可以改变</span><span class="hljs-keyword">let</span> myFavoriteNumber: any = <span class="hljs-string">&#x27;seven&#x27;</span>;myFavoriteNumber = <span class="hljs-number">7</span>;</code></pre></div><ul><li>任意值上可以访问任何属性和方法，</li><li>声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</li><li>未声明类型的变量，自动给识别为任意类型<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> something;something = <span class="hljs-string">&#x27;seven&#x27;</span>;something = <span class="hljs-number">7</span>;something.setName(<span class="hljs-string">&#x27;Tom&#x27;</span>);</code></pre></div></li></ul><h3 id="其他类型-never"><a href="#其他类型-never" class="headerlink" title="其他类型/never"></a>其他类型/never</h3><p>  表示从不会出现的值</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a:nevera = (<span class="hljs-function">()=&gt;</span>&#123;  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;错误&#x27;</span>)&#125;)</code></pre></div><h3 id="null-undefined是never的子类型"><a href="#null-undefined是never的子类型" class="headerlink" title="null/undefined是never的子类型"></a>null/undefined是never的子类型</h3>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num1:<span class="hljs-literal">undefined</span><span class="hljs-keyword">var</span> num2:<span class="hljs-literal">undefined</span> | numbernum = <span class="hljs-number">2</span><span class="hljs-built_in">console</span>.log(num2) <span class="hljs-comment">//2</span><span class="hljs-keyword">var</span> num3:<span class="hljs-literal">null</span>num = <span class="hljs-literal">null</span> <span class="hljs-comment">// ok</span>num = 其他都报错</code></pre></div><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>  一般用于定义的方法没有return</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">yell</span>(<span class="hljs-params"></span>):<span class="hljs-title">void</span></span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;666&#x27;</span>)&#125;</code></pre></div><h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><ul><li><p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type      Inference）的规则推断出一个类型。  </p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> myFavoriteNumber = <span class="hljs-string">&#x27;seven&#x27;</span>;<span class="hljs-comment">// 被自动推测为string类型</span>myFavoriteNumber = <span class="hljs-number">7</span>;<span class="hljs-comment">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span></code></pre></div></li><li><p>！！！！未声明类型的变量！！！！！<br>自动给识别为任意类型<br>不会被类型检查推测</p></li></ul><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> myFavoriteNumber: string | number;myFavoriteNumber = <span class="hljs-string">&#x27;seven&#x27;</span>;myFavoriteNumber = <span class="hljs-number">7</span>;</code></pre></div><ul><li>可以访问联合类型的共有的属性或方法</li><li>联合类型的变量在赋值的时候，一样会被推断出一个类型</li></ul>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getString</span>(<span class="hljs-params">something: string | number</span>): <span class="hljs-title">string</span> </span>&#123;  <span class="hljs-keyword">return</span> something.toString();&#125;<span class="hljs-keyword">let</span> myFavoriteNumber: string | number;myFavoriteNumber = <span class="hljs-string">&#x27;seven&#x27;</span>;<span class="hljs-built_in">console</span>.log(myFavoriteNumber.length); <span class="hljs-comment">// 5</span>myFavoriteNumber = <span class="hljs-number">7</span>;<span class="hljs-built_in">console</span>.log(myFavoriteNumber.length); <span class="hljs-comment">// 编译时报错</span></code></pre></div><ul><li><p>类型别名常用于联合类型</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">type Name = string;type NameResolver = <span class="hljs-function">() =&gt;</span> string;type NameOrResolver = Name | NameResolver;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params">n: NameOrResolver</span>): <span class="hljs-title">Name</span> </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> n === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;    <span class="hljs-keyword">return</span> n;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> n();  &#125;&#125;</code></pre></div></li></ul><h3 id="对象的类型-接口-interfaces"><a href="#对象的类型-接口-interfaces" class="headerlink" title="对象的类型-接口/interfaces"></a>对象的类型-接口/interfaces</h3><ul><li>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。</li><li>TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。<div class="hljs code-wrapper"><pre><code class="hljs javascript">interface Person &#123;name: string;age: number;&#125;<span class="hljs-keyword">let</span> xiaoming: Person = &#123;name: <span class="hljs-string">&#x27;xiaoming&#x27;</span>,age: <span class="hljs-number">66</span>&#125;</code></pre></div></li><li>赋值时，变量的形状必须和接口的形状保持一致，属性不多也不少<ul><li>可选属性<div class="hljs code-wrapper"><pre><code class="hljs javascript">age?: number;<span class="hljs-comment">//age可有可无</span></code></pre></div></li><li>任意属性<br>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集<div class="hljs code-wrapper"><pre><code class="hljs javascript">interface Person &#123;name: string;age?: number;[propName: string]: string;&#125;<span class="hljs-keyword">let</span> tom: Person = &#123;    name: <span class="hljs-string">&#x27;Tom&#x27;</span>,    age: <span class="hljs-number">25</span>,    gender: <span class="hljs-string">&#x27;male&#x27;</span>&#125;;<span class="hljs-comment">//age?--&gt;25是number--&gt;number不是[propName: string]: string;的子集</span><span class="hljs-comment">// index.ts(3,5): error TS2411: Property &#x27;age&#x27; of type    &#x27;number&#x27; is not assignable to string index type &#x27;string&#x27;.</span><span class="hljs-comment">// index.ts(7,5): error TS2322: Type &#x27;&#123; [x: string]: string |     number; name: string; age: number; gender: string; &#125;&#x27; is not    assignable to type &#x27;Person&#x27;.</span><span class="hljs-comment">//   Index signatures are incompatible.</span><span class="hljs-comment">//     Type &#x27;string | number&#x27; is not assignable to type     &#x27;string&#x27;.</span><span class="hljs-comment">//       Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span></code></pre></div><ul><li>只读属性<br>只能在创建的时候被赋值<div class="hljs code-wrapper"><pre><code class="hljs javascript">interface Person &#123;readonly id: number;name: string;age?: number;[propName: string]: any;&#125;<span class="hljs-keyword">let</span> tom: Person = &#123;  id: <span class="hljs-number">89757</span>,  name: <span class="hljs-string">&#x27;Tom&#x27;</span>,  gender: <span class="hljs-string">&#x27;male&#x27;</span>&#125;;tom.id = <span class="hljs-number">9527</span>;<span class="hljs-comment">// index.ts(14,5): error TS2540: Cannot assign to &#x27;id&#x27; because it is a constant or a read-only property.</span></code></pre></div></li></ul></li></ul></li></ul><h3 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h3><ul><li><p>函数声明</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x: number, y: number</span>): <span class="hljs-title">number</span> </span>&#123;  <span class="hljs-keyword">return</span> x + y;&#125;<span class="hljs-comment">// 输入的参数不能多也不能少</span></code></pre></div></li><li><p>函数表达式<br>！！！这里不是箭头函数</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> mySum: <span class="hljs-function">(<span class="hljs-params">x: number, y: number</span>) =&gt;</span> number&#123;  <span class="hljs-keyword">return</span> x + y&#125;<span class="hljs-keyword">let</span> mySum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x: number, y: number</span>): <span class="hljs-title">number</span> </span>&#123;  <span class="hljs-keyword">return</span> x + y;&#125;;<span class="hljs-comment">//在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</span></code></pre></div></li><li><p>用接口定义函数的形状</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">interface SearchFunc &#123;  (source: string, <span class="hljs-attr">subString</span>: string): boolean;&#125;<span class="hljs-keyword">let</span> mySearch: SearchFunc;mySearch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">source: string, subString: string</span>) </span>&#123;  <span class="hljs-keyword">return</span> source.search(subString) !== -<span class="hljs-number">1</span>;&#125;</code></pre></div></li><li><p>可选参数和对象的可选属性一样，加?</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 可选参数只能配置到参数们的末尾</span>firstName?: string, <span class="hljs-attr">lastName</span>: string<span class="hljs-comment">// 报错！！！！</span>firstName: string, lastName?: string<span class="hljs-comment">// ok</span></code></pre></div></li><li><p>参数默认值</p><p>  <code>(firstName: string, lastName: string = &#39;Cat&#39;)</code><br>  识别为可选参数<br>  不再受可选择参数必须放在必须参数后面的限制</p></li><li><p>函数重载</p><ul><li>不同输入输出选项的函数，可以重复定义多次，把精确的定义写在前面</li><li>TypeScript 会优先从最前面的函数定义开始匹配</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: number</span>): <span class="hljs-title">number</span></span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: string</span>): <span class="hljs-title">string</span></span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: number | string</span>): <span class="hljs-title">number</span> | <span class="hljs-title">string</span> </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(x.toString().split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>));  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;    <span class="hljs-keyword">return</span> x.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>);  &#125;&#125;</code></pre></div></li></ul><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><ul><li>在不确定类型的时候就访问方法或者属性会报错</li><li>此时使用类型断言，在需要断言的变量之前加上<type></li><li>断言只能存在联合类型中的类型</li></ul>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>(<span class="hljs-params">something: string | number</span>): <span class="hljs-title">number</span> </span>&#123;  <span class="hljs-keyword">if</span> ((&lt;string&gt;something).length) &#123;      <span class="hljs-keyword">return</span> (&lt;string&gt;something).length  &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> something.toString().length  &#125;&#125;</code></pre></div><h3 id="声明语句"><a href="#声明语句" class="headerlink" title="声明语句"></a>声明语句</h3><ul><li>declare var 声明全局变量</li><li>declare function 声明全局方法</li><li>declare class 声明全局类</li><li>declare enum 声明全局枚举类型</li><li>declare namespace 声明（含有子属性的）全局对象</li><li>interface 和 type 声明全局类型</li><li>export 导出变量</li><li>export namespace 导出（含有子属性的）对象</li><li>export default ES6 默认导出</li><li>export = commonjs 导出模块</li><li>export as namespace UMD 库声明全局变量</li><li>declare global 扩展全局变量</li><li>declare module 扩展模块</li><li>/// <reference /> 三斜线指令</li><li>使用 @types 统一管理第三方库的声明文件。</li></ul><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>  <a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib">https://github.com/Microsoft/TypeScript/tree/master/src/lib</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XML</title>
    <link href="/2019/06/15/XML/"/>
    <url>/2019/06/15/XML/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-XML"><a href="#什么是-XML" class="headerlink" title="什么是 XML"></a>什么是 XML</h2><p>XML 指可扩展标记语言（EXtensible Markup Language）<br>XML 是一种标记语言，很类似 HTML<br>XML 的设计宗旨是传输数据，而非显示数据，本身是不作为的<br>XML 标签没有被预定义。您需要自行定义标签。<br>XML 被设计为具有自我描述性。<br>XML 是 W3C 的推荐标准</p><h2 id="一句话区别"><a href="#一句话区别" class="headerlink" title="一句话区别"></a>一句话区别</h2><ul><li>XML 被设计用来传输和存储数据。</li><li>HTML 被设计用来显示数据。</li></ul><h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><ul><li><p>标签必须关闭</p></li><li><p>大小下颚敏感</p></li><li><p>正确的嵌套</p></li><li><p>根元素</p></li><li><p>属性必须加引号</p></li><li><p>实体引用</p><ul><li>&lt;    &lt;    小于</li><li>&gt;    &gt;    大于</li><li>&amp;    &amp;    和号</li><li>&apos;    ‘    单引号</li><li>&quot;    “    引号</li></ul></li><li><p>多个空格被保留</p></li></ul><p>tips：</p><ul><li>尽量使用元素来描述数据。而仅仅使用属性来提供与数据无关的信息。</li><li>元数据（有关数据的数据）应当存储为属性，而数据本身应当存储为元素。<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span>&lt;note day=<span class="hljs-string">&quot;08&quot;</span> month=<span class="hljs-string">&quot;08&quot;</span> year=<span class="hljs-string">&quot;2008&quot;</span>to=<span class="hljs-string">&quot;George&quot;</span> <span class="hljs-keyword">from</span>=<span class="hljs-string">&quot;John&quot;</span> heading=<span class="hljs-string">&quot;Reminder&quot;</span> body=<span class="hljs-string">&quot;Don&#x27;t forget the meeting!&quot;</span>&gt;&lt;/note&gt;<span class="hljs-comment">// good</span>&lt;messages&gt;  &lt;note id=<span class="hljs-string">&quot;501&quot;</span>&gt;    &lt;to&gt;George&lt;/to&gt;    &lt;<span class="hljs-keyword">from</span>&gt;John&lt;/<span class="hljs-keyword">from</span>&gt;    &lt;heading&gt;Reminder&lt;/heading&gt;    &lt;body&gt;Don<span class="hljs-string">&#x27;t forget the meeting!&lt;/body&gt;</span><span class="hljs-string">  &lt;/note&gt;</span><span class="hljs-string">  &lt;note id=&quot;502&quot;&gt;</span><span class="hljs-string">    &lt;to&gt;John&lt;/to&gt;</span><span class="hljs-string">    &lt;from&gt;George&lt;/from&gt;</span><span class="hljs-string">    &lt;heading&gt;Re: Reminder&lt;/heading&gt;</span><span class="hljs-string">    &lt;body&gt;I will not&lt;/body&gt;</span><span class="hljs-string">  &lt;/note&gt; </span><span class="hljs-string">&lt;/messages&gt;</span></code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html,xhtml,xml</title>
    <link href="/2019/06/05/html,xhtml,xml/"/>
    <url>/2019/06/05/html,xhtml,xml/</url>
    
    <content type="html"><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>  (HyperText Markup Language)，超文本标记语言。“超文本”就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素，“标记”是指用特定的标记符号来标记要显示的内容的各个部分。超文本标记语言是标准通用标记语言下的一个应用，也是一种规范，一种标准，它被设计用来显示数据。HTML文本就是我们通常所说的网页，扩展名可以是html或htm。</p><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>  (Extensible Markup Language)，可扩展标记语言。XML是标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言，它被设计用来传输和存储数据，是对超文本标记语言的补充。可扩展标记语言是一种元标记语言，即定义了用于定义其他特定领域有关语义的、结构化的标记语言，这些标记语言将文档分成许多部件并对这些部件加以标识。它能够更精确地声明内容，方便跨越多种平台的更有意义的搜索结果。它提供了一种描述结构数据的格式，简化了网络中数据交换和表示，使得代码、数据和表示分离，并作为数据交换的标准格式，因此它常被称为智能数据文档，文件扩展名为xml。</p><h2 id="XHTML"><a href="#XHTML" class="headerlink" title="XHTML"></a>XHTML</h2><p>  (Extensible HyperText Markup Language)，可扩展超文本标记语言。XHTML基于可扩展标记语言（XML）。XHTML就是一个扮演着类似HTML的角色的可扩展标记语言（XML），所以，本质上说，XHTML是一个过渡技术，结合了部分XML的强大功能及大多数HTML的简单特性。XHTML 1.0是一种在HTML 4.0基础上优化和改进的的新语言，目的是基于XML应用。XHTML是一种增强了的HTML,XHTML 是更严谨更纯净的 HTML 版本。它的可扩展性和灵活性将适应未来网络应用更多的需求。XML虽然数据转换能力强大，完全可以替代HTML，但面对成千上万已有的基于HTML语言设计的网站，直接采用XML还为时过早。因此，在HTML4.0的基础上，用XML的规则对其进行扩展，得到了XHTML。所以，建立XHTML的目的就是实现HTML向XML的过渡。<br>  XHTML 于2000年的1月26日成为 W3C （World Wide Web Consortium ，万维网联盟），文件扩展名为xhtml。</p><ul><li>HTML被设计用来显示数据，其焦点是数据的外观；</li><li>XML被设计用来传输和存储数据，其焦点是数据的内容；</li><li>XHTML是更严格更纯净的 HTML 版本，是作为一种 XML 应用被重新定义的 HTML，设计的目的是为了取代HTML以适应未来网络更多的需求。</li></ul><h2 id="HTML、XML和XHTML都是标准通用标记语言的一个子集。它们都可以用来开发网页，但就目前来看，网页开发中HTML还是占绝对的主流，现在最新版本HTML5也备受推崇。可拓展标记语言XML广泛运用于各种应用程序中数据的存储（例如各种配置文件）和应用程序间的数据传输，可以说是一项必须掌握的技术。至于可扩展超文本标记语言XHTML，在2009年W3C已经宣布停止了对XHTML2的开发，转而大力支持HTML5。"><a href="#HTML、XML和XHTML都是标准通用标记语言的一个子集。它们都可以用来开发网页，但就目前来看，网页开发中HTML还是占绝对的主流，现在最新版本HTML5也备受推崇。可拓展标记语言XML广泛运用于各种应用程序中数据的存储（例如各种配置文件）和应用程序间的数据传输，可以说是一项必须掌握的技术。至于可扩展超文本标记语言XHTML，在2009年W3C已经宣布停止了对XHTML2的开发，转而大力支持HTML5。" class="headerlink" title="HTML、XML和XHTML都是标准通用标记语言的一个子集。它们都可以用来开发网页，但就目前来看，网页开发中HTML还是占绝对的主流，现在最新版本HTML5也备受推崇。可拓展标记语言XML广泛运用于各种应用程序中数据的存储（例如各种配置文件）和应用程序间的数据传输，可以说是一项必须掌握的技术。至于可扩展超文本标记语言XHTML，在2009年W3C已经宣布停止了对XHTML2的开发，转而大力支持HTML5。"></a>HTML、XML和XHTML都是标准通用标记语言的一个子集。它们都可以用来开发网页，但就目前来看，网页开发中HTML还是占绝对的主流，现在最新版本HTML5也备受推崇。可拓展标记语言XML广泛运用于各种应用程序中数据的存储（例如各种配置文件）和应用程序间的数据传输，可以说是一项必须掌握的技术。至于可扩展超文本标记语言XHTML，在2009年W3C已经宣布停止了对XHTML2的开发，转而大力支持HTML5。</h2><h2 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h2><ul><li><p>DOCTYPE是用来声明文档类型和DTD规范的，浏览器根据声明来决定使用何种协议解析以及切换浏览模式。</p><blockquote><p>DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。</p></blockquote></li><li><p>标准模式的排版和JS运行模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</p></li><li><p>写法</p><ul><li><p>HTML 5</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span></code></pre></div></li><li><p>HTML 4.01 Strict</p><p>该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//W3C//DTD HTML 4.01//EN&quot;</span>   <span class="hljs-meta-string">&quot;http://www.w3.org/TR/html4/strict.dtd&quot;</span>&gt;</span></code></pre></div></li><li><p>HTML 4.01 Transitional</p><p>该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> </span><span class="hljs-meta"><span class="hljs-meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></code></pre></div></li></ul></li></ul><h2 id="HTML的语义化"><a href="#HTML的语义化" class="headerlink" title="HTML的语义化"></a>HTML的语义化</h2><ol><li>清晰的结构，方便代码的阅读和维护</li><li>方便障碍用户的屏幕阅读器</li><li>有利于SEO优化，搜索引擎的爬虫依赖标签确定关键字的权重</li></ol><h2 id="xhtml和html有什么区别"><a href="#xhtml和html有什么区别" class="headerlink" title="xhtml和html有什么区别"></a>xhtml和html有什么区别</h2><ul><li>XHTML元素必须被正确地嵌套</li><li>XHTML元素必须被关闭</li><li>标签名必须小写</li><li>XHTML文档必须拥有根元素 </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue组件之间通信</title>
    <link href="/2019/05/24/vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <url>/2019/05/24/vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="ref和-refs"><a href="#ref和-refs" class="headerlink" title="ref和$refs"></a><code>ref和$refs</code></h3><ul><li><p><code>ref</code>挂载在普通HTML组件上访问它得到DOM</p></li><li><p><code>ref</code>挂载在VUE组件上访问它得到组件实例</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;usernameInput&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">base-input</span>&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$refs.usernameInput</code></pre></div><h3 id="emit和prop"><a href="#emit和prop" class="headerlink" title="$emit和prop"></a><code>$emit</code>和<code>prop</code></h3><ul><li>子组件<code>props</code>接收父组件传递的数据</li><li>动态数据加冒号<code>:</code></li><li>子组件可对收到的<code>props</code>设置校验</li><li>子组件定义<code>$emit</code>自定义方法<br><code>this.$emit(&#39;childToParentMsg&#39;,this.childInfor,this.type)</code></li><li>父组件就可以<code>v-on</code>监听该方法</li><li>该方法绑定父组件的<code>methods</code></li><li>获得方法中传递的参数</li></ul><h3 id="parent和-children"><a href="#parent和-children" class="headerlink" title="$parent和$children"></a><code>$parent</code>和<code>$children</code></h3><ul><li>$parent得到  <strong>对象</strong></li><li>$children得到子组件实例的    <strong>数组</strong></li></ul><h3 id="provide和inject"><a href="#provide和inject" class="headerlink" title="provide和inject"></a><code>provide</code>和<code>inject</code></h3><ul><li><p>父组件向<code>任意深度</code>子组件传值</p></li><li><p>父组件中通过<code>provide</code>来提供变量</p></li><li><p>子组件中通过<code>inject</code>来注入变量</p></li><li><p>不论子组件有多深，只要调用了<code>inject</code>那么就可以注入<code>provider</code>中的数据。只要在父组件的生命周期内，子组件都可以调用。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">Vue.component(<span class="hljs-string">&#x27;child&#x27;</span>,&#123;    <span class="hljs-comment">// </span>    inject:[<span class="hljs-string">&#x27;for&#x27;</span>],      <span class="xml">&lt;------------------将for变量插入本实例</span><span class="xml">    data()&#123;</span><span class="xml">        return &#123;</span><span class="xml">            mymessage:this.for</span><span class="xml">        &#125;</span><span class="xml">    &#125;</span><span class="xml">&#125;)</span><span class="xml">Vue.component(&#x27;parent&#x27;,&#123;</span>    provide:&#123;    &lt;---------------------------提供了for变量        for:&#x27;test&#x27;    &#125;&#125;)</code></pre></div></li></ul><h3 id="attrs-amp-amp-listeners"><a href="#attrs-amp-amp-listeners" class="headerlink" title="$attrs &amp;&amp; $listeners"></a><code>$attrs</code> &amp;&amp; <code>$listeners</code></h3><ul><li><p><code>$attrs</code>包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件</p></li><li><p><code>$listeners</code>包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件</p></li><li><p>继续<code>v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;</code>可以把属性和方法继续传递下去</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// A-&gt;B-&gt;C</span>Vue.component(<span class="hljs-string">&#x27;C&#x27;</span>,&#123;      template:<span class="hljs-string">`</span><span class="hljs-string">          &lt;div&gt;</span><span class="hljs-string">              &lt;input type=&quot;text&quot; v-model=&quot;$attrs.messagec&quot; @input=&quot;passCData($attrs.messagec)&quot;&gt; &lt;/div&gt;</span><span class="hljs-string">      `</span>,      methods:&#123;          <span class="hljs-function"><span class="hljs-title">passCData</span>(<span class="hljs-params">val</span>)</span>&#123;              <span class="hljs-comment">//触发父组件A中的事件</span>              <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;getCData&#x27;</span>,val)          &#125;      &#125;  &#125;)  Vue.component(<span class="hljs-string">&#x27;B&#x27;</span>,&#123;      <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;          <span class="hljs-keyword">return</span> &#123;              mymessage:<span class="hljs-built_in">this</span>.message          &#125;      &#125;,      template:<span class="hljs-string">`</span><span class="hljs-string">          &lt;div&gt;</span><span class="hljs-string">              &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @input=&quot;passData(mymessage)&quot;&gt; </span><span class="hljs-string">              &lt;C v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/C&gt;</span><span class="hljs-string">          &lt;/div&gt;</span><span class="hljs-string"></span><span class="hljs-string"></span><span class="hljs-string">      `</span>,      props:[<span class="hljs-string">&#x27;message&#x27;</span>],<span class="hljs-comment">//得到父组件传递过来的数据</span>      methods:&#123;          <span class="hljs-function"><span class="hljs-title">passData</span>(<span class="hljs-params">val</span>)</span>&#123;              <span class="hljs-comment">//触发父组件中的事件</span>              <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;getChildData&#x27;</span>,val)          &#125;      &#125;  &#125;)  Vue.component(<span class="hljs-string">&#x27;A&#x27;</span>,&#123;      template:<span class="hljs-string">`</span><span class="hljs-string">          &lt;div&gt;</span><span class="hljs-string">              &lt;p&gt;this is parent compoent!&lt;/p&gt;</span><span class="hljs-string">              &lt;B :messagec=&quot;messagec&quot; :message=&quot;message&quot; v-on:getCData=&quot;getCData&quot; v-on:getChildData=&quot;getChildData(message)&quot;&gt;&lt;/B&gt;</span><span class="hljs-string">          &lt;/div&gt;</span><span class="hljs-string">      `</span>,      <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;          <span class="hljs-keyword">return</span> &#123;              message:<span class="hljs-string">&#x27;hello&#x27;</span>,              messagec:<span class="hljs-string">&#x27;hello c&#x27;</span> <span class="hljs-comment">//传递给c组件的数据</span>          &#125;      &#125;,      methods:&#123;          <span class="hljs-function"><span class="hljs-title">getChildData</span>(<span class="hljs-params">val</span>)</span>&#123;              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这是来自B组件的数据&#x27;</span>)          &#125;,          <span class="hljs-comment">//执行C子组件触发的事件</span>          <span class="hljs-function"><span class="hljs-title">getCData</span>(<span class="hljs-params">val</span>)</span>&#123;              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;这是来自C组件的数据：&quot;</span>+val)          &#125;      &#125;  &#125;)</code></pre></div></li></ul><h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// eventBus.js</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">const</span> EventBus  = <span class="hljs-keyword">new</span> Vue()<span class="hljs-comment">// componentA</span><span class="hljs-keyword">import</span> EventBus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;eventBus.js&#x27;</span>methods:&#123;    <span class="hljs-function"><span class="hljs-title">someFunc</span>(<span class="hljs-params"></span>)</span>&#123;        EventBus.$emit(<span class="hljs-string">&#x27;funcName&#x27;</span>,&#123;            <span class="hljs-comment">//props</span>        &#125;)    &#125;&#125;<span class="hljs-comment">// componentsB</span><span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span>&#123;    EventBus.$on(<span class="hljs-string">&#x27;funcName&#x27;</span>,<span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> &#123;        <span class="hljs-comment">//params取得传过来的参数</span>    &#125;)&#125;</code></pre></div><h3 id="使用Vue-observable"><a href="#使用Vue-observable" class="headerlink" title="使用Vue.observable"></a>使用Vue.observable</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//猴版</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> state = Vue.observable(&#123;    someData:[...]&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mutation = &#123;    <span class="hljs-function"><span class="hljs-title">addData</span>(<span class="hljs-params">val</span>)</span>&#123;        someData.push(val)    &#125;    <span class="hljs-function"><span class="hljs-title">delData</span>(<span class="hljs-params">val</span>)</span>&#123;        soneData = someData.filter(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item!==val)    &#125;&#125;</code></pre></div><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tcp握手</title>
    <link href="/2019/05/24/tcp%E6%8F%A1%E6%89%8B/"/>
    <url>/2019/05/24/tcp%E6%8F%A1%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<p>ref：<a href="https://juejin.im/post/5ccd0dfc6fb9a0324a08bb73">关于三次握手与四次挥手面试官想考我们什么？</a></p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><ol><li>为了确保通信双方收发能力正常</li><li>指定自己的初始化序列号，为后面的可靠传送做准备</li><li>过程：<ul><li>第一次握手：<br>客户端给服务端发一个 <code>SYN</code> 报文，并指明客户端的初始化序列号 <code>ISN(c)</code>。此时客户端处于 <code>SYN_Send</code> 状态。</li><li>第二次握手：<br>服务器收到客户端的 <code>SYN</code> 报文之后，会以自己的 <code>SYN</code> 报文作为应答，并且也是指定了自己的初始化序列号 <code>ISN(s)</code>，同时会把客户端的 <code>ISN(c) + 1</code> 作为 <code>ACK(确认字符)</code> 的值，表示自己已经收到了客户端的 <code>SYN</code>，此时服务器处于 <code>SYN_REVD</code> 的状态。</li><li>第三次握手：<br>客户端收到 <code>SYN</code> 报文之后，会发送一个 <code>ACK</code> 报文，当然，也是一样把服务器的 <code>ISN(s) + 1</code> 作为 <code>ACK</code> 的值，表示已经收到了服务端的 <code>SYN</code> 报文，此时客户端处于 <code>establised</code> 状态。<blockquote><p>同时该tcp栈已经允许请求数据，例如同时带上一个GET请求</p></blockquote></li><li>服务器收到 ACK 报文之后，也处于 <code>establised</code> 状态，此时，双方以建立起了链接。</li></ul></li></ol><blockquote><p>半连接队列：<br>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。</p></blockquote><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><ol><li>断开tcp连接</li><li>过程：<ul><li>第一次挥手：<br>客户端发送<code>FIN</code> 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</li><li>第二次握手：<br>服务端收到 <code>FIN</code> 之后，会把客户端的序列号值 + 1 作为 <code>ACK</code> 报文的序列号值并发送给客户端，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code>状态。</li><li>第三次挥手：<br>如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 <code>FIN</code> 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态。</li><li>第四次挥手：<br>客户端收到 FIN 之后，也把服务端的序列号值 + 1 作为自己 <code>ACK</code> 报文的序列号值并发送给服务端,此时客户端处于 <code>TIME_WAIT</code> 状态。之后才会进入 <code>CLOSED</code> 状态</li><li>服务端收到 <code>ACK</code> 报文之后，就处于关闭连接了，处于 <code>CLOSED</code> 状态。</li></ul></li></ol><blockquote><p><code>TIME_WAIT</code> 状态:<br>客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭,确保服务器是否已经收到了 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</p></blockquote><blockquote><p>也可缩短为三次挥手，上述二三步骤合并，服务器同时回复ACK和FIN</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EventLoop题目</title>
    <link href="/2019/05/21/EventLoop%E9%A2%98/"/>
    <url>/2019/05/21/EventLoop%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><a href="%E7%96%AF%E7%8B%82%E5%81%B7%E9%A2%98*1">https://juejin.im/post/59e85eebf265da430d571f89</a><br><a href="%E7%96%AF%E7%8B%82%E5%81%B7%E9%A2%98*2">https://juejin.im/post/5c9a43175188252d876e5903</a></p><ol><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;定时器开始啦&#x27;</span>)&#125;);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;马上执行for循环啦&#x27;</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;        i == <span class="hljs-number">99</span> &amp;&amp; resolve();    &#125;&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;执行then函数啦&#x27;</span>)&#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;代码执行结束&#x27;</span>);<span class="hljs-comment">// 马上执行for循环啦</span><span class="hljs-comment">// 代码执行结束</span><span class="hljs-comment">// 执行then函数啦</span><span class="hljs-comment">// 定时器开始啦</span></code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);&#125;)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise&#x27;</span>);    resolve()&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;then&#x27;</span>);&#125;)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;console&#x27;</span>);<span class="hljs-comment">// promise</span><span class="hljs-comment">// console</span><span class="hljs-comment">// then</span><span class="hljs-comment">// setTimeout</span></code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// console.log(&#x27;2&#x27;);</span>    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);    &#125;)    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;        <span class="hljs-comment">// console.log(&#x27;4&#x27;);</span>        resolve();    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5&#x27;</span>)    &#125;)&#125;)process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>);&#125;)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;7&#x27;</span>);    resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;8&#x27;</span>)&#125;)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;10&#x27;</span>);    &#125;)    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;        resolve();    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;12&#x27;</span>)    &#125;)&#125;)</code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>) &#125;,<span class="hljs-number">0</span>)<span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">()=&gt;</span>&#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>) &#125;)<span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>) <span class="hljs-comment">// 3 2</span><span class="hljs-comment">// 1</span></code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>) &#125;,<span class="hljs-number">0</span>)<span class="hljs-keyword">let</span> a=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)    resolve()&#125;).then(<span class="hljs-function">()=&gt;</span>&#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>) &#125;).then(<span class="hljs-function">()=&gt;</span>&#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>) &#125;)<span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>) <span class="hljs-comment">// 2 5 3 4</span><span class="hljs-comment">// 1</span></code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)  resolve()  &#125;).then(<span class="hljs-function">()=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>)  &#125;)  a.then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)  &#125;)  a.then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)  &#125;)<span class="hljs-comment">// 2 5 3 4</span></code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise1&quot;</span>)    resolve()&#125;).then(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then11&quot;</span>)    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise2&quot;</span>)        resolve()    &#125;).then(<span class="hljs-function">()=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then21&quot;</span>)    &#125;).then(<span class="hljs-function">()=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then23&quot;</span>)     &#125;)&#125;).then(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then12&quot;</span>)&#125;)<span class="hljs-comment">// promise1,then11,promise2,then21,then12,then23</span></code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise1&quot;</span>)    resolve()&#125;).then(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then11&quot;</span>)     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise2&quot;</span>)        resolve()    &#125;).then(<span class="hljs-function">()=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then21&quot;</span>)     &#125;).then(<span class="hljs-function">()=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then23&quot;</span>)     &#125;)&#125;).then(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then12&quot;</span>)  &#125;)<span class="hljs-comment">// promise1 then11  promise2 then21 then12  then23</span></code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise1&quot;</span>)      resolve()&#125;).then(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then11&quot;</span>)      <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise2&quot;</span>)          resolve()    &#125;).then(<span class="hljs-function">()=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then21&quot;</span>)      &#125;).then(<span class="hljs-function">()=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then23&quot;</span>)      &#125;)&#125;).then(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then12&quot;</span>)  &#125;)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise3&quot;</span>)      resolve()&#125;).then(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then31&quot;</span>)  &#125;)<span class="hljs-comment">//promise1 promise3 then11 promise2 then31 then21 then12 then23</span></code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;async1 start&quot;</span>);    <span class="hljs-keyword">await</span>  async2();    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;async1 end&quot;</span>);&#125;<span class="hljs-keyword">async</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&#x27;async2&#x27;</span>);&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;script start&quot;</span>);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;settimeout&quot;</span>);&#125;,<span class="hljs-number">0</span>);async1();<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise1&quot;</span>);    resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise2&quot;</span>);&#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script end&#x27;</span>);<span class="hljs-comment">// script start,async1 start,async2,promise1,script end,async1 end,promise2</span><span class="hljs-comment">// settimeout</span></code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;async1 start&quot;</span>);    <span class="hljs-keyword">await</span>  async2();    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;async1 end&quot;</span>);&#125;<span class="hljs-keyword">async</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&#x27;async2&#x27;</span>);&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;script start&quot;</span>);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;settimeout&quot;</span>);&#125;);async1()<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise1&quot;</span>);    resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise2&quot;</span>);&#125;);setImmediate(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;setImmediate&quot;</span>)&#125;)process.nextTick(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;process&quot;</span>)&#125;)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script end&#x27;</span>); <span class="hljs-comment">//script start,async1 start,async2,promise1,script end,process,async1 end,promise2</span><span class="hljs-comment">//sttimeout,setImmediate</span></code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2019/05/21/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2019/05/21/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>// 黑马课件</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul><li>了解正则表达式基本语法</li><li>能够使用JavaScript的正则对象</li></ul><h3 id="正则表达式简介"><a href="#正则表达式简介" class="headerlink" title="正则表达式简介"></a>正则表达式简介</h3><h4 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h4><p>正则表达式：用于匹配规律规则的表达式，正则表达式最初是科学家对人类神经系统的工作原理的早期研究，现在在编程语言中有广泛的应用。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。<br>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p><h4 id="正则表达式的作用"><a href="#正则表达式的作用" class="headerlink" title="正则表达式的作用"></a>正则表达式的作用</h4><ol><li>给定的字符串是否符合正则表达式的过滤逻辑(匹配)</li><li>可以通过正则表达式，从字符串中获取我们想要的特定部分(提取)</li><li>强大的字符串替换能力(替换)</li></ol><h4 id="正则表达式的特点"><a href="#正则表达式的特点" class="headerlink" title="正则表达式的特点"></a>正则表达式的特点</h4><ol><li>灵活性、逻辑性和功能性非常的强</li><li>可以迅速地用极简单的方式达到字符串的复杂控制</li><li>对于刚接触的人来说，比较晦涩难懂</li></ol><h3 id="正则表达式的测试"><a href="#正则表达式的测试" class="headerlink" title="正则表达式的测试"></a>正则表达式的测试</h3><ul><li><a href="https://c.runoob.com/front-end/854">在线测试正则</a></li></ul><h3 id="正则表达式的组成"><a href="#正则表达式的组成" class="headerlink" title="正则表达式的组成"></a>正则表达式的组成</h3><ul><li>普通字符</li><li>特殊字符(元字符)：正则表达式中有特殊意义的字符<br>示例演示：</li><li><code>\d</code> 匹配数字</li><li><code>ab\d</code> 匹配 ab1、ab2</li></ul><h3 id="元字符串"><a href="#元字符串" class="headerlink" title="元字符串"></a>元字符串</h3><p>通过测试工具演示下面元字符的使用</p><h4 id="常用元字符串"><a href="#常用元字符串" class="headerlink" title="常用元字符串"></a>常用元字符串</h4><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td><code>\d</code></td><td>匹配数字</td></tr><tr><td><code>\D</code></td><td>匹配任意非数字的字符</td></tr><tr><td><code>\w</code></td><td>匹配字母或数字或下划线</td></tr><tr><td><code>\W</code></td><td>匹配任意不是字母，数字，下划线</td></tr><tr><td><code>\s</code></td><td>匹配任意的空白符</td></tr><tr><td><code>\S</code></td><td>匹配任意不是空白符的字符</td></tr><tr><td><code>.</code></td><td>匹配除换行符以外的任意单个字符</td></tr><tr><td><code>^</code></td><td>表示匹配行首的文本(以谁开始)</td></tr><tr><td><code>$</code></td><td>表示匹配行尾的文本(以谁结束)</td></tr></tbody></table><h4 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h4><table><thead><tr><th>限定符</th><th>说明</th></tr></thead><tbody><tr><td><code>*</code></td><td>重复零次或更多次</td></tr><tr><td><code>+</code></td><td>重复一次或更多次</td></tr><tr><td><code>?</code></td><td>重复零次或一次</td></tr><tr><td><code>&#123;n&#125;</code></td><td>重复n次</td></tr><tr><td><code>&#123;n,&#125;</code></td><td>重复n次或更多次</td></tr><tr><td><code>&#123;n,m&#125;</code></td><td>重复n到m次</td></tr></tbody></table><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p><code>[]</code> 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思<br><code>[^]</code>  匹配除中括号以内的内容<br><code>\</code> 转义符<br><code>|</code> 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱<br><code>()</code> 从两个直接量中选择一个，分组<code>eg：gr(a|e)y匹配gray和grey</code><br><code>[\u4e00-\u9fa5]</code>  匹配汉字</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th>标志</th><th>说明</th></tr></thead><tbody><tr><td><code>i</code></td><td>忽略大小写</td></tr><tr><td><code>g</code></td><td>全局匹配</td></tr><tr><td><code>gi</code></td><td>全局匹配+忽略大小写</td></tr></tbody></table><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>验证手机号：</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">^\d&#123;<span class="hljs-number">11</span>&#125;$</code></pre></div><p>验证邮编：</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">^\d&#123;<span class="hljs-number">6</span>&#125;$</code></pre></div><p>验证日期 2012-5-01</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">^\d&#123;<span class="hljs-number">4</span>&#125;-\d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;-\d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;$</code></pre></div><p>验证邮箱 <a href="mailto:&#120;&#120;&#x78;&#x40;&#105;&#x74;&#99;&#97;&#115;&#x74;&#x2e;&#x63;&#110;">&#120;&#120;&#x78;&#x40;&#105;&#x74;&#99;&#97;&#115;&#x74;&#x2e;&#x63;&#110;</a>：</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">^\w+@\w+\.\w+$</code></pre></div><p>验证IP地址 192.168.1.10</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">^\d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;\(.\d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;)&#123;<span class="hljs-number">3</span>&#125;$</code></pre></div><h2 id="JavaScript-中使用正则表达式"><a href="#JavaScript-中使用正则表达式" class="headerlink" title="JavaScript 中使用正则表达式"></a>JavaScript 中使用正则表达式</h2><h3 id="创建正则对象"><a href="#创建正则对象" class="headerlink" title="创建正则对象"></a>创建正则对象</h3><p>方式1：</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> Regex(<span class="hljs-string">&#x27;\d&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>);<span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> Regex(<span class="hljs-string">&#x27;\d&#x27;</span>, <span class="hljs-string">&#x27;gi&#x27;</span>);</code></pre></div><p>方式2：</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\d/i</span>;<span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\d/gi</span>;</code></pre></div><h3 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 匹配日期</span><span class="hljs-keyword">var</span> dateStr = <span class="hljs-string">&#x27;2015-10-10&#x27;</span>;<span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/</span><span class="hljs-built_in">console</span>.log(reg.test(dateStr));</code></pre></div><h3 id="匹配正则表达式"><a href="#匹配正则表达式" class="headerlink" title="匹配正则表达式"></a>匹配正则表达式</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/./</span>.test(<span class="hljs-string">&quot;除了回车换行以为的任意字符&quot;</span>));<span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/.*/</span>.test(<span class="hljs-string">&quot;0个到多个&quot;</span>));<span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/.+/</span>.test(<span class="hljs-string">&quot;1个到多个&quot;</span>));<span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/.?/</span>.test(<span class="hljs-string">&quot;哈哈&quot;</span>));<span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/[0-9]/</span>.test(<span class="hljs-string">&quot;9527&quot;</span>));<span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/[a-z]/</span>.test(<span class="hljs-string">&quot;what&quot;</span>));<span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/[A-Z]/</span>.test(<span class="hljs-string">&quot;Are&quot;</span>));<span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/[a-zA-Z]/</span>.test(<span class="hljs-string">&quot;干啥子&quot;</span>));<span class="hljs-comment">//false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/[0-9a-zA-Z]/</span>.test(<span class="hljs-string">&quot;9ebg&quot;</span>));<span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/b|(ara)/</span>.test(<span class="hljs-string">&quot;abra&quot;</span>));<span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/[a-z]&#123;2,3&#125;/</span>.test(<span class="hljs-string">&quot;arfsf&quot;</span>));<span class="hljs-comment">//true</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/\d/</span>.test(<span class="hljs-string">&quot;998&quot;</span>));<span class="hljs-comment">//true</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/\d*/</span>.test(<span class="hljs-string">&quot;998&quot;</span>));<span class="hljs-comment">//true</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/\d+/</span>.test(<span class="hljs-string">&quot;998&quot;</span>));<span class="hljs-comment">//true</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/\d&#123;0,&#125;/</span>.test(<span class="hljs-string">&quot;998&quot;</span>));<span class="hljs-comment">//true</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/\d&#123;2,3&#125;/</span>.test(<span class="hljs-string">&quot;998&quot;</span>));<span class="hljs-comment">//true</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/\D/</span>.test(<span class="hljs-string">&quot;eat&quot;</span>));<span class="hljs-comment">//true</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/\s/</span>.test(<span class="hljs-string">&quot;  &quot;</span>));<span class="hljs-comment">//true</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/\S/</span>.test(<span class="hljs-string">&quot;嘎嘎&quot;</span>));<span class="hljs-comment">//true</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/\w/</span>.test(<span class="hljs-string">&quot;_&quot;</span>));<span class="hljs-comment">//true</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/\W/</span>.test(<span class="hljs-string">&quot;_&quot;</span>));<span class="hljs-comment">//true</span></code></pre></div><h3 id="正则表达式案例"><a href="#正则表达式案例" class="headerlink" title="正则表达式案例"></a>正则表达式案例</h3><p>1.验证密码强弱<br>2.验证邮箱：[0-9a-zA-Z_.-]+[@][0-9a-zA-Z._-]+([.][a-zA-Z]+){1,2}<br>3.验证中文名字[\u4e00-\u9fa5]</p><h3 id="正则提取"><a href="#正则提取" class="headerlink" title="正则提取"></a>正则提取</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 提取工资</span><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;张三：1000，李四：5000，王五：8000。&quot;</span>;<span class="hljs-keyword">var</span> array = str.match(<span class="hljs-regexp">/\d+/g</span>);<span class="hljs-built_in">console</span>.log(array);<span class="hljs-comment">// 2. 提取email地址</span><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;123123@xx.com,fangfang@valuedopinions.cn286669312@qq.com 2、emailenglish@emailenglish.englishtown.com286669312@qq.com...&quot;</span>;<span class="hljs-keyword">var</span> array = str.match(<span class="hljs-regexp">/\w+@\w+\.\w+(\.\w+)?/g</span>);<span class="hljs-built_in">console</span>.log(array);<span class="hljs-comment">// 3. 分组提取  </span><span class="hljs-comment">// 3. 提取日期中的年部分  2015-5-10</span><span class="hljs-keyword">var</span> dateStr = <span class="hljs-string">&#x27;2016-1-5&#x27;</span>;<span class="hljs-comment">// 正则表达式中的()作为分组来使用，获取分组匹配到的结果用Regex.$1 $2 $3....来获取</span><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/(\d&#123;4&#125;)-\d&#123;1,2&#125;-\d&#123;1,2&#125;/</span>;<span class="hljs-keyword">if</span> (reg.test(dateStr)) &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">RegExp</span>.$1);&#125;<span class="hljs-comment">// 4. 提取邮件中的每一部分</span><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/(\w+)@(\w+)\.(\w+)(\.\w+)?/</span>;<span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;123123@xx.com&quot;</span>;<span class="hljs-keyword">if</span> (reg.test(str)) &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">RegExp</span>.$1);  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">RegExp</span>.$2);  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">RegExp</span>.$3);&#125;</code></pre></div><h3 id="正则替换"><a href="#正则替换" class="headerlink" title="正则替换"></a>正则替换</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 替换所有空白</span><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;   123AD  asadf   asadfasf  adf &quot;</span>;str = str.replace(<span class="hljs-regexp">/\s/g</span>,<span class="hljs-string">&quot;xx&quot;</span>);<span class="hljs-built_in">console</span>.log(str);<span class="hljs-comment">// 2. 替换所有,|，</span><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;abc,efg,123，abc,123，a&quot;</span>;str = str.replace(<span class="hljs-regexp">/,|，/g</span>, <span class="hljs-string">&quot;.&quot;</span>);<span class="hljs-built_in">console</span>.log(str);</code></pre></div><h3 id="案例：表单验证"><a href="#案例：表单验证" class="headerlink" title="案例：表单验证"></a>案例：表单验证</h3><div class="hljs code-wrapper"><pre><code class="hljs html">QQ号：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txtQQ&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>邮箱：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txtEMail&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>手机：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txtPhone&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>生日：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txtBirthday&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>姓名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txtName&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//获取文本框</span><span class="hljs-keyword">var</span> txtQQ = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;txtQQ&quot;</span>);<span class="hljs-keyword">var</span> txtEMail = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;txtEMail&quot;</span>);<span class="hljs-keyword">var</span> txtPhone = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;txtPhone&quot;</span>);<span class="hljs-keyword">var</span> txtBirthday = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;txtBirthday&quot;</span>);<span class="hljs-keyword">var</span> txtName = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;txtName&quot;</span>);<span class="hljs-comment">//</span>txtQQ.onblur = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">//获取当前文本框对应的span</span>  <span class="hljs-keyword">var</span> span = <span class="hljs-built_in">this</span>.nextElementSibling;  <span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^\d&#123;5,12&#125;$/</span>;  <span class="hljs-comment">//判断验证是否成功</span>  <span class="hljs-keyword">if</span>(!reg.test(<span class="hljs-built_in">this</span>.value) )&#123;    <span class="hljs-comment">//验证不成功</span>    span.innerText = <span class="hljs-string">&quot;请输入正确的QQ号&quot;</span>;    span.style.color = <span class="hljs-string">&quot;red&quot;</span>;  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-comment">//验证成功</span>    span.innerText = <span class="hljs-string">&quot;&quot;</span>;    span.style.color = <span class="hljs-string">&quot;&quot;</span>;  &#125;&#125;;<span class="hljs-comment">//txtEMail</span>txtEMail.onblur = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">//获取当前文本框对应的span</span>  <span class="hljs-keyword">var</span> span = <span class="hljs-built_in">this</span>.nextElementSibling;  <span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^\w+@\w+\.\w+(\.\w+)?$/</span>;  <span class="hljs-comment">//判断验证是否成功</span>  <span class="hljs-keyword">if</span>(!reg.test(<span class="hljs-built_in">this</span>.value) )&#123;    <span class="hljs-comment">//验证不成功</span>    span.innerText = <span class="hljs-string">&quot;请输入正确的EMail地址&quot;</span>;    span.style.color = <span class="hljs-string">&quot;red&quot;</span>;  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-comment">//验证成功</span>    span.innerText = <span class="hljs-string">&quot;&quot;</span>;    span.style.color = <span class="hljs-string">&quot;&quot;</span>;  &#125;&#125;;</code></pre></div><p>表单验证部分，封装成函数：</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> regBirthday = <span class="hljs-regexp">/^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/</span>;addCheck(txtBirthday, regBirthday, <span class="hljs-string">&quot;请输入正确的出生日期&quot;</span>);<span class="hljs-comment">//给文本框添加验证</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCheck</span>(<span class="hljs-params">element, reg, tip</span>) </span>&#123;  element.onblur = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">//获取当前文本框对应的span</span>    <span class="hljs-keyword">var</span> span = <span class="hljs-built_in">this</span>.nextElementSibling;    <span class="hljs-comment">//判断验证是否成功</span>    <span class="hljs-keyword">if</span>(!reg.test(<span class="hljs-built_in">this</span>.value) )&#123;      <span class="hljs-comment">//验证不成功</span>      span.innerText = tip;      span.style.color = <span class="hljs-string">&quot;red&quot;</span>;    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">//验证成功</span>      span.innerText = <span class="hljs-string">&quot;&quot;</span>;      span.style.color = <span class="hljs-string">&quot;&quot;</span>;    &#125;  &#125;;&#125;</code></pre></div><p>通过给元素增加自定义验证属性对表单进行验证：</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;frm&quot;</span>&gt;</span>  QQ号：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;txtQQ&quot;</span> <span class="hljs-attr">data-rule</span>=<span class="hljs-string">&quot;qq&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  邮箱：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;txtEMail&quot;</span> <span class="hljs-attr">data-rule</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  手机：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;txtPhone&quot;</span> <span class="hljs-attr">data-rule</span>=<span class="hljs-string">&quot;phone&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  生日：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;txtBirthday&quot;</span> <span class="hljs-attr">data-rule</span>=<span class="hljs-string">&quot;date&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  姓名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;txtName&quot;</span> <span class="hljs-attr">data-rule</span>=<span class="hljs-string">&quot;cn&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 所有的验证规则</span><span class="hljs-keyword">var</span> rules = [  &#123;    name: <span class="hljs-string">&#x27;qq&#x27;</span>,    reg: <span class="hljs-regexp">/^\d&#123;5,12&#125;$/</span>,    tip: <span class="hljs-string">&quot;请输入正确的QQ&quot;</span>  &#125;,  &#123;    name: <span class="hljs-string">&#x27;email&#x27;</span>,    reg: <span class="hljs-regexp">/^\w+@\w+\.\w+(\.\w+)?$/</span>,    tip: <span class="hljs-string">&quot;请输入正确的邮箱地址&quot;</span>  &#125;,  &#123;    name: <span class="hljs-string">&#x27;phone&#x27;</span>,    reg: <span class="hljs-regexp">/^\d&#123;11&#125;$/</span>,    tip: <span class="hljs-string">&quot;请输入正确的手机号码&quot;</span>  &#125;,  &#123;    name: <span class="hljs-string">&#x27;date&#x27;</span>,    reg: <span class="hljs-regexp">/^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/</span>,    tip: <span class="hljs-string">&quot;请输入正确的出生日期&quot;</span>  &#125;,  &#123;    name: <span class="hljs-string">&#x27;cn&#x27;</span>,    reg: <span class="hljs-regexp">/^[\u4e00-\u9fa5]&#123;2,4&#125;$/</span>,    tip: <span class="hljs-string">&quot;请输入正确的姓名&quot;</span>  &#125;];addCheck(<span class="hljs-string">&#x27;frm&#x27;</span>);<span class="hljs-comment">//给文本框添加验证</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCheck</span>(<span class="hljs-params">formId</span>) </span>&#123;  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,      len = <span class="hljs-number">0</span>,      frm =<span class="hljs-built_in">document</span>.getElementById(formId);  len = frm.children.length;  <span class="hljs-keyword">for</span> (; i &lt; len; i++) &#123;    <span class="hljs-keyword">var</span> element = frm.children[i];    <span class="hljs-comment">// 表单元素中有name属性的元素添加验证</span>    <span class="hljs-keyword">if</span> (element.name) &#123;      element.onblur = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-comment">// 使用dataset获取data-自定义属性的值</span>        <span class="hljs-keyword">var</span> ruleName = <span class="hljs-built_in">this</span>.dataset.rule;        <span class="hljs-keyword">var</span> rule =getRuleByRuleName(rules, ruleName);        <span class="hljs-keyword">var</span> span = <span class="hljs-built_in">this</span>.nextElementSibling;        <span class="hljs-comment">//判断验证是否成功</span>        <span class="hljs-keyword">if</span>(!rule.reg.test(<span class="hljs-built_in">this</span>.value) )&#123;          <span class="hljs-comment">//验证不成功</span>          span.innerText = rule.tip;          span.style.color = <span class="hljs-string">&quot;red&quot;</span>;        &#125;<span class="hljs-keyword">else</span>&#123;          <span class="hljs-comment">//验证成功</span>          span.innerText = <span class="hljs-string">&quot;&quot;</span>;          span.style.color = <span class="hljs-string">&quot;&quot;</span>;        &#125;      &#125;    &#125;  &#125;&#125;<span class="hljs-comment">// 根据规则的名称获取规则对象</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRuleByRuleName</span>(<span class="hljs-params">rules, ruleName</span>) </span>&#123;  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,      len = rules.length;  <span class="hljs-keyword">var</span> rule = <span class="hljs-literal">null</span>;  <span class="hljs-keyword">for</span> (; i &lt; len; i++) &#123;    <span class="hljs-keyword">if</span> (rules[i].name == ruleName) &#123;      rule = rules[i];      <span class="hljs-keyword">break</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> rule;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git分布式版本控制</title>
    <link href="/2019/05/20/git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    <url>/2019/05/20/git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424">ref:liaoxuefeng</a></p><ol><li>创建与合并分支</li></ol><ul><li><p>查看分支：<code>git branch</code></p></li><li><p>创建分支：<code>git branch &lt;name&gt;</code></p></li><li><p>切换分支：<code>git checkout &lt;name&gt;</code></p></li><li><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></p></li><li><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p></li><li><p>删除分支：<code>git branch -d &lt;name&gt;</code></p></li></ul><ol><li>解决冲突</li></ol><ul><li>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</li><li>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</li><li><code>git log --graph</code>看到分支合并图</li></ul><ol><li>分支管理策略</li></ol><ul><li><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p></li><li><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p></li><li><div class="hljs code-wrapper"><pre><code class="hljs js">git merge --no-ff -m <span class="hljs-string">&quot;merge with no-ff&quot;</span> dev</code></pre></div></li><li><p>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p></li></ul><ol><li>缓存工作现场</li></ol><ul><li><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p></li><li><p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场</p></li><li><p>用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除</p></li><li><p>多次的stash，可以使用<code>git stash list</code>查看</p></li></ul><ol><li>多人协作</li></ol><ul><li><p>查看远程库信息，使用<code>git remote -v</code></p></li><li><p>本地新建的分支如果不推送到远程，对其他人就是不可见的</p></li><li><p>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交</p></li><li><p>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致</p></li><li><p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code></p></li><li><p>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</p></li></ul><ol><li>Rebase<br><a href="https://www.codercto.com/a/45325.html">https://www.codercto.com/a/45325.html</a></li></ol><ul><li><p><code>git.rebase</code>操作可以把本地未push的多个分叉提交历史整理成直线；</p></li><li><p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p><ol><li>当你的分支要提交时比master落后，一般要先merge master再commit</li><li>可使用rebase将你的分支patch为基于最新master的新分支后commit</li><li>在总的时间线上就省略了一个merge的记录</li></ol></li></ul><ol><li>cherrypick</li></ol><ul><li><code>git cherry-pick</code>选择某一个分支中的一个或几个commit来进行操作</li><li>需要在本地合入其他分支的提交时，如果我们不想对整个分支进行合并（merge），而是只想将某一次提交合入到本地当前分支上</li></ul><ol><li>.gitignore文件</li></ol><ul><li><code>.gitignore</code>文件用来制定git忽略追踪的文件和文件夹</li><li>如果仓库已建立缓存（commit add push）后把原先文件加入忽略<div class="hljs code-wrapper"><pre><code class="hljs javascript">git rm -r --cached [path]<span class="hljs-comment">// 之后重新add即可</span></code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端模块化</title>
    <link href="/2019/05/20/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2019/05/20/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="模块化开发的思想"><a href="#模块化开发的思想" class="headerlink" title="模块化开发的思想"></a>模块化开发的思想</h2><p>模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。</p><h3 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h3><ul><li>命名冲突</li><li>文件依赖</li><li>代码复用</li></ul><h3 id="CommonJS-Node-js"><a href="#CommonJS-Node-js" class="headerlink" title="CommonJS (Node.js)"></a>CommonJS (Node.js)</h3><ul><li><p>代码同步加载，服务器不用考虑速度</p></li><li><p>代码可以多次加载，但是运行结果会被缓存</p><ul><li><code>require(&#39;xxx&#39;)</code>加载模块</li><li><code>module.exports</code>(全局变量或方法)和<code>exports</code>定义对外的接口</li></ul></li></ul><h3 id="AMD-require-js"><a href="#AMD-require-js" class="headerlink" title="AMD (require.js)"></a>AMD (require.js)</h3><ul><li><code>Async Module Definition</code></li><li>代码异步加载，模块的加载不影响后续函数运行</li><li>依赖前置，在定义模块的时候就要声明其依赖的模块</li><li>执行顺序不一定和代码中顺序相同，而是谁先下载完执行谁  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// AMD</span>define([<span class="hljs-string">&quot;./a&quot;</span>, <span class="hljs-string">&quot;./b&quot;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;<span class="hljs-comment">// ...</span>a.doSomething();<span class="hljs-comment">// ...</span>b.doSomething();<span class="hljs-comment">// ...可能b比a先do了</span>&#125;);</code></pre></div></li></ul><h3 id="CMD-sea-js"><a href="#CMD-sea-js" class="headerlink" title="CMD (sea.js)"></a>CMD (sea.js)</h3><ul><li><code>Common Module Definition</code></li><li> 定义和加载与AMD相同</li><li> 依赖可以就近书写</li><li>依赖全部加载完才按顺序执行  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// CMD</span>define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>) </span>&#123;<span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./a&quot;</span>);a.doSomething();<span class="hljs-comment">//...</span><span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./b&quot;</span>); b.doSomething();<span class="hljs-comment">// ...</span>&#125;);</code></pre></div></li></ul><h3 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h3><ul><li> <code>Universal Module Definition</code></li><li> 写法是一个自运行函数</li><li> 兼容CMD/AMD/命名空间</li></ul><h3 id="ES6-MODULE"><a href="#ES6-MODULE" class="headerlink" title="ES6 MODULE"></a>ES6 MODULE</h3><ul><li><p>！ES6模块不是对象，<code>import</code>指向的是模块的的只读引用（<strong>动态引用</strong>），<code>export</code>只是显式指定输出的代码</p></li><li><p>编译时加载,用到才执行</p></li><li><p><code>export</code>导出模块,提供<code>export default</code>制定默认输出</p></li><li><p><code>import</code>引入</p></li><li><p><code>import</code>和<code>export</code>命令只能写在代码顶层</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// modules.js</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;    <span class="hljs-keyword">return</span> x * y;&#125;<span class="hljs-keyword">export</span> &#123;add <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>&#125;;<span class="hljs-comment">// 等同于</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> add;<span class="hljs-comment">// app.js</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;modules&#x27;</span>;<span class="hljs-comment">// 等同于</span><span class="hljs-keyword">import</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;modules&#x27;</span>;</code></pre></div></li></ul><h3 id="ES6-MODULE和CommonJS的区别"><a href="#ES6-MODULE和CommonJS的区别" class="headerlink" title="ES6 MODULE和CommonJS的区别"></a>ES6 MODULE和CommonJS的区别</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// CommonJS模块</span><span class="hljs-comment">// 运行时加载</span><span class="hljs-keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-comment">// 等同于</span><span class="hljs-keyword">let</span> _fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-keyword">let</span> stat = _fs.stat;<span class="hljs-keyword">let</span> exists = _fs.exists;<span class="hljs-keyword">let</span> readfile = _fs.readfile;<span class="hljs-comment">//上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”</span>modules.exports xxx<span class="hljs-comment">//CommonJS 模块输出的是值的拷贝，输出后模块内部的变化就影响不到这个值</span><span class="hljs-comment">// ES6</span><span class="hljs-comment">// 编译时加载</span><span class="hljs-keyword">import</span> &#123; stat, exists, readFile &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;<span class="hljs-comment">//上面代码的实质是从fs模块加载 3 个方法，其他方法不加载</span><span class="hljs-comment">//这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。</span><span class="hljs-comment">//当然，这也导致了没法引用 ES6 模块本身，因为它不是对象</span><span class="hljs-built_in">exports</span> <span class="hljs-keyword">default</span> xxx<span class="hljs-comment">// ES6 MODULES输出的是值的引用，运行时才到指定模块中取值</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>柯里化</title>
    <link href="/2019/05/19/%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <url>/2019/05/19/%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li><em>柯里化</em>将具有多个参数的函数被分解为多个函数，当被串联调用时，将一次一个地累积所有需要的参数。这种技术帮助编写函数式风格的代码，使代码更易读、紧凑。</li><li><em>偏函数</em>就是将一个 n 参的函数转换成固定 x 参的函数，剩余参数（n - x）将在下次调用全部传入<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2></li></ul><ol><li><p>参数复用</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 正常正则验证字符串 reg.test(txt)</span><span class="hljs-comment">// 函数封装后</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">check</span>(<span class="hljs-params">reg, txt</span>) </span>&#123;  <span class="hljs-keyword">return</span> reg.test(txt);&#125;check(<span class="hljs-regexp">/\d+/g</span>, <span class="hljs-string">&quot;test&quot;</span>); <span class="hljs-comment">//false</span>check(<span class="hljs-regexp">/[a-z]+/g</span>, <span class="hljs-string">&quot;test&quot;</span>); <span class="hljs-comment">//true</span><span class="hljs-comment">// Currying后</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curryingCheck</span>(<span class="hljs-params">reg</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">txt</span>) </span>&#123;    <span class="hljs-keyword">return</span> reg.test(txt);  &#125;;&#125;<span class="hljs-keyword">var</span> hasNumber = curryingCheck(<span class="hljs-regexp">/\d+/g</span>);<span class="hljs-keyword">var</span> hasLetter = curryingCheck(<span class="hljs-regexp">/[a-z]+/g</span>);hasNumber(<span class="hljs-string">&quot;test1&quot;</span>); <span class="hljs-comment">// true</span>hasNumber(<span class="hljs-string">&quot;testtest&quot;</span>); <span class="hljs-comment">// false</span>hasLetter(<span class="hljs-string">&quot;21212&quot;</span>); <span class="hljs-comment">// false</span></code></pre></div></li><li><p>提前确定</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 避免每次执行都判断</span><span class="hljs-keyword">var</span> on = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element, event, handler</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.addEventListener) &#123;    <span class="hljs-keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;      element.addEventListener(event, handler, <span class="hljs-literal">false</span>);    &#125;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;      element.attachEvent(<span class="hljs-string">&quot;on&quot;</span> + event, handler);    &#125;  &#125;&#125;;<span class="hljs-keyword">var</span> on = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.addEventListener) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element, event, handler</span>) </span>&#123;      <span class="hljs-keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;        element.addEventListener(event, handler, <span class="hljs-literal">false</span>);      &#125;    &#125;;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element, event, handler</span>) </span>&#123;      <span class="hljs-keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;        element.attachEvent(<span class="hljs-string">&quot;on&quot;</span> + event, handler);      &#125;    &#125;;  &#125;&#125;)();</code></pre></div></li><li><p>延迟运行</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//bind</span><span class="hljs-built_in">Function</span>.prototype.bind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) </span>&#123;  context = context || <span class="hljs-built_in">window</span>;  <span class="hljs-keyword">let</span> bindArgs = [...arguments].slice(<span class="hljs-number">1</span>);  <span class="hljs-keyword">let</span> func = <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> callArgs = [...arguments];    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> func) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> func(callArgs);    <span class="hljs-keyword">return</span> func.apply(context, bindArgs.concat(callArgs));  &#125;;&#125;;</code></pre></div></li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>isType<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// isType</span><span class="hljs-keyword">let</span> isType = <span class="hljs-function">(<span class="hljs-params">type</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj) === <span class="hljs-string">&quot;[object &quot;</span> + type + <span class="hljs-string">&quot;]&quot;</span>;&#125;;<span class="hljs-keyword">let</span> res = isType(<span class="hljs-string">&quot;String&quot;</span>)(<span class="hljs-string">&quot;123&quot;</span>);<span class="hljs-built_in">console</span>.log(res);<span class="hljs-comment">// let isType = function(type)&#123;</span><span class="hljs-comment">//  return function(obj)&#123;</span><span class="hljs-comment">//    return Object.prototype.toString.call</span><span class="hljs-comment">// (obj) === &#x27;[object &#x27; + type + &#x27;]&#x27;</span><span class="hljs-comment">//  &#125;</span><span class="hljs-comment">//&#125;</span></code></pre></div></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 实现连续求和函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x,y</span>)</span>&#123;  <span class="hljs-keyword">return</span> x+y&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> cur = [...arguments].reduce(add);  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerSum</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> next = [...arguments].reduce(add);    cur += next;    <span class="hljs-keyword">return</span> innerSum;  &#125;  innerSum.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> cur;  &#125;;  <span class="hljs-comment">// 控制台打印时候会自动调用toString方法</span>  <span class="hljs-keyword">return</span> innerSum;&#125;<span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>)(<span class="hljs-number">9</span>)); <span class="hljs-comment">// 25</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 柯里化函数</span><span class="hljs-keyword">const</span> curry = <span class="hljs-function">(<span class="hljs-params">fn, ...args1</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">...args2</span>) =&gt;</span>  (<span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> (arr.length === fn.length ? fn(...arr) : curry(fn, ...arr)))([    <span class="hljs-comment">// fn.length获取function需要的参数个数</span>    ...args1,    ...args2,  ]);<span class="hljs-keyword">const</span> curry = <span class="hljs-function">(<span class="hljs-params">fn,...args</span>) =&gt;</span> fn.length &lt;= args.length ? fn(...args) : curry.bind(<span class="hljs-literal">null</span>,fn,...args)<span class="hljs-comment">// 拆开写版本</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">func,...args1</span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args2</span>)</span>&#123;    <span class="hljs-keyword">let</span> args = [...args1,...args2]    <span class="hljs-keyword">if</span>(args.length===func.length)&#123;      <span class="hljs-keyword">return</span> func(...args)    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-keyword">return</span> curry(func,...args)    &#125;  &#125;&#125;</code></pre></div><h3 id="打印对象时候的调用"><a href="#打印对象时候的调用" class="headerlink" title="打印对象时候的调用"></a>打印对象时候的调用</h3><ul><li><p>直接打印对象,先<code>toString</code>再<code>valueOf</code></p><p>若 toString 和 valueOf 都返回对象则程序报错</p></li><li><p>打印对象做数值运算，先<code>valueOf</code>再<code>toString</code></p></li><li><p>控制台输出函数名字，先<code>valueOf</code>再<code>toString</code></p><p>若 toString 和 valueOf 都返回对象程序也不报错</p></li><li><blockquote><p>上述步骤如若第一步输出原始值则不继续执行</p></blockquote></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>devServer.proxy对象</title>
    <link href="/2019/05/13/webpack%E4%BB%A3%E7%90%86%EF%BC%8C%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE/"/>
    <url>/2019/05/13/webpack%E4%BB%A3%E7%90%86%EF%BC%8C%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>该功能由http-proxy-middleware提供</p></blockquote><p>开发环境中经常会用ajax获取假数据模拟渲染页面</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">methods: &#123;  getHomeInfo () &#123;    axios.get(<span class="hljs-string">&#x27;/static/testData/index.json&#x27;</span>)      .then(<span class="hljs-built_in">this</span>.getHomeInfoSucc)  &#125;,  getHomeInfoSucc (res) &#123;    <span class="hljs-built_in">console</span>.log(res)  &#125;&#125;</code></pre></div><p>项目上线时，api接口都要写成api的格式</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">axios.get(<span class="hljs-string">&#x27;/api/index.json&#x27;</span>)</code></pre></div><p><em>实际生产中在项目上线之前修改代码是很高风险的操作</em></p><p>所以我们可以使用代理来解决，即在开发环境下给url路径设置代理</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 配置该代理在config/index.js</span>dev: &#123;...    proxyTable: &#123;      <span class="hljs-comment">//  请求 /api 都会被转发到target下的路径</span>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;        target: <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>,        <span class="hljs-comment">// 并且改写路径</span>        pathRewrite: &#123;          <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;/static/data&#x27;</span>          <span class="hljs-comment">// 最终请求地址就是http://localhost:8080/static/data</span>          <span class="hljs-comment">// 也可以置空 改写 pathRewrite</span>        &#125;      &#125;    &#125;...<span class="hljs-comment">// 多个代理可以使用数组</span>proxy: [&#123;  context: [<span class="hljs-string">&quot;/auth&quot;</span>, <span class="hljs-string">&quot;/api&quot;</span>],  target: <span class="hljs-string">&quot;http://localhost:3000&quot;</span>,&#125;]<span class="hljs-comment">//默认情况下，不接受运行在 HTTPS 上，且使用了无效证书的后端服务器。如果你想要接受，修改配置如下：</span>proxy: &#123;  <span class="hljs-string">&quot;/api&quot;</span>: &#123;    target: <span class="hljs-string">&quot;https://other-server.example.com&quot;</span>,    secure: <span class="hljs-literal">false</span>  &#125;&#125;<span class="hljs-comment">// 有时你不想代理所有的请求。可以基于一个函数的返回值绕过代理</span>proxy: &#123;  <span class="hljs-string">&quot;/api&quot;</span>: &#123;    target: <span class="hljs-string">&quot;http://localhost:3000&quot;</span>,    <span class="hljs-comment">// 在函数中你可以访问请求体、响应体和代理选项。必须返回 false 或路径，来跳过代理请求。</span>   <span class="hljs-comment">//对于浏览器请求，你想要提供一个 HTML 页面，但是对于其他 API 请求则保持代理。你可以这样做：</span>    bypass: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, proxyOptions</span>) </span>&#123;      <span class="hljs-keyword">if</span> (req.headers.accept.indexOf(<span class="hljs-string">&quot;html&quot;</span>) !== -<span class="hljs-number">1</span>) &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Skipping proxy for browser request.&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index.html&quot;</span>;      &#125;    &#125;  &#125;&#125;<span class="hljs-comment">// 受到跨域限制时</span>proxy: &#123;      <span class="hljs-string">&#x27;/api&#x27;</span>: <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>,      changeOrigin: <span class="hljs-literal">true</span>      <span class="hljs-comment">// 改变请求的源</span>    &#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-router导航守卫。。。其实就是钩子啦</title>
    <link href="/2019/05/12/vue-router/"/>
    <url>/2019/05/12/vue-router/</url>
    
    <content type="html"><![CDATA[<p>正如其名，vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。</p><p>记住参数或查询的改变并不会触发进入/离开的导航守卫。你可以通过观察 $route 对象来应对这些变化，或使用 beforeRouteUpdate 的组件内守卫。</p><h1 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h1><p>你可以使用 router.beforeEach 注册一个全局前置守卫：</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123; ... &#125;)router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;)</code></pre></div><p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 等待中。</p><p>每个守卫方法接收三个参数：</p><ul><li><p><code>to</code>: Route: 即将要进入的目标 路由对象</p></li><li><p><code>from</code>: Route: 当前导航正要离开的路由</p></li><li><p><code>next</code>: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。</p><ul><li><p><code>next()</code>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</p></li><li><p><code>next(false)</code>: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。</p></li><li><p><code>next(&#39;/&#39;)</code> 或者 <code>next(&#123; path: &#39;/&#39; &#125;)</code>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: ‘home’ 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。</p></li><li><p><code>next(error)</code>: (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。</p></li></ul><blockquote><p>确保要调用 next 方法，否则钩子就不会被 resolved。</p></blockquote></li></ul><h1 id="全局解析守卫"><a href="#全局解析守卫" class="headerlink" title="全局解析守卫"></a>全局解析守卫</h1><blockquote><p>2.5.0 新增</p></blockquote><p>在 2.5.0+ 你可以用 <code>router.beforeResolve</code> 注册一个全局守卫。这和 <code>router.beforeEach</code> 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。</p><h1 id="全局后置钩子"><a href="#全局后置钩子" class="headerlink" title="全局后置钩子"></a>全局后置钩子</h1><p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身：</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">router.afterEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;)</code></pre></div><h1 id="路由独享的守卫"><a href="#路由独享的守卫" class="headerlink" title="路由独享的守卫"></a>路由独享的守卫</h1><p>你可以在路由配置上直接定义 <code>beforeEnter</code> 守卫：</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;  routes: [    &#123;      path: <span class="hljs-string">&#x27;/foo&#x27;</span>,      component: Foo,      beforeEnter: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;        <span class="hljs-comment">// ...</span>      &#125;    &#125;  ]&#125;)</code></pre></div><p>这些守卫与全局前置守卫的方法参数是一样的。</p><h1 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h1><p>最后，你可以在路由组件内直接定义以下路由导航守卫：</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">beforeRouteEnterbeforeRouteUpdate (<span class="hljs-number">2.2</span> 新增)beforeRouteLeave<span class="hljs-keyword">const</span> Foo = &#123;  template: <span class="hljs-string">`...`</span>,  beforeRouteEnter (to, <span class="hljs-keyword">from</span>, next) &#123;    <span class="hljs-comment">// 在渲染该组件的对应路由被 confirm 前调用</span>    <span class="hljs-comment">// 不！能！获取组件实例 `this`</span>    <span class="hljs-comment">// 因为当守卫执行前，组件实例还没被创建</span>  &#125;,  beforeRouteUpdate (to, <span class="hljs-keyword">from</span>, next) &#123;    <span class="hljs-comment">// 在当前路由改变，但是该组件被复用时调用</span>    <span class="hljs-comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span>    <span class="hljs-comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span>    <span class="hljs-comment">// 可以访问组件实例 `this`</span>  &#125;,  beforeRouteLeave (to, <span class="hljs-keyword">from</span>, next) &#123;    <span class="hljs-comment">// 导航离开该组件的对应路由时调用</span>    <span class="hljs-comment">// 可以访问组件实例 `this`</span>  &#125;&#125;</code></pre></div><p><code>beforeRouteEnter</code> 守卫 不能 访问 this，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。</p><p>不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">beforeRouteEnter (to, <span class="hljs-keyword">from</span>, next) &#123;  next(<span class="hljs-function"><span class="hljs-params">vm</span> =&gt;</span> &#123;    <span class="hljs-comment">// 通过 `vm` 访问组件实例</span>  &#125;)&#125;</code></pre></div><blockquote><p>注意 <code>beforeRouteEnter</code> 是支持给 next 传递回调的唯一守卫。对于 <code>beforeRouteUpdate 和 </code>beforeRouteLeave` 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript">beforeRouteUpdate (to, <span class="hljs-keyword">from</span>, next) &#123;  <span class="hljs-comment">// just use `this`</span>  <span class="hljs-built_in">this</span>.name = to.params.name  next()&#125;</code></pre></div><p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">beforeRouteLeave (to, <span class="hljs-keyword">from</span> , next) &#123;  <span class="hljs-keyword">const</span> answer = <span class="hljs-built_in">window</span>.confirm(<span class="hljs-string">&#x27;Do you really want to leave? you have unsaved changes!&#x27;</span>)  <span class="hljs-keyword">if</span> (answer) &#123;    next()  &#125; <span class="hljs-keyword">else</span> &#123;    next(<span class="hljs-literal">false</span>)  &#125;&#125;</code></pre></div><h1 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h1><ol><li>导航被触发。</li><li>在失活的组件里调用离开守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue生命周期</title>
    <link href="/2019/05/12/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2019/05/12/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>生命周期函数就是组件在初始化或者数据更新时会触发的钩子函数</p><ol><li><p><code>beforeCreate</code></p><p> 【创建前】实例化了一个空的vue实例对象，只有最基本的生命周期函数和方法，data，prop数据和methods都是获取不到的（这些数据在<code>initState()</code>中初始化）</p><ul><li>loading效果</li></ul></li><li><p><code>created</code></p><p> 【创建后】数据的初始化已经完成</p><ul><li>如果要调用methods的方法或者修改data数据最早只能在<code>craeted</code>中操作</li><li>进行Ajax数据的请求获取</li></ul></li><li><p><code>beforeMount</code></p><p> 【挂载前】内存中的模版已经编译好了，还没有挂载在页面中</p></li><li><p><code>Mounted</code></p><p> 【挂载后】将内存中的模版替换到浏览器页面中</p><ul><li>与dom相关的操作，最早只能在<code>mounted</code>中进行</li><li>mounted执行完了就代表vue实例已经初始化完毕，进入运行阶段</li><li>可以配合$.nextTick 使用进行单一事件对数据的更新后更新dom</li></ul></li><li><p>在被<code>keep-alive</code>组件包裹的组件才有的</p><ul><li><p><code>actived</code></p><ul><li>activated在组件第一次渲染时会被调用，之后在每次缓存组件被激活时调用。</li></ul></li><li><p><code>deactived</code></p><ul><li>使用了keep-alive就不会调用beforeDestroy(组件销毁前钩子)和destroyed(组件销毁)，因为组件没被销毁，被缓存起来了。</li></ul></li><li><p>缓存了组件之后，再次进入组件不会触发beforeCreate、created 、beforeMount、 mounted</p></li><li><p>keep-alive的作用主要是在组件切换时，保存组件的状态，防止重复渲染引发性能问题。</p></li></ul></li><li><p><code>beforeUpdate</code></p><p> 【更新前】data数据是新的，页面数据还是旧的</p><ul><li><code>vdom re-render and patch</code>以新的data数据在内存中渲染新的模版,新旧模版进行patch对比，将要更新的dom渲染到页面中</li><li>可以在更新前访问现有dom，如手动移除添加的事件监听器；</li></ul></li><li><p><code>updated</code></p><p> 【更新后】data数据和页面已经是同步的了</p><ul><li>此步骤不可操作数据，会进入死循环</li></ul></li><li><p><code>beforeDestory</code></p><p> 【销毁前】执行<code>beforeDestory</code>钩子，vue实例就从运行阶段进入销毁阶段</p><ul><li>执行<code>beforeDestory</code>的时候，实例身上的所有功能数据都还在，没有进行真正的销毁过程</li><li>之后就开始销毁，如果有子组件也会被销毁</li><li>添加销毁确认的提示</li><li>在实例销毁之前可用于销毁定时器，插件对象，解绑一些使用addEventListener 监听的事件等</li></ul></li><li><p><code>destoryed</code></p><p> 【销毁后】销毁结束才会执行<code>destoryed</code>，组件内的啥啥啥都不可用了</p><ul><li>此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在</li></ul></li></ol><h2 id="NextTick"><a href="#NextTick" class="headerlink" title="NextTick"></a>NextTick</h2><ul><li>nextTick 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。</li><li>在 created 和 mounted 阶段，如果需要操作渲染后的试图，也要使用 nextTick 方法。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//改变数据</span>vm.message = <span class="hljs-string">&#x27;changed&#x27;</span><span class="hljs-comment">//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新</span><span class="hljs-built_in">console</span>.log(vm.$el.textContent) <span class="hljs-comment">// 并不会得到&#x27;changed&#x27;</span><span class="hljs-comment">//这样可以，nextTick里面的代码会在DOM更新后执行</span>Vue.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(vm.$el.textContent) <span class="hljs-comment">//可以得到&#x27;changed&#x27;</span>&#125;)</code></pre></div><ul><li>created()中进行的DOM操作一定要放在Vue.nextTick()的回调函数中</li><li>更改数据后当你想立即使用js操作新的视图的时候需要使用它</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue响应式原理</title>
    <link href="/2019/05/11/vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <url>/2019/05/11/vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer()"></a>Observer()</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 数据劫持的实现</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observe</span>(<span class="hljs-params">obj</span>) </span>&#123;  <span class="hljs-keyword">if</span> (!obj || <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span>  <span class="hljs-built_in">Object</span>.keys(obj).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;    defineReactive(obj, key, obj[key])  &#125;)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">obj, key, val</span>) </span>&#123;  observe(val) <span class="hljs-comment">//      &lt;---------------------------递归遍历所有属性</span>  <span class="hljs-keyword">let</span> dep = <span class="hljs-keyword">new</span> Dep()  <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;    enumerable: <span class="hljs-literal">true</span>,    configurable: <span class="hljs-literal">true</span>,    get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;触发getter&#x27;</span>)      <span class="hljs-keyword">if</span>(Dep.target) &#123;        dep.addSub(Dep.target) <span class="hljs-comment">// &lt;------------往订阅队列里添加该订阅</span>      &#125;      <span class="hljs-keyword">return</span> val    &#125;,    set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newVal</span>) </span>&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;触发setter&#x27;</span>)        val = newVal        dep.notify()  <span class="hljs-comment">// &lt;----------------通知订阅者，触发其updata视图</span>    &#125;  &#125;)&#125;</code></pre></div><h2 id="订阅器Dep-收集依赖关系"><a href="#订阅器Dep-收集依赖关系" class="headerlink" title="订阅器Dep 收集依赖关系"></a>订阅器Dep 收集依赖关系</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 给模版添加订阅</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dep</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-built_in">this</span>.subs = []  <span class="hljs-comment">// 订阅队列</span>  &#125;  <span class="hljs-function"><span class="hljs-title">addSub</span>(<span class="hljs-params">sub</span>)</span> &#123;    <span class="hljs-built_in">this</span>.subs.push(sub)  &#125;  <span class="hljs-function"><span class="hljs-title">notify</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-built_in">this</span>.subs.forEach(<span class="hljs-function"><span class="hljs-params">sub</span> =&gt;</span> &#123;      <span class="hljs-comment">// 更新数据</span>      sub.update()    &#125;)  &#125;&#125;Dep.target = <span class="hljs-literal">null</span>;  <span class="hljs-comment">//  &lt;------------</span><span class="hljs-comment">// Dep.target每次指定订阅者之后都清空</span></code></pre></div><h2 id="Watcher观察者"><a href="#Watcher观察者" class="headerlink" title="Watcher观察者"></a>Watcher观察者</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watcher</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">obj, key, cb</span>)</span> &#123;    Dep.target = <span class="hljs-built_in">this</span>  <span class="hljs-comment">// &lt;-------此处触发getter</span>    <span class="hljs-built_in">this</span>.cb = cb    <span class="hljs-built_in">this</span>.obj = obj    <span class="hljs-built_in">this</span>.key = key    <span class="hljs-built_in">this</span>.value = obj[key]    Dep.target = <span class="hljs-literal">null</span>  &#125;  <span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-built_in">this</span>.value = <span class="hljs-built_in">this</span>.obj[<span class="hljs-built_in">this</span>.key]    <span class="hljs-comment">// 更新DOM</span>    <span class="hljs-built_in">this</span>.cb(<span class="hljs-built_in">this</span>.value)  &#125;&#125;</code></pre></div><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li><code>vue</code>实例化，<code>data</code>被代理到<code>viewmodel</code></li><li><code>data</code>被<code>Observer</code>绑定<code>getter/setter</code></li><li>组件渲染过程中，实例触摸到的<code>data</code>会触发其<code>getter</code>,<code>dep</code>将该依赖收集到对应组件的<code>watcher</code>(订阅了这个数据)</li><li>数据改变时触发相应的<code>setter</code>,<code>dep</code>通知他的观察者<code>watcher</code></li></ol><h1 id="VUE整个实现流程"><a href="#VUE整个实现流程" class="headerlink" title="VUE整个实现流程"></a>VUE整个实现流程</h1><ol><li><p>编译模版<code>template</code>成<code>render</code>函数，执行<code>render</code>函数得到虚拟节点树（同时为不同类型的节点标记</p></li><li><p>将data代理到<code>viewmodel</code>上，并且绑定<code>getter/setter</code>(Object.defineProperty)</p></li><li><p>组件初次渲染视图，<code>compile</code>渲染html触摸到的<code>data</code>会触发<code>getter</code>收集依赖到该组件的<code>watcher</code></p></li><li><p><code>data</code>数据改变时，触发<code>setter</code>,<code>dep</code>通知其<code>watcher</code>更新数据，<code>cb</code>将会对比新旧数据，发现数据改变了则再更新视图，这里用到了<code>diff</code>算法</p></li></ol><h2 id="with函数"><a href="#with函数" class="headerlink" title="with函数"></a>with函数</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;  name:<span class="hljs-string">&#x27;haungfeihong&#x27;</span>,  age:<span class="hljs-string">&#x27;18&#x27;</span>,  beat:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    alert(<span class="hljs-string">&#x27;佛山无影脚&#x27;</span>)  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-function"><span class="hljs-title">with</span>(<span class="hljs-params">obj</span>)</span>&#123;    alert(name)    alert(age)    beat()  &#125;&#125;fn1( )</code></pre></div><h2 id="render函数"><a href="#render函数" class="headerlink" title="render函数"></a>render函数</h2><ul><li><p>类似snabbdom的h函数</p></li><li><p>返回vnode虚拟节点</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">with</span>(<span class="hljs-params"><span class="hljs-built_in">this</span></span>)</span>&#123; <span class="hljs-keyword">return</span> _c(<span class="hljs-string">&#x27;div&#x27;</span>,&#123;   attrs: &#123;      <span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-string">&quot;app&quot;</span>   &#125; &#125;, [_c(<span class="hljs-string">&#x27;div&#x27;</span>,[_c(<span class="hljs-string">&#x27;input&#x27;</span>,&#123;   directives: [&#123;      name:<span class="hljs-string">&quot;model&quot;</span>,     rewName:<span class="hljs-string">&quot;v-model&quot;</span>,      value:(title),     expression:<span class="hljs-string">&quot;title&quot;</span>   &#125;],   domProps:&#123;    <span class="hljs-string">&quot;value&quot;</span>:(title)   &#125;,    on:&#123;     <span class="hljs-string">&quot;input&quot;</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$event</span>)</span>&#123;        <span class="hljs-keyword">if</span>($sevent.target.composing) <span class="hljs-keyword">return</span>        ...        ...        ...     &#125;    &#125;  &#125;)])  ]  )&#125;</code></pre></div></li></ul><h2 id="patch函数"><a href="#patch函数" class="headerlink" title="patch函数"></a>patch函数</h2><ul><li><p>可以把vmode渲染到文档中</p></li><li><p>同时也有新旧vnode对比的功能</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js题</title>
    <link href="/2019/05/05/js%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2019/05/05/js%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ul><li>向 setTimeout 传参</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func1</span>(<span class="hljs-params">name</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    alert(name + <span class="hljs-string">&quot;最帅&quot;</span>);  &#125;;&#125;<span class="hljs-keyword">var</span> n1 = func1(<span class="hljs-string">&quot;刘德华&quot;</span>);<span class="hljs-built_in">setTimeout</span>(n1, <span class="hljs-number">1000</span>);<span class="hljs-comment">//使用setTimeout第三个参数</span><span class="hljs-built_in">setTimeout</span>(  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123;    alert(name);  &#125;,  <span class="hljs-number">2000</span>,  <span class="hljs-string">&quot;周杰伦&quot;</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(i);  &#125;, i * <span class="hljs-number">1000</span>);&#125; <span class="hljs-comment">// 每一秒钟输出一个6</span><span class="hljs-comment">// 6 6 6 6 6</span><span class="hljs-comment">//</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(i);  &#125;, i * <span class="hljs-number">1000</span>);&#125; <span class="hljs-comment">// let创建块级作用域</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;  <span class="hljs-built_in">setTimeout</span>(    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">j</span>) </span>&#123;      <span class="hljs-built_in">console</span>.log(j);    &#125;,    i * <span class="hljs-number">1000</span>,    i  );&#125; <span class="hljs-comment">//使用setTimeout第三个参数</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;  (<span class="hljs-function">(<span class="hljs-params">j</span>) =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(j);    &#125;, <span class="hljs-number">1000</span> * j);  &#125;)(i);&#125;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;setTimeout&quot;</span>);&#125;);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promishe&quot;</span>);&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then&quot;</span>);&#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;console&quot;</span>);<span class="hljs-comment">//执行结果</span><span class="hljs-comment">//promise</span><span class="hljs-comment">//console</span><span class="hljs-comment">//then</span><span class="hljs-comment">//setTimeout</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span>);&#125;);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span>);  resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3&quot;</span>);&#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;4&quot;</span>);<span class="hljs-comment">//2</span><span class="hljs-comment">//4</span><span class="hljs-comment">//3</span><span class="hljs-comment">//1</span><span class="hljs-comment">//then是Promise的微任务,new Promise</span></code></pre></div><ul><li>instance of</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">instance_of</span>(<span class="hljs-params">l, r</span>) </span>&#123;  <span class="hljs-keyword">let</span> r = r.prototype;  <span class="hljs-keyword">let</span> l = <span class="hljs-built_in">Object</span>.getPrototypeOf(l);  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;    <span class="hljs-keyword">if</span> (l === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (o === l) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    l = <span class="hljs-built_in">Object</span>.getPrototypeOf(l); <span class="hljs-comment">// 一直到有结果return</span>  &#125;&#125;</code></pre></div><ul><li>手写 new<br>new 操作:<ul><li>创建一个空对象</li><li>将空对象连接上构造函数的原型</li><li>将 this 指向新对象，执行构造函数</li><li>如果该函数没有返回对象，则返回 this</li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_new</span>(<span class="hljs-params">func, ...args</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> func !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;first argument must be a function&quot;</span>);  &#125;  <span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.create(func.prototype);  <span class="hljs-comment">//Object.create(proto)等效于</span>  <span class="hljs-comment">//let O = function()&#123;&#125;</span>  <span class="hljs-comment">//O.prototype = proto</span>  <span class="hljs-comment">//return new O()</span>  <span class="hljs-keyword">const</span> res = func.apply(obj, args);  <span class="hljs-keyword">if</span> (res !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&quot;function&quot;</span> || <span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&quot;object&quot;</span>)) &#123;    <span class="hljs-keyword">return</span> res;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> obj;  &#125;&#125;<span class="hljs-comment">//or</span><span class="hljs-keyword">const</span> isComplexType = <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span>  (<span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;function&quot;</span>) &amp;&amp; obj !== <span class="hljs-literal">null</span>;<span class="hljs-keyword">const</span> _new = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">func, ...args</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> func !== <span class="hljs-string">&quot;function&quot;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;err&quot;</span>;  <span class="hljs-keyword">const</span> instance = <span class="hljs-built_in">Object</span>.create(func.prototype);  <span class="hljs-keyword">const</span> res = func.apply(instance, args);  <span class="hljs-keyword">return</span> isComplexType(res) ? res : instance;&#125;;</code></pre></div><ul><li>手写防抖/节流</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 防抖</span><span class="hljs-comment">// 多次触发最后一次执行</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func,wait,immediate = <span class="hljs-literal">true</span>,...args1</span>)</span>&#123;  <span class="hljs-comment">// 有立即执行选项</span>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span> ｜｜ <span class="hljs-keyword">typeof</span> delay !== <span class="hljs-string">&#x27;number&#x27;</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span> (<span class="hljs-string">&#x27;bad args&#x27;</span>)  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>  <span class="hljs-keyword">const</span> _debounce = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args2</span>)</span>&#123;    <span class="hljs-keyword">if</span>(timer)&#123;      <span class="hljs-built_in">clearTimeout</span>(timer)      timer = <span class="hljs-literal">null</span>    &#125;    <span class="hljs-keyword">if</span>(immediate &amp;&amp; !timer)&#123;      fn.apply(<span class="hljs-built_in">this</span>,[...args1,...args2])      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-literal">null</span>,delay)    &#125;<span class="hljs-keyword">else</span>&#123;      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;        fn.apply(<span class="hljs-built_in">this</span>,args)        <span class="hljs-built_in">clearTimeout</span>(timeout)        timer = <span class="hljs-literal">null</span>      &#125;,delay)    &#125;  &#125;  _debounce.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">clearTimeout</span>(timer)    timer = <span class="hljs-literal">null</span>  &#125;  <span class="hljs-keyword">return</span> _debounce&#125;<span class="hljs-comment">// 节流</span><span class="hljs-comment">// 连续触发限制定时间隔执行</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">func, wait, tail,...args1</span>) </span>&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span> ｜｜ <span class="hljs-keyword">typeof</span> delay !== <span class="hljs-string">&#x27;number&#x27;</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span> (<span class="hljs-string">&#x27;bad args&#x27;</span>)  <span class="hljs-comment">// tail = true wait结束后执行</span>  <span class="hljs-comment">// tail = false 满足条件立即执行</span>  <span class="hljs-keyword">let</span> timeout,pre = <span class="hljs-number">0</span>  <span class="hljs-keyword">const</span> _throttle = <span class="hljs-function">(<span class="hljs-params">...args2</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(tail)&#123;      <span class="hljs-keyword">if</span>(timeout) <span class="hljs-keyword">return</span>      timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;        func.apply(<span class="hljs-built_in">this</span>,[...args1,...args2])        <span class="hljs-built_in">clearTimeout</span>(timeout)        timeout = <span class="hljs-literal">null</span>      &#125;,wait)    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-keyword">let</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()      <span class="hljs-keyword">if</span>(now-pre&gt;wait)&#123;        func.apply(<span class="hljs-built_in">this</span>,[...args1,...args2])        pre = now      &#125;    &#125;  &#125;  _throttle.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">clearTimeout</span>(timeout)    timeout = <span class="hljs-literal">null</span>  &#125;  <span class="hljs-keyword">return</span> _throttle&#125;<span class="hljs-keyword">const</span> f1 = throttle(<span class="hljs-function">()=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>),<span class="hljs-number">3000</span>,<span class="hljs-literal">false</span>)<span class="hljs-built_in">setInterval</span>(f1, <span class="hljs-number">1000</span>);</code></pre></div><ul><li>修改数组</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">splice(index,howmany,item1,.....,itemX)<span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>]<span class="hljs-comment">// 必须传入一个参数，即splice(index)</span><span class="hljs-comment">// howmany不传则从该位置到结尾删除所有元素</span><span class="hljs-comment">// 第三个参数是要添加进的新元素</span><span class="hljs-comment">// 返回值是删除的元素组成的新数组</span><span class="hljs-built_in">console</span>.log(fruits.splice(<span class="hljs-number">0</span>))<span class="hljs-comment">//[&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]</span><span class="hljs-built_in">console</span>.log(fruits)<span class="hljs-comment">//[]</span><span class="hljs-built_in">console</span>.log(fruits.splice(<span class="hljs-number">1</span>))<span class="hljs-comment">//[&quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]</span><span class="hljs-built_in">console</span>.log(fruits)<span class="hljs-comment">//[&quot;Banana&quot;]</span><span class="hljs-built_in">console</span>.log(fruits.splice(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<span class="hljs-comment">//[&quot;Orange&quot;, &quot;Apple&quot;]</span><span class="hljs-comment">///--&gt;</span><span class="hljs-built_in">console</span>.log(fruits.splice(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;xiba&#x27;</span>,<span class="hljs-string">&#x27;qinjia&#x27;</span>))<span class="hljs-comment">//[&quot;Orange&quot;, &quot;Apple&quot;]</span><span class="hljs-built_in">console</span>.log(fruits)<span class="hljs-comment">//[&quot;Banana&quot;, &quot;xiba&quot;, &quot;qinjia&quot;, &quot;Mango&quot;]</span>sort()<span class="hljs-comment">// 数组排序，可传入排序顺序（函数）</span><span class="hljs-keyword">var</span> nums = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">53</span>,<span class="hljs-number">46</span>,<span class="hljs-number">73</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">1</span>]<span class="hljs-built_in">console</span>.log(fruits.sort())<span class="hljs-comment">//[&quot;Apple&quot;, &quot;Banana&quot;, &quot;Mango&quot;, &quot;Orange&quot;]</span><span class="hljs-built_in">console</span>.log(nums.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;  <span class="hljs-keyword">return</span> b-a&#125;))<span class="hljs-comment">//[73, 53, 46, 22, 11, 9, 3, 2, 1]</span>pop()<span class="hljs-comment">//删除最后一个元素</span><span class="hljs-built_in">console</span>.log(nums.pop())<span class="hljs-comment">// 1</span><span class="hljs-built_in">console</span>.log(fruits.pop())<span class="hljs-comment">// Mango</span>shift()<span class="hljs-comment">//删除第一个元素并返回</span>push(item...)<span class="hljs-comment">// 向数组末尾添加元素</span><span class="hljs-comment">// 返回新数组的长度</span><span class="hljs-built_in">console</span>.log(nums.push(<span class="hljs-number">666</span>,<span class="hljs-number">999</span>))<span class="hljs-comment">//11</span>unshift(item...)<span class="hljs-comment">// 向数组的开头添加元素</span><span class="hljs-comment">// 返回新数组的长度</span><span class="hljs-built_in">console</span>.log(nums.unshift(<span class="hljs-number">666</span>,<span class="hljs-number">999</span>))<span class="hljs-comment">//11</span>reverse()<span class="hljs-comment">// 颠倒顺序</span><span class="hljs-comment">// 返回新数组</span>copyWithin()<span class="hljs-comment">// 复制成员到指定位置</span>nums.copyWithin(<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)<span class="hljs-built_in">console</span>.log(nums)<span class="hljs-comment">// 将index3的位置开始两个元素复制为index0开始的两个元素</span><span class="hljs-comment">// [2, 3, 53, 2, 3, 9, 11, 22, 1]</span>fill(value,start,end)<span class="hljs-comment">// 填充的元素，填充开始位置，填充结束位置（不填充该元素）</span><span class="hljs-comment">// 填充数组</span>nums.fill(<span class="hljs-number">666</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)<span class="hljs-built_in">console</span>.log(nums)<span class="hljs-comment">// [666, 666, 53, 46, 73, 9, 11, 22, 1]</span></code></pre></div><ul><li>操作数组</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> nums = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">53</span>, <span class="hljs-number">46</span>, <span class="hljs-number">73</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>];<span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Mango&quot;</span>];slice(begin, end);<span class="hljs-comment">// 潜拷贝,传入索引值</span><span class="hljs-comment">// begin开始包括自己，索引end自身是不拷贝的</span><span class="hljs-built_in">console</span>.log(nums.slice(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>));<span class="hljs-comment">//[3, 53, 46, 73]</span>join(<span class="hljs-string">&quot;str&quot;</span>);<span class="hljs-comment">// 指定分隔符连成字符串</span><span class="hljs-built_in">console</span>.log(fruits.join());<span class="hljs-comment">//Banana,Orange,Apple,Mango 默认为逗号</span><span class="hljs-built_in">console</span>.log(fruits.join(<span class="hljs-string">&quot;-&quot;</span>));<span class="hljs-comment">//Banana-Orange-Apple-Mango</span>concat();<span class="hljs-comment">//合并数组</span><span class="hljs-built_in">console</span>.log(nums.concat(fruits));<span class="hljs-comment">// [2, 3, 53, 46, 73, 9, 11, 22, 1, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]</span>indexOf() / lastIndexOf();<span class="hljs-comment">// 一个从前往后找，一个倒着找(索引可是只有正的</span><span class="hljs-comment">// 传入serachElement和fromIndex（查找起始位置</span><span class="hljs-built_in">console</span>.log(nums.indexOf(<span class="hljs-number">9</span>)); <span class="hljs-comment">// 5</span><span class="hljs-built_in">console</span>.log(nums.indexOf(<span class="hljs-number">9</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// 5</span><span class="hljs-built_in">console</span>.log(nums.indexOf(<span class="hljs-number">9</span>, <span class="hljs-number">6</span>)); <span class="hljs-comment">// 9</span><span class="hljs-built_in">console</span>.log(nums.lastIndexOf(<span class="hljs-number">9</span>, <span class="hljs-number">8</span>)); <span class="hljs-comment">// 5</span>includes();<span class="hljs-comment">// 是否包含某元素</span><span class="hljs-comment">// 返回布尔值</span><span class="hljs-built_in">console</span>.log(nums.includes(<span class="hljs-number">2</span>)); <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(nums.includes(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">// false</span></code></pre></div><ul><li>计算数组中元素出现的次数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>];<span class="hljs-comment">//reduce</span><span class="hljs-keyword">let</span> countArr = arr.reduce(<span class="hljs-function">(<span class="hljs-params">obj, i</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> obj) &#123;    obj[i]++;  &#125; <span class="hljs-keyword">else</span> &#123;    obj[i] = <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">return</span> obj;&#125;, &#123;&#125;);<span class="hljs-comment">// &#123; &#x27;1&#x27;: 2, &#x27;2&#x27;: 2, &#x27;3&#x27;: 2, &#x27;4&#x27;: 4 &#125;</span><span class="hljs-comment">// 循环</span><span class="hljs-keyword">let</span> obj = &#123;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> arr) &#123;  <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> obj) &#123;    obj[i]++;  &#125; <span class="hljs-keyword">else</span> &#123;    obj[i] = <span class="hljs-number">1</span>;  &#125;&#125;</code></pre></div><ul><li>call/bind/apply 区别</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = &#123;  sing: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg1, arg2</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;笨小孩&quot;</span> + <span class="hljs-built_in">this</span>.name);    <span class="hljs-built_in">console</span>.log(arg1 + arg2);  &#125;,&#125;;<span class="hljs-keyword">const</span> b = &#123;  name: <span class="hljs-string">&quot;刘德华&quot;</span>,&#125;;<span class="hljs-keyword">const</span> c = &#123;  name: <span class="hljs-string">&quot;张学友&quot;</span>,&#125;;a.sing();<span class="hljs-comment">//笨小孩undefined</span><span class="hljs-comment">// NaN</span>a.sing.call(b, <span class="hljs-number">666</span>, <span class="hljs-number">888</span>);<span class="hljs-comment">// call后一个一个传args</span><span class="hljs-comment">// 笨小孩刘德华</span><span class="hljs-comment">// 1554</span>a.sing.apply(c, [<span class="hljs-number">666</span>, <span class="hljs-number">888</span>]);<span class="hljs-comment">// apply第二个参数[]</span><span class="hljs-comment">// 笨小孩刘德华</span><span class="hljs-comment">// 1554</span><span class="hljs-keyword">let</span> d = a.sing.bind(b, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">// bind返回函数不执行，传参数方式和call一样</span>d();<span class="hljs-comment">//call是apply的语法糖</span></code></pre></div><ul><li>限制并发</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 线程池</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncPool</span>(<span class="hljs-params">limit, arr, func</span>) </span>&#123;  <span class="hljs-keyword">let</span> i = o;  <span class="hljs-keyword">const</span> ret = []; <span class="hljs-comment">// 所有任务</span>  <span class="hljs-keyword">const</span> executing = []; <span class="hljs-comment">// 运行中</span>  <span class="hljs-keyword">const</span> enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">if</span> (array.length === <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve();    &#125;    <span class="hljs-keyword">const</span> item = arr[i++];    <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> func(item));    ret.push(p);    <span class="hljs-comment">//</span>    executing.push(e);    <span class="hljs-comment">//</span>    <span class="hljs-keyword">const</span> e = p.then(<span class="hljs-function">() =&gt;</span> executing.splice(executing.indexOf(e), <span class="hljs-number">1</span>)); <span class="hljs-comment">// 自己resolve后从并发池中删除</span>    <span class="hljs-keyword">let</span> r = <span class="hljs-built_in">Promise</span>.resolve();    <span class="hljs-keyword">if</span> (executing.length &gt;= limit) &#123;      r = <span class="hljs-built_in">Promise</span>.race(executing);      <span class="hljs-comment">//使用race，并发池中只要有一个promise返回resolve，则继续调用enqueue方法添加新的进去</span>    &#125;    <span class="hljs-keyword">return</span> r.then(<span class="hljs-function">() =&gt;</span> enqueue());  &#125;;  <span class="hljs-keyword">return</span> enqueue().then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">Promise</span>.all(ret));&#125;</code></pre></div><ul><li>实现重试功能</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">retry</span>(<span class="hljs-params">fn, interval, limit</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attempt</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> fn());      p.then(resolve).catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (limit-- &lt;= <span class="hljs-number">1</span>) &#123;          reject(<span class="hljs-string">&quot;run out of limit&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;            attempt();            <span class="hljs-built_in">clearTimeout</span>(timer);          &#125;, interval);        &#125;      &#125;);    &#125;    attempt();  &#125;);&#125;</code></pre></div><ul><li>浅拷贝</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//</span><span class="hljs-built_in">Object</span>.assign();<span class="hljs-comment">//展开运算符</span><span class="hljs-keyword">let</span> a = &#123;  age: <span class="hljs-number">1</span>,&#125;;<span class="hljs-keyword">let</span> b = &#123; ...a &#125;;a.age = <span class="hljs-number">2</span>;<span class="hljs-built_in">console</span>.log(b.age); <span class="hljs-comment">// 1</span>**只会对对象的表层属性进行拷贝，遇到复杂类型时只是拷贝了地址**</code></pre></div><ul><li>深拷贝</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(source))<span class="hljs-comment">//先JSON.stringify转成字符串，再JSON.parse把字符串转换成新的对象</span>**遇到<span class="hljs-built_in">Symbol</span>和函数则报错**</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 实现</span><span class="hljs-keyword">const</span> isObject = <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> obj !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;object&quot;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">source, map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) </span>&#123;  <span class="hljs-comment">//WeakMap 避免循环引用爆栈</span>  <span class="hljs-comment">// obj.o1 = obj  // boom</span>  <span class="hljs-keyword">if</span> (!isObject(source)) <span class="hljs-keyword">return</span> source;  <span class="hljs-keyword">if</span> (map.has(source)) <span class="hljs-keyword">return</span> map.get(source);  <span class="hljs-keyword">const</span> _constructor = source.constructor;  <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(RegExp|Date)&amp;/i</span>.text(_constructor.name))    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> _constructor(source);  <span class="hljs-comment">// 正则和日期</span>  <span class="hljs-keyword">const</span> newObj =    _constructor === <span class="hljs-built_in">Array</span> ? source.concat() : <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, source);  map.set(source, newObj);  <span class="hljs-built_in">Reflect</span>.ownKeys(source).forEach(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;    <span class="hljs-comment">// Reflect.ownKeys 方法返回一个由目标对象自身的属性键组成的数组。它的返回值等同于Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))。</span>    newObj[key] = deepClone(source[key], map);  &#125;);  <span class="hljs-keyword">return</span> newObj;&#125;<span class="hljs-comment">//////////test////////////////</span><span class="hljs-keyword">const</span> obj0 = &#123;  name: <span class="hljs-string">&quot;大sao&quot;</span>,  eat: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;吃的真多&quot;</span>);  &#125;,&#125;;<span class="hljs-keyword">let</span> obj1 = deepClone(obj0);<span class="hljs-keyword">let</span> obj2 = <span class="hljs-built_in">Object</span>.assign(obj0);obj0.name = <span class="hljs-string">&quot;666&quot;</span>;<span class="hljs-comment">//  潜拷贝</span><span class="hljs-built_in">console</span>.log(obj2); <span class="hljs-comment">// &#123;name: &quot;666&quot;, eat: ƒ, children: &#123;…&#125;&#125;</span><span class="hljs-comment">//  深拷贝</span><span class="hljs-built_in">console</span>.log(obj1); <span class="hljs-comment">// &#123;name: &quot;大sao&quot;, eat: ƒ, children: &#123;…&#125;&#125;</span></code></pre></div><ul><li>for…in /for…of</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.method = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.length);&#125;;<span class="hljs-keyword">var</span> myArray = [<span class="hljs-string">&quot;1&quot;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;mmm&quot;</span> &#125;, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];myArray.name = <span class="hljs-string">&quot;数组&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> value <span class="hljs-keyword">of</span> myArray) &#123;  <span class="hljs-built_in">console</span>.log(value);&#125;<span class="hljs-comment">//1 &#123;name: &quot;mmm&quot;&#125; 3 4 5 6 7</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> index <span class="hljs-keyword">in</span> myArray) &#123;  <span class="hljs-built_in">console</span>.log(myArray[index]);&#125;<span class="hljs-comment">//1 2 3 4 5 6 7 数组 ƒ () &#123;</span><span class="hljs-comment">//  console.log(this.length);</span><span class="hljs-comment">//&#125;</span></code></pre></div><ul><li>阻止冒泡和默认事件</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopBubble</span>(<span class="hljs-params">e</span>) </span>&#123;  <span class="hljs-keyword">if</span> (e &amp;&amp; e.stopPropagation) &#123;    e.stopPropagation();  &#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">window</span>.event.cancelBubble = <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopDefault</span>(<span class="hljs-params">e</span>) </span>&#123;  <span class="hljs-keyword">if</span> (e &amp;&amp; e.preventDefault) e.preventDefault();  <span class="hljs-keyword">else</span> <span class="hljs-built_in">window</span>.event.returnValue = <span class="hljs-literal">false</span>;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre></div><ul><li>let/const/var</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// JavaScript 变量提升 var声明会提前（声明不是赋值）</span><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// undefined</span><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// 报错</span><span class="hljs-built_in">console</span>.log(c); <span class="hljs-comment">// 报错</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> c = <span class="hljs-number">3</span>;<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 1</span></code></pre></div><ul><li>手写 call/apply/bind</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype._call = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;must call a function&quot;</span>);  context = context || <span class="hljs-built_in">window</span>;  <span class="hljs-keyword">const</span> caller = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;caller&quot;</span>);  context[caller] = <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">let</span> result = context[caller](...args);  <span class="hljs-keyword">delete</span> context[caller];  <span class="hljs-keyword">return</span> result;&#125;;<span class="hljs-built_in">Function</span>.prototype._apply = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, args</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;must apply a function&quot;</span>);  context = context || <span class="hljs-built_in">window</span>;  <span class="hljs-keyword">const</span> caller = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;caller&quot;</span>);  context[caller] = <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">let</span> result = context[caller](...args);  <span class="hljs-keyword">delete</span> context[caller];  <span class="hljs-keyword">return</span> result;&#125;;<span class="hljs-comment">// 返回一个原函数的拷贝，并拥有指定的this值和初始参数。</span><span class="hljs-built_in">Function</span>.prototype._bind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args1</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;must bind a function&quot;</span>);  <span class="hljs-keyword">const</span> originFn = <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">const</span> notBFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;  <span class="hljs-keyword">const</span> boundFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args2</span>) </span>&#123;    <span class="hljs-keyword">return</span> originFn.apply(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> originFn ? <span class="hljs-built_in">this</span> : context, [      <span class="hljs-comment">// 如果绑定函数被new调用</span>      <span class="hljs-comment">// 则this指向new obj的this</span>      ...args1,      ...args2,    ]);  &#125;;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.prototype) &#123;    notBFn.prototype = <span class="hljs-built_in">this</span>.prototype;  &#125;  boundFn.prototype = <span class="hljs-keyword">new</span> notBFn();  <span class="hljs-comment">// boundFn.prototype = Object.create(this.prototype)</span>  <span class="hljs-comment">// 使用notBFn间接连接boundFn和originFn原型链</span>  <span class="hljs-keyword">return</span> boundFn;&#125;;</code></pre></div><ul><li>手动实现一个继承</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">///////最完美办法</span><span class="hljs-comment">// 1.call</span><span class="hljs-comment">// 2.Object.create</span><span class="hljs-comment">// 3.原型的构造器指向自己</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">this</span>.type = <span class="hljs-string">&quot;human&quot;</span>;  <span class="hljs-built_in">this</span>.eat = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我肚子饿了&quot;</span>);  &#125;;&#125;Person.prototype.live = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;吃饭睡觉打豆豆&quot;</span>);&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Avenger</span>(<span class="hljs-params">name</span>) </span>&#123;  Person.call(<span class="hljs-built_in">this</span>);  <span class="hljs-built_in">this</span>.name = name;&#125;Avenger.prototype = <span class="hljs-built_in">Object</span>.create(Person.prototype);Avenger.prototype.constructor = Avenger;<span class="hljs-keyword">let</span> hulk = <span class="hljs-keyword">new</span> Avenger(<span class="hljs-string">&quot;HULK&quot;</span>);hulk.live();<span class="hljs-comment">// 吃饭睡觉打豆豆</span>其他方法：<span class="hljs-comment">// - 借用构造函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Avenger</span>(<span class="hljs-params">name</span>)</span>&#123;  Person.call(<span class="hljs-built_in">this</span>,name)  <span class="hljs-built_in">this</span>.name = name&#125;<span class="hljs-comment">// 只能继承构造函数上属性</span><span class="hljs-comment">// 2. 原型继承</span>Avenger.prototype = <span class="hljs-keyword">new</span> Person()<span class="hljs-comment">// 子类实例共享原型中的引用类型数据</span><span class="hljs-comment">// 不能传参</span><span class="hljs-comment">// 3.组合继承 1+2</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Avenger</span>(<span class="hljs-params">name</span>)</span>&#123;  Person.call(<span class="hljs-built_in">this</span>,name)  <span class="hljs-built_in">this</span>.name = name&#125;Avenger.prototype = <span class="hljs-keyword">new</span> Person()<span class="hljs-comment">// 实例构造函数会指向父类的构造函数</span><span class="hljs-comment">// 父类构造函数执行多次</span><span class="hljs-comment">// 4. 原型式继承</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Avenger</span>(<span class="hljs-params">name</span>)</span>&#123;    Person.call(<span class="hljs-built_in">this</span>,name)    <span class="hljs-built_in">this</span>.name = name&#125;Avenger.prototype = Person.prototype<span class="hljs-comment">// 子类实例构造函数会指向父类的构造函数</span><span class="hljs-comment">// 分不清实例是谁构造的</span><span class="hljs-comment">// 5. 寄生继承</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Avenger</span>(<span class="hljs-params">name</span>)</span>&#123;    Person.call(<span class="hljs-built_in">this</span>,name)    <span class="hljs-built_in">this</span>.name = name&#125;Avenger.prototype = <span class="hljs-built_in">Object</span>.create(Person.prototype)<span class="hljs-comment">// Object.create() 创造的中间对象的原型对象就是传入的参数</span><span class="hljs-comment">// 此时中间对象的原型也就是父类的原型</span><span class="hljs-comment">// 中间对象通过类似在原型链上“加一段”的方式把父子类的构造器隔开</span><span class="hljs-comment">// 6. 寄生组合</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Avenger</span>(<span class="hljs-params">name</span>)</span>&#123;    Person.call(<span class="hljs-built_in">this</span>,name)    <span class="hljs-built_in">this</span>.name = name&#125;Avenger.prototype = <span class="hljs-built_in">Object</span>.create(Person.prototype)Avenger.prototype.constructor = Avenger<span class="hljs-comment">//   再把构造器指向自己，完成自己的链</span></code></pre></div><ul><li>手动实现一个迭代器</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createIterator</span>(<span class="hljs-params">array</span>) </span>&#123;  <span class="hljs-keyword">let</span> nextIndex = <span class="hljs-number">0</span>;  <span class="hljs-keyword">return</span> &#123;    next: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">return</span> nextIndex &lt; array.length        ? &#123; <span class="hljs-attr">value</span>: array[nextIndex++], <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;        : &#123; <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;;    &#125;,    [<span class="hljs-built_in">Symbol</span>.iterator]: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;    &#125;,  &#125;;&#125;<span class="hljs-keyword">var</span> i1 = createIterator([<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">21</span>, <span class="hljs-number">6</span>]);<span class="hljs-built_in">console</span>.log(i1.next()); <span class="hljs-comment">// &#123;value:4,done:false&#125;</span></code></pre></div><ul><li><p>for 循环实现遍历方法</p><ul><li><p>for 循环实现 forEach</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._forEach = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);  &#125;  thisArg = thisArg || <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasOwnProperty(i)) &#123;      callback.call(thisArg, <span class="hljs-built_in">this</span>[i], i, <span class="hljs-built_in">this</span>);    &#125;  &#125;&#125;;</code></pre></div></li><li><p>for 循环实现 map</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._map = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);  &#125;  <span class="hljs-keyword">const</span> result = [];  thisArg = thisArg || <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasOwnProperty(i)) &#123;      result[i] = callback.call(thisArg, <span class="hljs-built_in">this</span>[i], i, <span class="hljs-built_in">this</span>);    &#125;  &#125;  <span class="hljs-keyword">return</span> result;&#125;;</code></pre></div></li><li><p>for 循环实现 filter</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._filter_ = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);  &#125;  <span class="hljs-keyword">const</span> result = [];  thisArg = thisArg || <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasOwnProperty(i)) &#123;      <span class="hljs-keyword">if</span> (callback.call(thisArg, <span class="hljs-built_in">this</span>[i], i, <span class="hljs-built_in">this</span>)) &#123;        result.push(<span class="hljs-built_in">this</span>[i]);      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> result;&#125;;</code></pre></div></li><li><p>for 循环实现 some</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._some = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);  &#125;  thisArg = thisArg || <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasOwnProperty(i)) &#123;      <span class="hljs-keyword">if</span> (callback.call(thisArg, <span class="hljs-built_in">this</span>[i], i, <span class="hljs-built_in">this</span>)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;</code></pre></div></li><li><p>for 循环实现 every</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._every = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);  &#125;  thisArg = thisArg || <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasOwnProperty(i)) &#123;      <span class="hljs-keyword">if</span> (!callback.call(thisArg, <span class="hljs-built_in">this</span>[i], i, <span class="hljs-built_in">this</span>)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;</code></pre></div></li><li><p>for 循环实现 reduce</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._reduce = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, initialValue</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);  &#125;  <span class="hljs-keyword">let</span> res;  <span class="hljs-keyword">let</span> initialIndex = <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span> (!initialValue) &#123;    <span class="hljs-keyword">for</span> (; initialIndex &lt; <span class="hljs-built_in">this</span>.length; initialIndex++) &#123;      <span class="hljs-comment">// 未指定初始值则自行查找第一个非空下标</span>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasOwnProperty(initialIndex)) &#123;        res = <span class="hljs-built_in">this</span>[i];        <span class="hljs-keyword">break</span>;      &#125;    &#125;  &#125; <span class="hljs-keyword">else</span> &#123;    res = initialValue;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = initialIndex + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">this</span>.length; j++) &#123;    res = callback.call(<span class="hljs-literal">null</span>, res, <span class="hljs-built_in">this</span>[j], j, <span class="hljs-built_in">this</span>);  &#125;  <span class="hljs-keyword">return</span> res;&#125;;</code></pre></div></li></ul></li><li><p>reduce 实现遍历方法</p><ul><li>reduce 实现 forEach</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._forEach = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);  &#125;  <span class="hljs-built_in">this</span>.reduce(<span class="hljs-function">(<span class="hljs-params">pre, acc, index</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> [...pre, callback.call(thisArg, acc, index, <span class="hljs-built_in">this</span>)];  &#125;, []);&#125;;</code></pre></div><ul><li>reduce 实现 map</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//加上return</span></code></pre></div><ul><li>reduce 实现 filter</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._filter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback,thisArg</span>)</span>&#123;  ...  ...  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.reduce(<span class="hljs-function">(<span class="hljs-params">pre,acc</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> callback.call(thisArg,acc,index,<span class="hljs-built_in">this</span>)?[...pre,cur]:[...pre]  &#125;,[])&#125;</code></pre></div></li><li><p>实现 object.assign</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> isComplexType = <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span>  (<span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;function&quot;</span>) &amp;&amp; obj !== <span class="hljs-literal">null</span>;<span class="hljs-keyword">const</span> selfAssign = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, ...source</span>) </span>&#123;  <span class="hljs-keyword">if</span> (!target) <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;target err&quot;</span>;  <span class="hljs-keyword">return</span> source.reduce(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> acc;    <span class="hljs-keyword">if</span> (!isComplexType(acc)) acc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(acc);    <span class="hljs-built_in">Reflect</span>.ownKeys(cur).forEach(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;      acc[key] = cur[key];    &#125;);    <span class="hljs-keyword">return</span> acc;  &#125;, target);&#125;;</code></pre></div><ul><li>手动实现 typeof</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> selfTypeof = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;  <span class="hljs-keyword">const</span> ret = <span class="hljs-built_in">Object</span>.prototype.toString.call(obj);  <span class="hljs-keyword">return</span> ret.slice(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>).toLowercase();&#125;;</code></pre></div><ul><li>手动实现 instanceof</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> selfInstanceof = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">left, right</span>) </span>&#123;  <span class="hljs-keyword">let</span> _proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(left);  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;    <span class="hljs-keyword">if</span> (_proto === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (_proto === right.prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    _proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(_proto);  &#125;&#125;;</code></pre></div><ul><li><p>二维数组的所有排列组合</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">let</span> len = arr.length;  <span class="hljs-keyword">if</span> (len &gt;= <span class="hljs-number">2</span>) &#123;    <span class="hljs-keyword">let</span> len1 = arr[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">let</span> len2 = arr[<span class="hljs-number">1</span>].length;    <span class="hljs-keyword">let</span> lenBoth = len1 * len2;    <span class="hljs-keyword">let</span> items = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(lenBoth);    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len1; i++) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; len2; j++) &#123;        items[index] = [].concat(arr[<span class="hljs-number">0</span>][i]).concat(arr[<span class="hljs-number">1</span>][j]);        index++;      &#125;    &#125;    <span class="hljs-keyword">let</span> newArr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len - <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; len; i++) &#123;      newArr[i - <span class="hljs-number">1</span>] = arr[i];    &#125;    newArr[<span class="hljs-number">0</span>] = items;    <span class="hljs-keyword">return</span> exchange(newArr);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];  &#125;&#125;</code></pre></div></li><li><p>属性名表达式</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">10</span> &#125;;<span class="hljs-keyword">let</span> b = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">10</span> &#125;;<span class="hljs-keyword">let</span> obj = &#123;  a: <span class="hljs-number">10</span>,&#125;;obj[b] = <span class="hljs-number">20</span>;<span class="hljs-built_in">console</span>.log(obj[a]); <span class="hljs-comment">// 20</span><span class="hljs-comment">//obj.b和obj[b]的不同</span>obj[需要是已经声明的变量名]obj.则不受限制obj.c = <span class="hljs-number">20</span> ===&gt; obj:&#123;<span class="hljs-attr">c</span>:<span class="hljs-number">20</span>,<span class="hljs-attr">a</span>:<span class="hljs-number">10</span>&#125;obj[c] <span class="hljs-comment">//报错</span><span class="hljs-comment">//原题中obj[b]后打印得到</span>obj = &#123;  a:<span class="hljs-number">10</span>,  <span class="hljs-string">&#x27;[object:object]&#x27;</span> : <span class="hljs-number">20</span>  <span class="hljs-comment">//b = &#123; b: 10 &#125; ===&gt; &#x27;[object:object]&#x27;</span>&#125;后再访问obj[a]时也就是访问obj[<span class="hljs-string">&#x27;[object:object]&#x27;</span>] = <span class="hljs-number">20</span></code></pre></div><ul><li>this 的指向</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">20</span>,  say: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);  &#125;,&#125;;obj.say();<span class="hljs-comment">// 打印出10的方法</span><span class="hljs-comment">// 1</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">20</span>,  say: <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);  &#125;,&#125;;obj.say();<span class="hljs-comment">// 2</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">20</span>,  say: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);  &#125;,&#125;;<span class="hljs-keyword">let</span> say = obj.say;say();<span class="hljs-comment">// 3</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">20</span>,  say: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);  &#125;,&#125;;obj.say.call(<span class="hljs-built_in">this</span>);</code></pre></div><ul><li>js 执行顺序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// js执行顺序</span><span class="hljs-comment">// 1</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;script start&quot;</span>); <span class="hljs-comment">// 1</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;setTimeout&quot;</span>); <span class="hljs-comment">// 4</span>&#125;, <span class="hljs-number">0</span>);<span class="hljs-built_in">Promise</span>.resolve()  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise1&quot;</span>); <span class="hljs-comment">//2</span>  &#125;)  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise2&quot;</span>); <span class="hljs-comment">//3</span>  &#125;);<span class="hljs-comment">// 2</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//1</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span>); <span class="hljs-comment">// 5</span>  process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3&quot;</span>); <span class="hljs-comment">//7</span>  &#125;);  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;4&quot;</span>); <span class="hljs-comment">//6</span>    resolve();  &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;5&quot;</span>); <span class="hljs-comment">//8</span>  &#125;);&#125;);process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;6&quot;</span>); <span class="hljs-comment">//3</span>&#125;);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;7&quot;</span>); <span class="hljs-comment">//2</span>  resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;8&quot;</span>); <span class="hljs-comment">//4</span>&#125;);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;9&quot;</span>); <span class="hljs-comment">//9</span>  process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;10&quot;</span>); <span class="hljs-comment">//11</span>  &#125;);  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;11&quot;</span>); <span class="hljs-comment">//10</span>    resolve();  &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;12&quot;</span>);  &#125;); <span class="hljs-comment">//12</span>&#125;);<span class="hljs-comment">// 3</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>); <span class="hljs-comment">//1</span>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>); <span class="hljs-comment">//2</span>  &#125;);  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;异步3&quot;</span>); <span class="hljs-comment">//6</span>  &#125;);  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;同步3&quot;</span>); <span class="hljs-comment">//3</span>&#125;<span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>); <span class="hljs-comment">//5</span>&#125;);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>); <span class="hljs-comment">//7</span>&#125;);async1();<span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>); <span class="hljs-comment">//4</span></code></pre></div><ul><li>设置最大请求次数的请求函数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myRequest</span>(<span class="hljs-params">url,body,successCallback,errorCallback,maxCount</span>)</span>&#123;  <span class="hljs-keyword">return</span> fetch(url,body).then(<span class="hljs-function"><span class="hljs-params">response</span>=&gt;</span>successCallback(response)).catch(<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;    <span class="hljs-keyword">if</span>(maxCount&lt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> errorCallback(<span class="hljs-string">&#x27;请求超时&#x27;</span>)    <span class="hljs-keyword">return</span> myRequest(url,body,successCallback,errorCallback,--maxCount)  &#125;)&#125;myRequest(<span class="hljs-string">&#x27;http://test/aaa&#x27;</span>,&#123;           method: <span class="hljs-string">&#x27;GET&#x27;</span>,           headers: myHeaders,           mode: <span class="hljs-string">&#x27;cors&#x27;</span>,           cache: <span class="hljs-string">&#x27;default&#x27;</span> &#125;           ,successCallback,errorCallback,<span class="hljs-number">10</span>)&lt;!-- <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myRequest2</span>(<span class="hljs-params">params,successCallback,errorCallback,maxCount</span>)</span>&#123;  <span class="hljs-keyword">return</span> axios(params)  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> successCallback(response))&#125;  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(maxCount&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> errorCallback(<span class="hljs-string">&#x27;请求超时&#x27;</span>)    <span class="hljs-keyword">return</span> myRequest2(params,successCallback,errorCallback,--maxCount)  &#125;) --&gt;</code></pre></div><ul><li>js 执行优先级</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>&#123;  getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);  &#125;;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;&#125;Foo.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);&#125;;Foo.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);&#125;;<span class="hljs-keyword">var</span> getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>);&#125;Foo.getName();getName();Foo().getName();<span class="hljs-comment">// function changeThis()&#123;</span><span class="hljs-comment">//   return this</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// changeThis().fn666 = ()=&gt;&#123;</span><span class="hljs-comment">//   console.log(666);</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// global.fn666()</span>getName();<span class="hljs-keyword">new</span> Foo.getName();<span class="hljs-keyword">new</span> Foo().getName();<span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> Foo().getName();</code></pre></div><ul><li>实现一个 setTimeout</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_setTimeout</span>(<span class="hljs-params">cb, timeout, ...args</span>) </span>&#123;  <span class="hljs-keyword">const</span> start = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();  <span class="hljs-keyword">let</span> timer, now;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span>(<span class="hljs-params"></span>) </span>&#123;    timer = <span class="hljs-built_in">window</span>.requestAnimationFrame(loop);    now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();    <span class="hljs-keyword">if</span> (now - start &gt;= timeout) &#123;      cb.apply(<span class="hljs-built_in">this</span>, args);      <span class="hljs-built_in">window</span>.cancelAnimationFrame(timer);    &#125;  &#125;  <span class="hljs-built_in">window</span>.requestAnimationFrame(loop);&#125;</code></pre></div><ul><li>使用 setTimeout 模拟 setInterval</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// setInterval 的问题</span><span class="hljs-comment">// 定时往事件队列中添加回调函数，如果主线程运行时间过长到大量回调超时，则有可能同时执行大量异步回调，违背使用意图</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_setInterval</span>(<span class="hljs-params">fn,timeout,...args</span>)</span>&#123;  <span class="hljs-keyword">const</span> controller = &#123;    stop = <span class="hljs-literal">false</span>    <span class="hljs-comment">// 控制器</span>  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">interval</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">if</span>(!<span class="hljs-title">constructor</span>.<span class="hljs-title">stop</span>)&#123;      fn.apply(<span class="hljs-built_in">this</span>,args)      <span class="hljs-built_in">setTimeout</span>(interval)    &#125;  &#125;  <span class="hljs-built_in">setTimeout</span>(interval,timeout)  <span class="hljs-keyword">return</span> controller&#125;</code></pre></div><ul><li>模版字符串</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\&#123;\&#123;(w+)\&#125;\&#125;/g</span>;<span class="hljs-keyword">const</span> template = <span class="hljs-string">&quot;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&quot;</span>;<span class="hljs-keyword">const</span> data = &#123;  name: <span class="hljs-string">&quot;森下上士&quot;</span>,  age: <span class="hljs-number">18</span>,&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">template, data</span>) </span>&#123;  <span class="hljs-keyword">if</span> (reg.test(template)) &#123;    <span class="hljs-keyword">const</span> tem = template.match(reg);    tem.forEach(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;      <span class="hljs-keyword">const</span> p = key.slice(<span class="hljs-number">2</span>, -<span class="hljs-number">2</span>);      <span class="hljs-comment">// &#123;&#123;xxx&#125;&#125; ==&gt; xxx</span>      template = template.replace(key, data[p]);    &#125;);  &#125;  <span class="hljs-keyword">return</span> template;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hybrid</title>
    <link href="/2019/05/03/hybrid/"/>
    <url>/2019/05/03/hybrid/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是hybrid"><a href="#什么是hybrid" class="headerlink" title="什么是hybrid"></a>什么是hybrid</h2><ul><li>前端客户端混合开发</li><li>某些环节可能涉及server端</li><li>使用hybrid去做app里变化频繁的页面</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>快速迭代更新（热更新？？）无需审核 </li><li>体验和nativeapp基本类似</li><li>ios/android代码共用多</li></ul><h2 id="hybrid的实现"><a href="#hybrid的实现" class="headerlink" title="hybrid的实现"></a>hybrid的实现</h2><ol><li>静态文件给客户端</li><li>客户端存储在app中</li><li>客户端在webview中使用file协议加载页面</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>开发成本高，联调测试debug都麻烦</li><li>运维成本高（打包，版本，验证）</li></ol><h2 id="hybrid适合产品型，h5适合运营型"><a href="#hybrid适合产品型，h5适合运营型" class="headerlink" title="hybrid适合产品型，h5适合运营型"></a>hybrid适合产品型，h5适合运营型</h2><h2 id="前端JS和客户端通讯"><a href="#前端JS和客户端通讯" class="headerlink" title="前端JS和客户端通讯"></a>前端JS和客户端通讯</h2><ol><li>js访问客户端的功能，传递参数和监听回调</li><li>schema协议，通过iframe，（注意iframe异步销毁）</li><li>内置上线，安全快速</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVC/MVP/MVVM</title>
    <link href="/2019/05/02/mvvm/"/>
    <url>/2019/05/02/mvvm/</url>
    
    <content type="html"><![CDATA[<h2 id="MVC-MVP-MVVM"><a href="#MVC-MVP-MVVM" class="headerlink" title="MVC/MVP/MVVM"></a>MVC/MVP/MVVM</h2><ul><li><p>MVC<code>Model-View-Controller</code></p><div class="hljs code-wrapper"><pre><code class="hljs js">View-&gt;Controller-&gt;Model^                     ||                     ||                     v&lt;---------------------&lt;</code></pre></div><ol><li><p>View 传送指令到 Controller ；</p></li><li><p>Controller 完成业务逻辑后，操作 Model 改变数据 ；</p></li><li><p>Model通知 View用新数据更新，用户得到反馈。</p></li></ol><p><em>在MVC中，View会直接从Model中读取数据。</em></p><p><em>Model不依赖于View，但是 View是依赖于Model</em></p></li><li><p>MVP<code>Model-View-Presenter</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript">View &lt;--&gt; Presenter &lt;==&gt; Model</code></pre></div><ol><li><p>M、V、P之间双向通信。</p></li><li><p>View 与 Model 不通信，都通过 Presenter 传递。Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现。</p></li><li><p>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</p></li><li><p><em>Presenter与具体的View是没有直接关联的</em>，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变，这样就可以重用。</p></li></ol></li><li><p>MVVM<code>Model-View-ViewModel</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript">View &lt;==&gt; ViewModel &lt;==&gt; Model</code></pre></div><ul><li><code>Model</code> 层: 对应数据层的域模型，它主要做域模型的同步。通过 Ajax/fetch 等 API 完成客户端和服务端业务 Model 的同步。在层间关系里，它主要用于抽象出 ViewModel 中视图的 Model</li><li><code>View</code> 层: 作为视图模板存在，在 MVVM 里，整个 View 是一个动态模板。除了定义结构、布局外，它展示的是 ViewModel 层的数据和状态。View 层不负责处理状态，View 层做的是数据绑定、 指令的声明、 事件绑定的声明。</li><li><code>ViewModel</code>和<code>View</code>视图双向绑定，在业务处理中只关心数据的流转，而无需直接和页面打交道</li></ul><p><em>mvvm模式将Presener改名为View Model，基本上与MVP模式完全一致，唯一的区别是，它采用双向绑定(data-binding): View的 变动，自动反映在View Model，反之亦然。这样开发者就不用处理接收事件和View更新的工作，框架已经帮你做好了。</em></p><p>使用MVVM模式有几大好处：</p><div class="hljs code-wrapper"><pre><code>1. 低耦合。View可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。　　2. 可重用性。可以把一些视图的逻辑放在ViewModel里面，让很多View重用这段视图逻辑。　　3. 独立开发。开发人员可以专注与业务逻辑和数据的开发(ViewModel)。设计人员可以专注于界面(View)的设计。　　4. 可测试性。可以针对ViewModel来对界面(View)进行测试</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>virtual dom虚拟DOM</title>
    <link href="/2019/04/28/virtual%20dom/"/>
    <url>/2019/04/28/virtual%20dom/</url>
    
    <content type="html"><![CDATA[<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><ul><li>使用js模拟出来的DOM对象</li><li>DOM变化的对比，放在js层来做</li><li>目的：<strong>提高重绘性能</strong></li></ul><h2 id="js模拟"><a href="#js模拟" class="headerlink" title="js模拟"></a>js模拟</h2><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&quot;</span><span class="hljs-attr">container</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;class&quot;</span>&gt;</span>item1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;class&quot;</span>&gt;</span>item2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;class&quot;</span>&gt;</span>item3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>改变list<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"> <span class="hljs-comment">//用js模拟DOM</span><span class="hljs-keyword">var</span> data=&#123;   tag: <span class="hljs-string">&#x27;ul&#x27;</span>,   attrs: &#123;     id: <span class="hljs-string">&#x27;list&#x27;</span>   &#125;,   children: [&#123;     tag: <span class="hljs-string">&#x27;li&#x27;</span>,     attrs: &#123;       className: <span class="hljs-string">&#x27;item&#x27;</span>     &#125;,     children: [       <span class="hljs-string">&#x27;item1&#x27;</span>     ]   &#125;, &#123;     tag: <span class="hljs-string">&#x27;li&#x27;</span>,     attrs: &#123;       className: <span class="hljs-string">&#x27;item&#x27;</span>     &#125;,     children: [       <span class="hljs-string">&#x27;item2&#x27;</span>     ]   &#125;,   &#123;     tag: <span class="hljs-string">&#x27;li&#x27;</span>,     attrs: &#123;       className: <span class="hljs-string">&#x27;item&#x27;</span>     &#125;,     children: [       <span class="hljs-string">&#x27;item3&#x27;</span>     ]   &#125;] &#125; <span class="hljs-comment">//用jquery操作</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span> (<span class="hljs-params">data</span>)</span>&#123;   <span class="hljs-keyword">var</span> $container = $(<span class="hljs-string">&#x27;.container&#x27;</span>)   $container.html(<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment">// &lt;----每次都要全部清空</span>   <span class="hljs-keyword">var</span> $ul = $(<span class="hljs-string">&#x27;&lt;ul&gt;&#x27;</span>)   data.children.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>&#123;     $ul.append($(<span class="hljs-string">&#x27;&lt;&#x27;</span>+ item.tag +<span class="hljs-string">&#x27;&gt;&#x27;</span>+ item.children[<span class="hljs-number">0</span>] +<span class="hljs-string">&#x27;&lt;/&#x27;</span>+ item.tag +<span class="hljs-string">&#x27;&gt;&#x27;</span>))   &#125;)   $container.append($ul) &#125; render(data) $(<span class="hljs-string">&#x27;#btn&#x27;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;   data.children[<span class="hljs-number">1</span>].children = [<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">100</span>)]   render(data) &#125;)</code></pre></div><h2 id="snabbdom"><a href="#snabbdom" class="headerlink" title="snabbdom"></a>snabbdom</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;script src=<span class="hljs-string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom.js&quot;</span>&gt;&lt;/script&gt;&lt;script src=<span class="hljs-string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-class.js&quot;</span>&gt;&lt;/script&gt;&lt;script src=<span class="hljs-string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-props.js&quot;</span>&gt;&lt;/script&gt;&lt;script src=<span class="hljs-string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-style.js&quot;</span>&gt;&lt;/script&gt;&lt;script src=<span class="hljs-string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-eventlisteners.js&quot;</span>&gt;&lt;/script&gt;&lt;script src=<span class="hljs-string">&quot;https://cdn.bootcss.com/snabbdom/0.7.3/h.js&quot;</span>&gt;&lt;/script&gt;  <span class="hljs-keyword">var</span> snabbdom  = <span class="hljs-built_in">window</span>.snabbdom  <span class="hljs-comment">//定义关键函数</span>  <span class="hljs-keyword">var</span> patch = snabbdom.init([    snabbdom_class,    snabbdom_props,    snabbdom_style,    snabbdom_eventlisteners  ])  <span class="hljs-keyword">var</span> h = snabbdom.h  <span class="hljs-keyword">var</span> container = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&#x27;container&#x27;</span>)[<span class="hljs-number">0</span>] <span class="hljs-comment">// 注意此处的返回</span>  <span class="hljs-comment">// console.log(document.getElementsByClassName(&#x27;container&#x27;))</span>  <span class="hljs-comment">// console.log(container)</span>  <span class="hljs-keyword">var</span> vnode = h(<span class="hljs-string">&#x27;ul#list&#x27;</span>, &#123;&#125;, [    h(<span class="hljs-string">&#x27;li.item&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;item1&#x27;</span>),    h(<span class="hljs-string">&#x27;li.item&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;item2&#x27;</span>),    h(<span class="hljs-string">&#x27;li.item&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;item3&#x27;</span>)  ])   patch(container, vnode)    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;btn&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> newvnode = h(<span class="hljs-string">&#x27;ul#list&#x27;</span>, &#123;&#125;, [      h(<span class="hljs-string">&#x27;li.item&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;item1&#x27;</span>),      h(<span class="hljs-string">&#x27;li.item&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;666666&#x27;</span>),      h(<span class="hljs-string">&#x27;li.item&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;item3&#x27;</span>)    ])    patch(vnode, newvnode) <span class="hljs-comment">// newnode patch oldnode</span>  &#125;)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6</title>
    <link href="/2019/04/28/ES6/"/>
    <url>/2019/04/28/ES6/</url>
    
    <content type="html"><![CDATA[<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ol><li>语法</li></ol><p><code>export / export</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 这是 Node 中向外暴露成员的形式：</span><span class="hljs-comment">// module.exports = &#123;&#125;</span><span class="hljs-comment">// ES6中导入模块，使用 import 模块名称 from &#x27;模块标识符&#x27; import &#x27;表示路径&#x27;</span><span class="hljs-comment">// 在 ES6 中，使用 export default 和 export 向外暴露成员：</span><span class="hljs-keyword">var</span> info = &#123;  name: <span class="hljs-string">&quot;zs&quot;</span>,  age: <span class="hljs-number">20</span>&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> info;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  address: <span class="hljs-string">&quot;深圳&quot;</span>&#125;;<span class="hljs-comment">// 注意： export default 向外暴露的成员，可以使用任意的变量来接收</span><span class="hljs-comment">// 注意： 在一个模块中，export default 只允许向外暴露1次</span><span class="hljs-comment">// 注意： 在一个模块中，可以同时使用 export default 和 export 向外暴露成员</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> title = <span class="hljs-string">&quot;小星星&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> content = <span class="hljs-string">&quot;哈哈哈&quot;</span>;<span class="hljs-comment">// 注意： 使用 export 向外暴露的成员，只能使用 &#123; &#125; 的形式来接收，这种形式，叫做 【按需导出】</span><span class="hljs-comment">// 注意： export 可以向外暴露多个成员， 同时，如果某些成员，我们在 import 的时候，不需要，则可以不在 &#123;&#125; 中定义</span><span class="hljs-comment">// 注意： 使用 export 导出的成员，必须严格按照 导出时候的名称，来使用 &#123;&#125; 按需接收；</span><span class="hljs-comment">// 注意： 使用 export 导出的成员，如果 就想 换个 名称来接收，可以使用 as 来起别名；</span><span class="hljs-comment">// 在Node中 使用 var 名称 = require(&#x27;模块标识符&#x27;)</span><span class="hljs-comment">// module.exports 和 exports 来暴露成员</span></code></pre></div><ol start="2"><li><p>使用 babel 编译 ES6 语法</p><p>Babel 是一个工具链，主要用于在旧的浏览器或环境中将 ECMAScript 2015+ 代码转换为向后兼容版本的 JavaScript 代码</p></li><li><p>模块化工具 webpack,rollup</p></li></ol><h2 id="Class-和构造函数"><a href="#Class-和构造函数" class="headerlink" title="Class 和构造函数"></a>Class 和构造函数</h2><ol><li><p><code>typeof Class -&gt; &quot;function&quot;</code></p><p>class 其实是语法糖</p></li><li><p>Class 继承</p><p>本质使用的是原型式继承</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span>&#123;    <span class="hljs-built_in">this</span>.name = name  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-title">extend</span> <span class="hljs-title">B</span></span>&#123;  <span class="hljs-title">constructor</span> (<span class="hljs-params">name</span>)&#123;    <span class="hljs-built_in">super</span>(name)      &#125;  &#125;</code></pre></div><p><strong>super 就是父类的构造函数</strong></p><p><strong>super 传入什么参数就继承父类构造函数的什么属性</strong></p></li></ol><h2 id="ES6-中声明对象的方法"><a href="#ES6-中声明对象的方法" class="headerlink" title="ES6 中声明对象的方法"></a>ES6 中声明对象的方法</h2><ul><li>var</li><li>function</li><li>let</li><li>const</li><li>class</li><li>import</li></ul><h3 id="顶层对象"><a href="#顶层对象" class="headerlink" title="顶层对象"></a>顶层对象</h3><div class="hljs code-wrapper"><pre><code><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-comment">// 如果在 Node 的 REPL 环境，可以写成       global.a</span><span class="hljs-comment">// 或者采用通用方法，写成 this.a</span><span class="hljs-built_in">window</span>.a <span class="hljs-comment">// 1</span><span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>;<span class="hljs-built_in">window</span>.b <span class="hljs-comment">// undefined</span></code></pre></div>上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined</code></pre><h3 id="GloablThis"><a href="#GloablThis" class="headerlink" title="GloablThis"></a>GloablThis</h3><ul><li>js 在各种运行环境里顶层对象不统一</li><li>浏览器中 -&gt; <code>window</code></li><li>node 中 ——&gt; <code>global</code></li></ul><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><ul><li>用法类似 var</li><li>块级作用域</li><li>不存在变量提升<blockquote><p>var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为 undefined。</p></blockquote></li><li>暂时性死区<blockquote><p>块级作用域内 let 声明的变量不会受该区域外部的影响</p></blockquote></li><li>不允许重复声明</li></ul><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul><li>声明一个只读的常量</li><li>值不可改变</li><li>声明后立即初始化赋值</li><li>块级作用域</li><li>变量不提升</li><li>暂时性死区</li><li>不可重复声明<blockquote><p>const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p></blockquote></li></ul><h2 id="多行字符串-模版变量"><a href="#多行字符串-模版变量" class="headerlink" title="多行字符串/模版变量"></a>多行字符串/模版变量</h2><div class="hljs code-wrapper"><pre><code><pre><code class="hljs javascript"><span class="hljs-comment">//es5</span><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;mmm&#x27;</span>,age = <span class="hljs-number">20</span>,html = <span class="hljs-string">&#x27;&#x27;</span>;html += <span class="hljs-string">&#x27;&lt;div&gt;&#x27;</span>;html += <span class="hljs-string">&#x27; &lt;p&gt;&#x27;</span> + name + <span class="hljs-string">&#x27;&lt;/p&gt;&#x27;</span>;html += <span class="hljs-string">&#x27; &lt;p&gt;&#x27;</span> + age + <span class="hljs-string">&#x27;&lt;/p&gt;&#x27;</span>;html += <span class="hljs-string">&#x27;&lt;/div&gt;&#x27;</span>;<span class="hljs-comment">//es6</span><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;mmm&#x27;</span>,age = <span class="hljs-number">20</span>;<span class="hljs-keyword">const</span> html = <span class="hljs-string">`&lt;div&gt;</span><span class="hljs-string">                &lt;p&gt;<span class="hljs-subst">$&#123;name&#125;</span>&lt;/p&gt;</span><span class="hljs-string">                &lt;p&gt;<span class="hljs-subst">$&#123;age&#125;</span>&lt;/p&gt;</span><span class="hljs-string">              &lt;/div&gt;`</span><span class="hljs-built_in">console</span>.log(html)</code></pre></div></code></pre><h2 id="解构赋值和默认值"><a href="#解构赋值和默认值" class="headerlink" title="解构赋值和默认值"></a>解构赋值和默认值</h2><p>解构赋值的用途：</p><ul><li>交换变量的值</li><li>从函数返回多个值</li><li>函数参数的定义</li><li>提取 JSON 数据</li><li>函数参数的默认值</li><li>Map 遍历<code>for (let [key, value] of map) &#123;console.log(key + &quot; is &quot; + value);&#125;</code></li><li>加载模块时候指定方法<code>const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// normal</span><span class="hljs-keyword">let</span> [foo = <span class="hljs-literal">true</span>] = [];foo <span class="hljs-comment">// true</span><span class="hljs-keyword">let</span> [x, y = <span class="hljs-string">&#x27;b&#x27;</span>] = [<span class="hljs-string">&#x27;a&#x27;</span>]; <span class="hljs-comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span><span class="hljs-keyword">let</span> [x, y = <span class="hljs-string">&#x27;b&#x27;</span>] = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-literal">undefined</span>]; <span class="hljs-comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span>！！！！！注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值<span class="hljs-comment">// 默认值</span><span class="hljs-keyword">let</span> [x = <span class="hljs-number">1</span>] = [<span class="hljs-literal">undefined</span>];x <span class="hljs-comment">// 1</span><span class="hljs-keyword">let</span> [x = <span class="hljs-number">1</span>] = [<span class="hljs-literal">null</span>];x <span class="hljs-comment">// null</span><span class="hljs-keyword">let</span> [x = <span class="hljs-number">1</span>, y = x] = [];     <span class="hljs-comment">// x=1; y=1</span><span class="hljs-keyword">let</span> [x = <span class="hljs-number">1</span>, y = x] = [<span class="hljs-number">2</span>];    <span class="hljs-comment">// x=2; y=2</span><span class="hljs-keyword">let</span> [x = <span class="hljs-number">1</span>, y = x] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]; <span class="hljs-comment">// x=1; y=2</span><span class="hljs-keyword">let</span> [x = y, y = <span class="hljs-number">1</span>] = [];     <span class="hljs-comment">// ReferenceError: y is not defined</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 对象的解构赋值</span><span class="hljs-comment">// 和顺序无关，keyvalue对应就行</span><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">foo</span>: foo, <span class="hljs-attr">bar</span>: bar &#125; = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">&quot;bbb&quot;</span> &#125;;<span class="hljs-keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">&quot;bbb&quot;</span> &#125;;foo; <span class="hljs-comment">// &quot;aaa&quot;</span>bar; <span class="hljs-comment">// &quot;bbb&quot;</span><span class="hljs-comment">// 默认值</span><span class="hljs-keyword">var</span> &#123; x = <span class="hljs-number">3</span> &#125; = &#123;&#125;;x; <span class="hljs-comment">// 3</span><span class="hljs-keyword">var</span> &#123; x, y = <span class="hljs-number">5</span> &#125; = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> &#125;;x; <span class="hljs-comment">// 1</span>y; <span class="hljs-comment">// 5</span><span class="hljs-keyword">var</span> &#123; <span class="hljs-attr">x</span>: y = <span class="hljs-number">3</span> &#125; = &#123;&#125;;y; <span class="hljs-comment">// 3</span><span class="hljs-keyword">var</span> &#123; <span class="hljs-attr">x</span>: y = <span class="hljs-number">3</span> &#125; = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">5</span> &#125;;y; <span class="hljs-comment">// 5</span><span class="hljs-keyword">var</span> &#123; <span class="hljs-attr">message</span>: msg = <span class="hljs-string">&quot;Something went    wrong&quot;</span> &#125; = &#123;&#125;;msg; <span class="hljs-comment">// &quot;Something went wrong&quot;</span><span class="hljs-comment">//默认值生效的条件是，对象的属性值严格等于undefined</span><span class="hljs-keyword">var</span> &#123; x = <span class="hljs-number">3</span> &#125; = &#123; <span class="hljs-attr">x</span>: <span class="hljs-literal">undefined</span> &#125;;x; <span class="hljs-comment">// 3</span><span class="hljs-keyword">var</span> &#123; x = <span class="hljs-number">3</span> &#125; = &#123; <span class="hljs-attr">x</span>: <span class="hljs-literal">null</span> &#125;;x; <span class="hljs-comment">// null</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//字符串的解构赋值，字符串被转换为蕾丝数组的对象</span><span class="hljs-keyword">const</span> [a, b, c, d, e] = <span class="hljs-string">&#x27;hello&#x27;</span>;a <span class="hljs-comment">// &quot;h&quot;</span>b <span class="hljs-comment">// &quot;e&quot;</span>c <span class="hljs-comment">// &quot;l&quot;</span>d <span class="hljs-comment">// &quot;l&quot;</span>e <span class="hljs-comment">// &quot;o&quot;</span><span class="hljs-comment">// 数值和布尔值的解构赋值</span><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">toString</span>: s&#125; = <span class="hljs-number">123</span>;s === <span class="hljs-built_in">Number</span>.prototype.toString <span class="hljs-comment">// true</span><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">toString</span>: s&#125; = <span class="hljs-literal">true</span>;s === <span class="hljs-built_in">Boolean</span>.prototype.toString <span class="hljs-comment">// true</span>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<span class="hljs-literal">undefined</span>和<span class="hljs-literal">null</span>无法转为对象，所以对它们进行解构赋值，都会报错。<span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">prop</span>: x &#125; = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// TypeError</span><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">prop</span>: y &#125; = <span class="hljs-literal">null</span>; <span class="hljs-comment">// TypeError</span><span class="hljs-comment">// 函数参数的解构赋注</span></code></pre></div><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ul><li>箭头函数的 this 是语法上的，静态绑定书写时的上下文</li><li>箭头函数没有<code>prototype</code> —&gt; <strong>不能作为构造函数，不能 new</strong></li><li>箭头函数不能用<code>arguments</code>属性</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//es5</span><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];arr = arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;  <span class="hljs-keyword">return</span> item + <span class="hljs-number">1</span>;&#125;);<span class="hljs-comment">//es6</span><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];arr = arr.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item + <span class="hljs-number">1</span>);<span class="hljs-comment">// this的指向</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// &#123;a:666&#125;</span>  <span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];  arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;js&quot;</span>, <span class="hljs-built_in">this</span>); <span class="hljs-comment">// window</span>    <span class="hljs-keyword">return</span> item + <span class="hljs-number">1</span>;  &#125;);  arr.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;es6&quot;</span>, <span class="hljs-built_in">this</span>); <span class="hljs-comment">// &#123;a:666&#125;</span>    <span class="hljs-keyword">return</span> item + <span class="hljs-number">1</span>;  &#125;);&#125;fn.call(&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">666</span> &#125;);</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> elements = [<span class="hljs-string">&quot;Hydrogen&quot;</span>, <span class="hljs-string">&quot;Helium&quot;</span>, <span class="hljs-string">&quot;Lithium&quot;</span>, <span class="hljs-string">&quot;Beryllium&quot;</span>];elements.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>&#123;  <span class="hljs-keyword">return</span> element.length;&#125;); <span class="hljs-comment">// 返回数组：[8, 6, 7, 9]</span><span class="hljs-comment">// 上面的普通函数可以改写成如下的箭头函数</span>elements.map(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> element.length;&#125;); <span class="hljs-comment">// [8, 6, 7, 9]</span><span class="hljs-comment">// 当箭头函数只有一个参数时，可以省略参数的圆括号</span>elements.map(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> element.length;&#125;); <span class="hljs-comment">// [8, 6, 7, 9]</span><span class="hljs-comment">// 当箭头函数的函数体只有一个 `return` 语句时，可以省略 `return` 关键字和方法体的花括号</span>elements.map(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> element.length); <span class="hljs-comment">// [8, 6, 7, 9]</span><span class="hljs-comment">// 在这个例子中，因为我们只需要 `length` 属性，所以可以使用参数解构</span><span class="hljs-comment">// 需要注意的是字符串 `&quot;length&quot;` 是我们想要获得的属性的名称，而 `lengthFooBArX` 则只是个变量名，</span><span class="hljs-comment">// 可以替换成任意合法的变量名</span>elements.map(<span class="hljs-function">(<span class="hljs-params">&#123; length: lengthFooBArX &#125;</span>) =&gt;</span> lengthFooBArX); <span class="hljs-comment">// [8, 6, 7, 9]</span></code></pre></div><p><strong>!!!!!!!!箭头函数不会创建自己的 this,它只会从自己的作用域链的上一层继承 this</strong></p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">s.add(<span class="hljs-number">1</span>)  .add(<span class="hljs-number">2</span>)  .add(<span class="hljs-number">2</span>);<span class="hljs-comment">// 注意2被加入了两次</span>s.size; <span class="hljs-comment">// 2</span>s.has(<span class="hljs-number">1</span>); <span class="hljs-comment">// true</span>s.has(<span class="hljs-number">2</span>); <span class="hljs-comment">// true</span>s.has(<span class="hljs-number">3</span>); <span class="hljs-comment">// false</span>s.delete(<span class="hljs-number">2</span>);s.has(<span class="hljs-number">2</span>); <span class="hljs-comment">// false</span></code></pre></div><ul><li>遍历操作</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set.keys()) &#123;  <span class="hljs-built_in">console</span>.log(item);&#125;<span class="hljs-comment">// red</span><span class="hljs-comment">// green</span><span class="hljs-comment">// blue</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set.values()) &#123;  <span class="hljs-built_in">console</span>.log(item);&#125;<span class="hljs-comment">// red</span><span class="hljs-comment">// green</span><span class="hljs-comment">// blue</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set.entries()) &#123;  <span class="hljs-built_in">console</span>.log(item);&#125;<span class="hljs-comment">// [&quot;red&quot;, &quot;red&quot;]</span><span class="hljs-comment">// [&quot;green&quot;, &quot;green&quot;]</span><span class="hljs-comment">// [&quot;blue&quot;, &quot;blue&quot;]</span><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> set) &#123;  <span class="hljs-built_in">console</span>.log(x);&#125;<span class="hljs-comment">// red</span><span class="hljs-comment">// green</span><span class="hljs-comment">// blue</span></code></pre></div><ul><li>forEach()</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>]);set.forEach(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">&quot; : &quot;</span> + value));<span class="hljs-comment">// 1 : 1</span><span class="hljs-comment">// 4 : 4</span><span class="hljs-comment">// 9 : 9</span></code></pre></div><ul><li>扩展运算符</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>]);<span class="hljs-keyword">let</span> arr = [...set];<span class="hljs-comment">// [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]</span><span class="hljs-comment">//数组去重</span><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>];<span class="hljs-keyword">let</span> unique = [...new <span class="hljs-built_in">Set</span>(arr)];<span class="hljs-comment">// [3, 5, 2]</span><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...set].map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>));<span class="hljs-comment">// 返回Set结构：&#123;2, 4, 6&#125;</span><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...set].filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>));<span class="hljs-comment">// 返回Set结构：&#123;2, 4&#125;</span><span class="hljs-comment">//let a = new Set([1, 2, 3]);</span><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]);<span class="hljs-comment">// 并集</span><span class="hljs-keyword">let</span> union = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...a, ...b]);<span class="hljs-comment">// Set &#123;1, 2, 3, 4&#125;</span><span class="hljs-comment">// 交集</span><span class="hljs-keyword">let</span> intersect = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...a].filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> b.has(x)));<span class="hljs-comment">// set &#123;2, 3&#125;</span><span class="hljs-comment">// 差集</span><span class="hljs-keyword">let</span> difference = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...a].filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !b.has(x)));<span class="hljs-comment">// Set &#123;1&#125;</span></code></pre></div><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="js-的对象-Object-的键传统上只能使用字符串，使用上有限制"><a href="#js-的对象-Object-的键传统上只能使用字符串，使用上有限制" class="headerlink" title="js 的对象 Object 的键传统上只能使用字符串，使用上有限制"></a>js 的对象 Object 的键传统上只能使用字符串，使用上有限制</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> data = &#123;&#125;;<span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myDiv&#x27;</span>);data[element] = <span class="hljs-string">&#x27;metadata&#x27;</span>;data[<span class="hljs-string">&#x27;[object HTMLDivElement]&#x27;</span>]<span class="hljs-comment">// &quot;metadata&quot;</span>由于对象只接受字符串作为键名，所以element被自动转为字符串[object HTMLDivElement]。</code></pre></div><h3 id="ES6-提供了-Map-数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。"><a href="#ES6-提供了-Map-数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。" class="headerlink" title="ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。"></a>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> items = [  [<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>],  [<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;Author&quot;</span>]];<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();items.forEach(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> map.set(key, value));</code></pre></div><h3 id="Map-的属性和方法"><a href="#Map-的属性和方法" class="headerlink" title="Map 的属性和方法"></a>Map 的属性和方法</h3><ul><li>size</li><li>set(key,value) // 返回整个 Map 结构</li><li>get() // 找不到该 key 返回 undefined</li><li>has()</li><li>delete() // 删除失败返回 false</li><li>clear() // 无返回值</li></ul><h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([  [<span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;no&quot;</span>],  [<span class="hljs-string">&quot;T&quot;</span>, <span class="hljs-string">&quot;yes&quot;</span>]]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> map.keys()) &#123;  <span class="hljs-built_in">console</span>.log(key);&#125;<span class="hljs-comment">// &quot;F&quot;</span><span class="hljs-comment">// &quot;T&quot;</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> map.values()) &#123;  <span class="hljs-built_in">console</span>.log(value);&#125;<span class="hljs-comment">// &quot;no&quot;</span><span class="hljs-comment">// &quot;yes&quot;</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> map.entries()) &#123;  <span class="hljs-built_in">console</span>.log(item[<span class="hljs-number">0</span>], item[<span class="hljs-number">1</span>]);&#125;<span class="hljs-comment">// &quot;F&quot; &quot;no&quot;</span><span class="hljs-comment">// &quot;T&quot; &quot;yes&quot;</span><span class="hljs-comment">// 或者</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> map.entries()) &#123;  <span class="hljs-built_in">console</span>.log(key, value);&#125;<span class="hljs-comment">// &quot;F&quot; &quot;no&quot;</span><span class="hljs-comment">// &quot;T&quot; &quot;yes&quot;</span><span class="hljs-comment">// 等同于使用map.entries()</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> map) &#123;  <span class="hljs-built_in">console</span>.log(key, value);&#125;<span class="hljs-comment">// &quot;F&quot; &quot;no&quot;</span><span class="hljs-comment">// &quot;T&quot; &quot;yes&quot;</span></code></pre></div><h3 id="与其他数据类型的互相转换"><a href="#与其他数据类型的互相转换" class="headerlink" title="与其他数据类型的互相转换"></a>与其他数据类型的互相转换</h3><p>。。。</p><h2 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h2><h3 id="Generator-函数的语法糖"><a href="#Generator-函数的语法糖" class="headerlink" title="Generator 函数的语法糖"></a>Generator 函数的语法糖</h3><p>async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await。<br>可以看作是多个异步操作包装成的 Promise 对象，await，命令就是内部 then 命令的语法糖。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>async 函数返回 Promise 对象，必须等到所有 await 执行完或者 return，才会执行 then</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTitle</span>(<span class="hljs-params">url</span>) </span>&#123;  <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(url);  <span class="hljs-keyword">let</span> html = <span class="hljs-keyword">await</span> response.text();  <span class="hljs-keyword">return</span> html.match(<span class="hljs-regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="hljs-number">1</span>];&#125;getTitle(<span class="hljs-string">&quot;https://tc39.github.io/ecma262/&quot;</span>).then(<span class="hljs-built_in">console</span>.log);</code></pre></div><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中.</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;  <span class="hljs-keyword">await</span> func();&#125; <span class="hljs-keyword">catch</span> (err) &#123;  <span class="hljs-built_in">console</span>.log(err);&#125;<span class="hljs-comment">//或者直接写成</span><span class="hljs-keyword">await</span> func().catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(err);&#125;);</code></pre></div><p>如果 await 操作成功，就会使用 break 语句退出循环；如果失败，会被 catch 语句捕捉，然后进入下一轮循环。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;superagent&quot;</span>);<span class="hljs-keyword">const</span> NUM_RETRIES = <span class="hljs-number">3</span>;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> i;  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NUM_RETRIES; ++i) &#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">await</span> superagent.get(<span class="hljs-string">&quot;http://google.com/this-throws-an-error&quot;</span>);      <span class="hljs-keyword">break</span>;    &#125; <span class="hljs-keyword">catch</span> (err) &#123;&#125;  &#125;  <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// 3</span>&#125;test();</code></pre></div><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><ul><li><code>...args</code>函数的参数数组</li><li><code>...rest</code>函数的剩余参数</li></ul><h2 id="尾调优化"><a href="#尾调优化" class="headerlink" title="尾调优化"></a>尾调优化</h2><blockquote><p>尾调函数：外部函数的返回值是以一个内部函数的返回值</p></blockquote><p>  es6新规范规定：尾调函数执行过程中可以把执行完成的外部函数弹出执行栈，节省栈空间（内存</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>)</span>&#123;  ...一些操作  <span class="hljs-keyword">return</span> inner() <span class="hljs-comment">// 尾调用</span>&#125;</code></pre></div><p>  尾调用优化的条件就是确定外部栈帧真的没有必要存在了。涉及<br>  的条件如下：</p><ol><li>代码在 ** 严格模式 ** 下执行；<blockquote><p>严格模式的意义：使用arguments和callee都会引用外部函数，优化失败</p></blockquote></li><li>外部函数的返回值是对尾调用函数的调用；</li><li>尾调用函数返回后不需要执行额外的逻辑；</li><li>尾调用函数不是引用外部函数作用域中自由变量的闭包。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flex布局</title>
    <link href="/2019/04/25/flex%E5%B8%83%E5%B1%80/"/>
    <url>/2019/04/25/flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>ref:<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">阮一峰的网络日志</a></p><h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><ul><li><p>flex-direction 主轴的方向</p><p><code>flex-direction</code>: </p><ul><li><code>row(默认住) | row-reverse</code> 横向排列</li><li><code>column | column-reverse</code>纵向排列</li></ul></li><li><p>flex-wrap 排列不下时的换行处理</p><p><code>flex-wrap</code>:</p><ul><li><code>nowrap</code>不换行</li><li><code>wrap</code>换行</li><li><code>wrap-reverse</code>逆序换行</li></ul></li><li><p>flex-flow(上述两种的简写)</p><p><code>flex-flow属性是flex-direction属性和flex-wrap属性的简写</code></p></li><li><p>justify-content 主轴上的对齐方式</p><ul><li><code>flex-start</code>（默认值）：左对齐 </li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</li></ul></li><li><p>align-items 项目在交叉轴上如何对齐 </p><ul><li><code>flex-start</code>：交叉轴的起点对齐</li><li><code>flex-end</code>：交叉轴的终点对齐</li><li><code>center</code>：交叉轴的中点对齐</li><li><code>baseline</code>: 项目的第一行文字的基线对齐</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度</li></ul></li><li><p>align-content 多根轴线的对齐方式</p><ul><li><code>flex-start</code>：与交叉轴的起点对齐</li><li><code>flex-end</code>：与交叉轴的终点对齐</li><li><code>center</code>：与交叉轴的中点对齐</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴</li></ul></li></ul><h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><ul><li><p><code>order</code></p><p>项目的排列顺序。数值越小，排列越靠前，默认为0</p></li><li><p><code>flex-grow</code></p><p>如果存在剩余空间，1放大，0不放大</p></li><li><p><code>flex-shrink</code></p><p>如果空间不足，1缩小，0不缩小</p></li><li><p><code>flex-basis</code></p><p>  基础大小</p></li><li><p><code>flex</code></p><p><code>[flex-grow][flex-shrink][flex-basis]</code></p></li><li><p><code>align-self</code></p><p>与其他项目不一样的对齐方式,参考<code>[align-item]</code></p></li></ul><ol><li><p>圣杯布局</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:burlywood&quot;</span>&gt;</span>header<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 按照顺序渲染，如果需提前修改元素order属性，越小越优先 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:chocolate&quot;</span>&gt;</span>nav<span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:blueviolet&quot;</span>&gt;</span>main<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aside</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:cadetblue&quot;</span>&gt;</span>aside<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:darkslateblue&quot;</span>&gt;</span>footer<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs css">*&#123;  <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;&#125;<span class="hljs-selector-tag">body</span>&#123;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100vh</span>;  <span class="hljs-comment">/* 垂直方向 */</span>  <span class="hljs-attribute">flex-direction</span>: column;&#125;<span class="hljs-selector-tag">header</span>,<span class="hljs-selector-tag">footer</span>&#123;  <span class="hljs-comment">/* 6em 为本身的固定宽度 */</span>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">6em</span>;&#125;<span class="hljs-selector-class">.body</span>&#123;  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;  <span class="hljs-attribute">display</span>: flex;&#125;<span class="hljs-selector-class">.body</span> <span class="hljs-selector-tag">nav</span>,<span class="hljs-selector-class">.body</span> <span class="hljs-selector-tag">aside</span>&#123;  <span class="hljs-comment">/* 10em 为本身的固定宽度 */</span>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10em</span>;&#125;<span class="hljs-selector-class">.body</span> <span class="hljs-selector-tag">main</span>&#123;  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>&#125;</code></pre></div></li><li><p>固定的底栏</p><div class="hljs code-wrapper"><pre><code class="hljs css">*&#123;  <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;&#125;<span class="hljs-selector-tag">body</span>&#123;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-comment">/* 改变flex朝向 */</span>  <span class="hljs-attribute">flex-direction</span>:column;  <span class="hljs-comment">/* 占满视口高度 */</span> &lt;----------------  <span class="hljs-attribute">min-height</span>:<span class="hljs-number">100vh</span>;&#125;<span class="hljs-selector-tag">header</span>&#123;  <span class="hljs-attribute">height</span>:<span class="hljs-number">30px</span>;  <span class="hljs-attribute">background</span>: blue;&#125;<span class="hljs-selector-tag">main</span>&#123;  <span class="hljs-comment">/* 主题内容填满剩余空间 */</span>  <span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span>&#125;<span class="hljs-selector-tag">footer</span>&#123;  <span class="hljs-attribute">background</span>:black;&#125;</code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html/css面试题</title>
    <link href="/2019/04/24/htmlcss%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2019/04/24/htmlcss%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="web-标准"><a href="#web-标准" class="headerlink" title="web 标准"></a>web 标准</h3><blockquote><p>w3c（万维网联盟）创建于 1994 年，是 Web 技术领域最具权威和影响力的国际中立性技术标准机构。</p></blockquote><ul><li><p>W3C 标准被称为 W3C 推荐标准（W3C Recommendations），W3C 最重要的工作是发展 web 规范，也就是描述 web 通信协议（比如 HTML 和 XML）和其他构建模块的“推荐标准”。</p></li><li><p>网页主要由三部分组成：结构（Structure）、表现（Presentation）和行为（Behavior）。对应的标准也分三方面：结构化标准语言主要包括 XHTML 和 XML，表现标准语言主要包括 CSS，行为标准主要包括对象模型（如 W3C DOM）、ECMAScript 等。这些标准大部分由万维网联盟（外语缩写：W3C）起草和发布，也有一些是其他标准组织制订的标准，比如 ECMA（European Computer Manufacturers Association）的 ECMAScript 标准。</p></li></ul><h4 id="Web-标准的优点"><a href="#Web-标准的优点" class="headerlink" title="Web 标准的优点"></a>Web 标准的优点</h4><p>● 文件下载与页面显示速度更快。<br>● 内容能被更多的用户所访问（包括失明、视弱、色盲等残障人士）。<br>● 内容能被更广泛的设备所访问（包括屏幕阅读机、手持设备、搜索机器人、打印机、电冰箱等等）。<br>● 用户能够通过样式选择定制自己的表现界面。<br>● 所有页面都能提供适于打印的版本。<br>● 更少的代码和组件，容易维护。<br>● 带宽要求降低（代码更简洁），成本降低。举个例子：当 ESPN.com 使用 CSS 改版后，每天节约超过两兆字节（terabytes）的带宽。<br>● 更容易被搜寻引擎搜索到。<br>● 提高网站易用性。</p><h3 id="html5-哪些标签可以做-SEO-优化"><a href="#html5-哪些标签可以做-SEO-优化" class="headerlink" title="html5 哪些标签可以做 SEO 优化"></a>html5 哪些标签可以做 SEO 优化</h3><p><code>title、meta、header、footer、nav、article、aside</code></p><h3 id="meta标签的作用"><a href="#meta标签的作用" class="headerlink" title="meta标签的作用"></a>meta标签的作用</h3><ul><li>keyword seo优化 </li><li>viewreport 多端适配，缩放</li><li>charset 字符编码</li><li>模拟http请求<code>http-equiv=&quot;expires&quot;</code></li></ul><h3 id="处理-html5-的兼容"><a href="#处理-html5-的兼容" class="headerlink" title="处理 html5 的兼容"></a>处理 html5 的兼容</h3><p>IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加默认的样式。</p><p>也可以直接使用成熟的框架，如 html5shim：<br><code>&lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;</code></p><h3 id="html5-新特性"><a href="#html5-新特性" class="headerlink" title="html5 新特性"></a>html5 新特性</h3><h4 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h4><p>纯表现的元素：basefont，big，center，font, s，strike，tt，u；</p><p>对可用性产生负面影响的元素：frame，frameset，noframes；</p><h4 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h4><ul><li><p>拖拽释放(Drag and drop) API </p></li><li><p><code>canvas</code> 画布和内联 <code>svg</code></p></li><li><p><code>audio/video</code> 音视频元素</p></li><li><p><code>localStorage``sessionStorage</code></p></li><li><p>语意化更好的标签，比如<code>header,nav,section,article,footer,aside</code></p></li><li><p>新的表单元素：<code>datalist，keygen，output</code>,表单自动完成</p></li><li><p>新的表单输入类型<code>email,url,number,range,Date pickers (date, month, week, time, datetime, datetime-local),search,color</code></p></li><li><p>web 应用程序离线缓存</p></li><li><p>地理定位Geolocation API</p></li><li><p>webworker，websocket</p></li></ul><h3 id="HTML5-的离线存储"><a href="#HTML5-的离线存储" class="headerlink" title="HTML5 的离线存储"></a>HTML5 的离线存储</h3><p>在用户没有联网时，可以正常访问站点或应用；在联网的情况下，更新用户机器上的缓存文件。</p><p>如何使用：<br>1、页面头部加入一个 manifest 的属性<br>2、在 cache.manifest 文件的编写离线存储的资源<br>3、在离线状态下，操作 window.applicationCache 进行需求实现</p><h4 id="浏览器是如何对-HTML5-的离线存储资源进行管理和加载的"><a href="#浏览器是如何对-HTML5-的离线存储资源进行管理和加载的" class="headerlink" title="浏览器是如何对 HTML5 的离线存储资源进行管理和加载的"></a>浏览器是如何对 HTML5 的离线存储资源进行管理和加载的</h4><ul><li><p>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，浏览器会根据 manifest 文件的内容下载相应的资源并且进行离线存储。</p></li><li><p>如果已经访问过 app，并且资源已经离线存储，浏览器会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件，如果文件没有发生改变，就不做任何操作，否则就会重新下载文件中的资源并进行离线存储。</p></li><li><p>离线的情况下，浏览器直接使用离线存储的资源。</p></li></ul><h3 id="css3-新特性"><a href="#css3-新特性" class="headerlink" title="css3 新特性"></a>css3 新特性</h3><ul><li>边框属性<code>border-radius</code>，<code>box-shadow</code>，<code>border-image</code></li><li>背景控制<code>background-size,background-origin</code></li><li>文字阴影和自动换行<code>text-shadow,word-wrap</code></li><li>自定义字体<code>@font-face</code></li><li>2d/3d 转换，过渡和动画</li><li>多栏布局</li><li>盒模型属性<code>box-sizing</code></li><li>弹性盒子<code>flex</code></li><li>更强大的多媒体查询</li></ul><h3 id="position-跟-display、margin-collapse、overflow、float-这些特性相互叠加后会怎样"><a href="#position-跟-display、margin-collapse、overflow、float-这些特性相互叠加后会怎样" class="headerlink" title="position 跟 display、margin collapse、overflow、float 这些特性相互叠加后会怎样"></a>position 跟 display、margin collapse、overflow、float 这些特性相互叠加后会怎样</h3><ul><li>如果元素的 display 为 none，那么元素不被渲染，position，float 不起作用；</li><li>如果元素拥有 position:absolute;或 position:fixed;属性，那么元素将为绝对定位，float 不起作用。</li><li>如果元素 float 属性不是 none，元素会脱离文档流，根据 float 属性值来显示。</li><li>有浮动、绝对定位，inline-block 属性的元素，margin 不会和垂直方向上的其他元素 margin 折叠。</li></ul><h3 id="css-实现简单的幻灯片效果"><a href="#css-实现简单的幻灯片效果" class="headerlink" title="css 实现简单的幻灯片效果"></a>css 实现简单的幻灯片效果</h3><p><a href="https://www.runoob.com/css3/css3-animations.html">css3 动画菜鸟教程</a></p><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;  <span class="hljs-attribute">animation-name</span>: Myani;  <span class="hljs-attribute">animation-duration</span>: <span class="hljs-number">5s</span>;  <span class="hljs-attribute">animation-timing-function</span>: linear;  <span class="hljs-attribute">animation-delay</span>: <span class="hljs-number">2s</span>;  <span class="hljs-attribute">animation-iteration-count</span>: infinite;  <span class="hljs-attribute">animation-direction</span>: alternate;  <span class="hljs-attribute">animation-play-state</span>: running;  <span class="hljs-comment">/* Firefox: */</span>  -moz-  <span class="hljs-comment">/* Safari 和 Chrome: */</span>  -webkit-  <span class="hljs-comment">/* Opera: */</span>  -o-&#125;<span class="hljs-keyword">@keyframe</span> Myani &#123;  &lt; !-- 从什么变到什么 --&gt;<span class="hljs-selector-tag">from</span> &#123;&#125;  <span class="hljs-selector-tag">to</span> &#123;&#125;  //or  百分比&#125;</code></pre></div><h3 id="src-和-href-的区别"><a href="#src-和-href-的区别" class="headerlink" title="src 和 href 的区别"></a>src 和 href 的区别</h3><p><code>src</code>是指向外部资源的位置，指向的内容会嵌入到文档中当前标签所在的位置，在请求 src 资源时会将其指向的资源下载并应用到文档内，如 js 脚本，img 图片和 frame 等元素。<strong>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，所以一般 js 脚本会放在底部而不是头部。</strong></p><p><code>href</code>是指网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。</p><h3 id="样式重置"><a href="#样式重置" class="headerlink" title="样式重置"></a>样式重置</h3><p>HTML 中绝大部分标签元素在网页显示中都有一个默认属性值，通常为了避免重复定义元素样式，需要进行重置默认样式，让众多浏览器的效果达到一致</p><h3 id="严格模式和混杂模式"><a href="#严格模式和混杂模式" class="headerlink" title="严格模式和混杂模式"></a>严格模式和混杂模式</h3><ul><li>严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。</li><li>混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以 防止站点无法工作</li></ul><h3 id="超链接访问过后-hover-样式就不出现了"><a href="#超链接访问过后-hover-样式就不出现了" class="headerlink" title="超链接访问过后 hover 样式就不出现了"></a>超链接访问过后 hover 样式就不出现了</h3><p>被点击访问过的超链接样式不在具有 hover 和 active 了解决方法是改变 CSS 属性排列顺序: <code>L-V-H-A</code></p><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;&#125;<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;&#125;<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;&#125;<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code><pre><code class="hljs css">    <span class="hljs-selector-tag">span</span>&#123;  <span class="hljs-attribute">position</span>: absolute;  <span class="hljs-attribute">top</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">left</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">border-top</span>:<span class="hljs-number">50px</span> red solid;  <span class="hljs-attribute">border-left</span>:<span class="hljs-number">50px</span> white solid;  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> white solid;  &lt;!-- 一样粗的边框在边角会以<span class="hljs-number">45</span>度分割 --&gt;&#125;</code></pre></div></code></pre><h3 id="画圆和椭圆"><a href="#画圆和椭圆" class="headerlink" title="画圆和椭圆"></a>画圆和椭圆</h3><ul><li><code>border-radius属性</code></li><li>boder-radius 是简写属性<ul><li>border-top-left-radius</li><li>border-top-right-radius</li><li>border-bottom-right-radius</li><li>border-botom-left-radius</li><li>top 左右，bottom 右左，顺时针</li><li>还可以分别设置水平和垂直方向的半径，用 “/“隔开</li></ul></li><li>```css<!--半椭圆-->width: 100px;height: 0;<br>border-style: solid;<br>border-color: #f00;<br>border-radius: 50%/100% 100% 0 0 <!-- 水平部分半径/垂直部分半径 -->;<div class="hljs code-wrapper"><pre><code class="hljs xml">- `canvcas`  ```html  <span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;context&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">let</span> c = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;context&quot;</span>);</span><span class="javascript">    <span class="hljs-keyword">let</span> ctx = c.getContext(<span class="hljs-string">&quot;2d&quot;</span>);</span><span class="javascript">    ctx.strokeStyle = <span class="hljs-string">&quot;red&quot;</span>;</span><span class="javascript">    ctx.arc(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI);</span>    ctx.stroke();  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div></li></ul><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><blockquote><p>概念<br>html 文档中的每个元素都被描绘成矩形盒子，这些矩形盒子通过一个模型来描述其占用空间，这个模型称为盒模型。盒模型通过四个边界来描述：<code>margin</code>（外边距），<code>border</code>（边框），<code>padding</code>（内边距），<code>content</code>（内容区域</p></blockquote><h3 id="行内元素和块级元素"><a href="#行内元素和块级元素" class="headerlink" title="行内元素和块级元素"></a>行内元素和块级元素</h3><h4 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h4><p><code>display inline</code></p><ol><li><p>和其他元素在同一行内</p></li><li><p>行内元素不能设置 width、height、margin、padding</p></li><li><p>默认高度和宽度就是内容的高度和宽度</p></li><li><p>可以设置 margin-left 和 margin-right 属性，无法设置 margin-top 和 margin-bottom 属性</p></li><li><p>border 和 padding 可以设置，但是 border-top 和 padding-top 到页面顶部后就不再增加</p></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript">img; <span class="hljs-comment">//可以设置宽高</span>span;lable;strong;a;input; <span class="hljs-comment">//可以设置宽高</span>select; <span class="hljs-comment">//可以设置宽高</span>textarea; <span class="hljs-comment">//可以设置宽高</span></code></pre></div><h4 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h4><p><code>display block</code></p><ol><li><p>独占一行</p></li><li><p>可以设置 width，height，margin，padding，border 属性</p></li><li><p>默认宽度是容器的 100%</p></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript">artical; <span class="hljs-comment">// h5</span>div;header; <span class="hljs-comment">// h5</span>section; <span class="hljs-comment">// h5</span>adress; <span class="hljs-comment">// h5</span>ol;ul;aside; <span class="hljs-comment">// h5</span>footer; <span class="hljs-comment">// h5</span>audio; <span class="hljs-comment">// h5</span>video; <span class="hljs-comment">// h5</span>canvas; <span class="hljs-comment">// h5</span>hgroup; <span class="hljs-comment">// h5</span>p;h1 - h6;table;form;</code></pre></div><ul><li>行内块级元素<br><code>display line-block</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 兼容</span>div &#123;    display： inline-block；    zoom： <span class="hljs-number">1</span>；   <span class="hljs-comment">//在IE下触发hasLayout</span>    display：inline；<span class="hljs-comment">//一旦触发了hasLayout设置display：inline和display：block效果相似。</span>&#125;</code></pre></div><ol><li>不自动换行</li><li>识别宽高</li><li>左向右排列</li></ol><h3 id="解析一下优雅降级和渐进增强"><a href="#解析一下优雅降级和渐进增强" class="headerlink" title="解析一下优雅降级和渐进增强"></a>解析一下优雅降级和渐进增强</h3><p>_优雅降级_：Web 站点在所有新式浏览器中都能正常工作，如果用户使用的是旧式浏览器，则代码会针对旧版本的 IE 进行降级处理，使之在旧式浏览器上以某种形式降级体验而不至于完全不能使用。</p><p>_渐进增强_：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能，向页面增加不影响基础浏览器的额外样式和功能。当浏览器支持时，它们会自定地呈现出来并发挥作用。</p><h3 id="常见空-VOID-元素"><a href="#常见空-VOID-元素" class="headerlink" title="常见空 VOID 元素"></a>常见空 VOID 元素</h3><p><code>br、hr、img、input、link、meta</code></p><h3 id="window-onload-和-DOMContentLoaded-的区别"><a href="#window-onload-和-DOMContentLoaded-的区别" class="headerlink" title="window.onload 和 DOMContentLoaded 的区别"></a>window.onload 和 DOMContentLoaded 的区别</h3><p><code>window.onload</code>页面的全部资源加载完<br><code>DOMContentLoaded</code>纯html加载完</p><h3 id="visibilityState-有哪些用途"><a href="#visibilityState-有哪些用途" class="headerlink" title="visibilityState 有哪些用途"></a>visibilityState 有哪些用途</h3><p>通过<code>visibilityState</code>的值检测页面当前是否可见，以及打开页面的时间等<br>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放</p><h3 id="标准模型和-IE-模型"><a href="#标准模型和-IE-模型" class="headerlink" title="标准模型和 IE 模型"></a>标准模型和 IE 模型</h3><ul><li>通过[box-sizing]设置</li><li>标准模型[content-box]的宽和高只计算 content 部分</li><li>ie 模型[border-box]的宽高包括 padding 和 border</li></ul><h3 id="获取-DOM-元素的-style"><a href="#获取-DOM-元素的-style" class="headerlink" title="获取 DOM 元素的 style"></a>获取 DOM 元素的 style</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">1.</span> dom.style.width/height<span class="hljs-comment">// content 只能获取内联样式</span><span class="hljs-number">2.</span> dom.currentStyle.width/height<span class="hljs-comment">// 只支持ie</span><span class="hljs-number">3.</span> <span class="hljs-built_in">window</span>.getComputedStyle(ele).width/height<span class="hljs-comment">// content</span><span class="hljs-number">5.</span> ele.offsetWidth/offsetHeight<span class="hljs-comment">// content+padding+border+滚动条</span><span class="hljs-number">6.</span> ele.clientWidth/clientHeight<span class="hljs-comment">// content+padding 不含滚动条</span><span class="hljs-number">7.</span> ele.scrollTop/ele.scrollLeft<span class="hljs-comment">// 滚动像素数</span></code></pre></div><h3 id="边距重叠"><a href="#边距重叠" class="headerlink" title="边距重叠"></a>边距重叠</h3><p>两个或多个块级盒子的!!垂直!!相邻边界会重合，它们的边界宽度是相邻边界宽度中的最大值。<br>特别注意内容为空的盒子。</p><h2 id="BFC-Block-Formatting-Context-块级格式化上下文"><a href="#BFC-Block-Formatting-Context-块级格式化上下文" class="headerlink" title="BFC/Block Formatting Context 块级格式化上下文"></a>BFC/Block Formatting Context 块级格式化上下文</h2><ul><li>三种文档流，常规/浮动（环绕常规流）/绝对定位（脱离常规流）</li><li>BFC就是常规流中一个决定块级盒子布局及浮动相互影响的一个区域<ul><li>内部盒子竖着排列</li><li>子元素不会超过包含他的块边界</li><li>浮动子元素参与BFC高度计算</li><li>BFC区域不会与浮动区域重叠</li><li>子元素的左边缘会与BFC的左边缘重合</li></ul></li></ul><p>下列方式会创建BFC：</p><ul><li>根元素<code>html</code></li><li>浮动元素（元素的 <code>float</code> 不是 <code>none</code>）</li><li>定位元素（元素的 <code>position</code> 为 <code>absolute</code> 或 <code>fixed</code></li><li><code>overflow</code> 值不为 <code>visible</code> 的块元素</li><li><code>display</code> 值为 <code>flow-root</code> 的元素</li><li>行内块元素（元素的 <code>display</code> 为 <code>inline-block</code></li><li>弹性元素（<code>display</code> 为 <code>flex</code> 或 <code>inline-flex</code> 元素的直接子元素）</li><li>网格元素（<code>display</code> 为 <code>grid</code> 或 <code>inline-grid</code> 元素的直接子元素）</li><li>表格有关（<code>display</code> 为 <code>table-xx?</code>）</li></ul><p>[MDN] <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context</a> “块格式化上下文”</p><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><h3 id="用父元素伪类清除浮动"><a href="#用父元素伪类清除浮动" class="headerlink" title="用父元素伪类清除浮动"></a>用父元素伪类清除浮动</h3><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 通用 */</span><span class="hljs-selector-class">.clearfather</span>:after &#123;  content: <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-attribute">clear</span>: both;  <span class="hljs-attribute">display</span>: block;  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">overflow</span>: hidden;  <span class="hljs-attribute">visibility</span>: hidden;&#125;<span class="hljs-selector-class">.clearfather</span> &#123;  *zoom: <span class="hljs-number">1</span>; <span class="hljs-comment">/* ie6/7 */</span>&#125;</code></pre></div><h3 id="最后面加入一个空-div-清除浮动"><a href="#最后面加入一个空-div-清除浮动" class="headerlink" title="最后面加入一个空 div 清除浮动"></a>最后面加入一个空 div 清除浮动</h3><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfloat</span> &#123;  <span class="hljs-attribute">clear</span>: both;&#125;</code></pre></div><h3 id="父元素-BFC"><a href="#父元素-BFC" class="headerlink" title="父元素 BFC"></a>父元素 BFC</h3><p>设置能触发 BFC 的属性均可<br>【同上】</p><ul><li>overflow**<em>不为 visible</em>**==&gt;hidden,auto，scroll 都行</li><li>设置 float 值不为 none</li><li>display = inline-block,flex,inline-flex</li><li>display = table-cell，table-caption</li><li>设置 position**<em>不为默认 static</em>**==&gt;absolute,fixed 都行<ul><li>MDN 安利了<code>display: flow-root</code></li></ul></li></ul><h3 id="页面导入样式时，使用-link-和-import-有什么区别"><a href="#页面导入样式时，使用-link-和-import-有什么区别" class="headerlink" title="页面导入样式时，使用 link 和@import 有什么区别"></a>页面导入样式时，使用 link 和@import 有什么区别</h3><ul><li><p>link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务；@import 属于 CSS 范畴，只能加载 CSS。</p></li><li><p>link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载。</p></li><li><p>link 是 XHTML 标签，无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器（IE5 以下）不支持。</p></li><li><p>link 支持使用 Javascript 控制 DOM 去改变样式；而@import 不支持。</p></li></ul><h3 id="css-动画开启-gpu-加速"><a href="#css-动画开启-gpu-加速" class="headerlink" title="css 动画开启 gpu 加速"></a>css 动画开启 gpu 加速</h3><h4 id="用-CSS3-动画替代-JS-模拟动画的好处"><a href="#用-CSS3-动画替代-JS-模拟动画的好处" class="headerlink" title="用 CSS3 动画替代 JS 模拟动画的好处"></a>用 CSS3 动画替代 JS 模拟动画的好处</h4><ul><li><p>不占用 JS 主线程；</p></li><li><p>可以利用硬件加速；</p></li><li><p>浏览器可对动画做优化（元素不可见时不动画减少对 FPS 影响</p></li></ul><h4 id="使用-GPU-渲染元素"><a href="#使用-GPU-渲染元素" class="headerlink" title="使用 GPU 渲染元素"></a>使用 GPU 渲染元素</h4><p>并不是所有的 CSS 属性都能触发 GPU 的硬件加速，实际上只有少数属性可以，比如下面的这些：</p><ul><li><code>transform</code></li><li><code>opacity</code></li><li><code>filter</code></li></ul><blockquote><p>不会触发重绘</p></blockquote><h4 id="强制使用-GPU-渲染"><a href="#强制使用-GPU-渲染" class="headerlink" title="强制使用 GPU 渲染"></a>强制使用 GPU 渲染</h4><p>为了避免 2D transform 动画在开始和结束时发生的 repaint 操作，我们可以硬编码一些样式来解决这个问题：<br>.example1 {<br>transform: translateZ(0);<br>}</p><p>.example2 {<br>transform: rotateZ(360deg);<br>}</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>html</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>错误监控</title>
    <link href="/2019/04/24/%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/"/>
    <url>/2019/04/24/%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="错误分类"><a href="#错误分类" class="headerlink" title="错误分类"></a>错误分类</h2><ol><li><p>运行时错误：代码书写时造成的，比如语法错误、逻辑错误</p></li><li><p>资源加载错误：找不到文件或者是文件加载超时造成的</p></li></ol><h2 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h2><ol><li><p>运行时错的捕获</p><ul><li><code>try&#123;...&#125;catch&#123;...&#125;</code></li><li><code>windown.onerror</code></li></ul></li></ol><ol start="2"><li><p>资源加载错误</p><ul><li><code>Object.onerror</code></li><li><code>window.addEventListener(&quot;error&quot;,function(e)&#123;console.log(e)//打印出了错误对象&#125;,true)</code>捕获</li><li>高级浏览器中<code>performance.getEntries()</code>可以获取所有已加载资源的加载时长，间接找到加载错误</li></ul></li><li><p>Promise</p><ul><li><code>Promise.then.catch</code></li><li><code>window.addEventListener(&quot;unhandledrejection&quot;,function(e)&#123;...&#125;)</code>捕获Promise异常</li></ul></li><li><p>跨域的JS错误</p><ul><li><p>跨域之后<code>window.onerror</code>是无法捕获异常信息的，所以统一返回<code>script error</code></p></li><li><p>解决方案便是script属性配置 <code>crossorigin=”anonymous”</code> 并且服务器添加<code>Access-Control-Allow-Origin</code></p></li><li><p>如果js被压缩(像webpack)，压缩前开启<code>sourcemap</code>，后解析map追踪错误位置</p></li></ul></li><li><p>MVVM框架自己的错误捕获方法</p></li></ol><h2 id="错误上报"><a href="#错误上报" class="headerlink" title="错误上报"></a>错误上报</h2><ol><li><p>ajax</p></li><li><p>利用image对象</p><p> <code>(new Image()).src = &#39;url? + 错误信息&#39;</code>              </p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面性能</title>
    <link href="/2019/04/23/%E6%8F%90%E5%8D%87%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD/"/>
    <url>/2019/04/23/%E6%8F%90%E5%8D%87%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="资源压缩合并，减少HTTP请求"><a href="#资源压缩合并，减少HTTP请求" class="headerlink" title="资源压缩合并，减少HTTP请求"></a>资源压缩合并，减少HTTP请求</h2><ul><li>css,html,js压缩合并</li><li><code>htm-minifier</code></li><li><code>uglifyjs2</code></li></ul><h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> imgList = [...document.querySelectAll(<span class="hljs-string">&#x27;img&#x27;</span>)]<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyLoad</span>(<span class="hljs-params">imgList</span>)</span>&#123;  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>  <span class="hljs-keyword">const</span> len = imgList.length  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">let</span> doneList = []    imgList.forEach(<span class="hljs-function">(<span class="hljs-params">img,index</span>)=&gt;</span>&#123;      <span class="hljs-keyword">const</span> react = img.getBoundingClientRect()      <span class="hljs-comment">// Element.getBoundingClientRect() 方法返回元素的大小及其相对于视口的位置</span>      <span class="hljs-comment">// 返回值是一个 DOMRect 对象，这个对象是由该元素的 getClientRects() 方法返回的一组矩形的集合，就是该元素的 CSS 边框大小。返回的结果是包含完整元素的最小矩形，并且拥有left, top, right, bottom, x, y, width, 和 height这几个以像素为单位的只读属性用于描述整个边框。</span>      <span class="hljs-keyword">if</span>(react.top&lt;<span class="hljs-built_in">window</span>.innerHeight)&#123;        img.src = img.dataset.src        doneList.push(index)        count++        <span class="hljs-keyword">if</span>(count === len)&#123;          <span class="hljs-built_in">document</span>.removeEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>,lazyLoad)        &#125;      &#125;    &#125;)    imgList = imgList.filter(<span class="hljs-function">(<span class="hljs-params">img,index</span>)=&gt;</span>!doneList.includes(i))  &#125;&#125;<span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>,debounce(lazyLoad))<span class="hljs-comment">// 加上节流</span></code></pre></div><h2 id="非核心代码异步加载"><a href="#非核心代码异步加载" class="headerlink" title="非核心代码异步加载"></a>非核心代码异步加载</h2><ul><li><p>异步加载的方式</p><ol><li>动态创建script标签，window.onload加入页面</li><li>script<code>defer</code></li><li>script<code>async</code></li></ol></li><li><p>script/script async/script defer的区别</p><ul><li>普通的<code>script</code>，html解析暂停，立即下载和执行这个脚本</li><li><code>&lt;script async&gt;</code>，html解析和该脚本的加载同时进行，下载完后执行脚本时暂停html解析</li><li><code>&lt;script defer&gt;</code>，html解析和该脚本的加载同时进行，脚本在页面解析完成后才执行</li></ul><p>  <img src="../images/script.png" alt="script"></p></li></ul><ul><li><p><code>link</code>和<code>@import</code>和<code>src</code></p><ol><li><code>src</code>指向外部资源的位置，该资源会被嵌入src所在位置，浏览器会在此处暂停其他资源的下载</li><li><code>link</code>引入css，icon，定义RSS等。与页面加载同时进行。</li><li><code>@import</code>只能引入样式表。页面加载完后才下载。可能会有兼容问题<h2 id="利用浏览器缓存"><a href="#利用浏览器缓存" class="headerlink" title="利用浏览器缓存"></a>利用浏览器缓存</h2><h2 id="使用CDN加速资源"><a href="#使用CDN加速资源" class="headerlink" title="使用CDN加速资源"></a>使用CDN加速资源</h2></li></ol></li></ul><p>CDN的全称是<code>Content Delivery Network</code>，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率</p><h2 id="预解析DNS"><a href="#预解析DNS" class="headerlink" title="预解析DNS"></a>预解析DNS</h2><p><code>DNS Prefetch</code> 是一种DNS 预解析技术，当浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在单击当前网页中的连接时就无需进行DNS的解析，减少用户等待时间，提高用户体验。</p><ol><li><p>http中浏览器会对a标签自动开启dns预解析</p></li><li><p>https用meta信息来告知浏览器, 当前页面要做DNS预解析:</p></li></ol><blockquote><p>对于https页面，大部分浏览器是关闭a标签的dns预解析的</p></blockquote><p><code>&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;</code></p><ol start="2"><li>在页面header中使用link标签来强制对DNS预解析:</li></ol><p><code> &lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://bdimg.share.baidu.com&quot; /&gt;</code></p><h2 id="预渲染和服务端渲染"><a href="#预渲染和服务端渲染" class="headerlink" title="预渲染和服务端渲染"></a>预渲染和服务端渲染</h2><ul><li><code>SSR:server side render</code></li><li><code>prerender-spa-plugin</code>不适用于个性化的，内容变化大，多路由的页面<br>可以用来优化单页应用</li></ul><h2 id="前端涉及的数据存储"><a href="#前端涉及的数据存储" class="headerlink" title="前端涉及的数据存储"></a>前端涉及的数据存储</h2><ul><li><p><code>LocalStorage</code></p><ul><li><p>不会过期</p></li><li><p>数据大小5MB</p></li><li><p>浏览器中共享</p></li><li><p>同源共享同一份<code>localStorage</code></p></li><li><p>只能为<code>string</code>类型,注意需要<code>JSON</code>转换</p></li></ul></li><li><p>SessionStorage</p><ul><li><p>窗口/标签页关闭时清理</p></li><li><p>数据大小5MB</p></li></ul></li><li><p>Cookie</p><ul><li><p>由服务器设置过期时间</p></li><li><p>数据大小 4KB</p></li><li><p>参与每次http请求</p></li><li><p>有路径概念，可以限制不同路径下的 cookie 互相是访问不到的</p></li></ul></li><li><p>IndexDB</p><ul><li><p>除非被清理否则一直存在</p></li><li><p>数据大小无限制</p></li><li><p>IndexedDB是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB  允许储存大量数据，提供查找接口，还能建立索引。</p></li></ul></li></ul><h2 id="浏览器多个标签页之间的通信"><a href="#浏览器多个标签页之间的通信" class="headerlink" title="浏览器多个标签页之间的通信"></a>浏览器多个标签页之间的通信</h2><h3 id="使用localStorage"><a href="#使用localStorage" class="headerlink" title="使用localStorage"></a>使用localStorage</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// &lt;!-- 标签页1： --&gt; </span>    $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        $(<span class="hljs-string">&quot;#btn&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;           <span class="hljs-keyword">var</span> name=$(<span class="hljs-string">&quot;#name&quot;</span>).val();            <span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&quot;name&quot;</span>, name); <span class="hljs-comment">//存储需要的信息 </span>        &#125;);   &#125;);<span class="hljs-comment">// &lt;!-- 标签页2： --&gt;</span>$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;storage&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>&#123;   <span class="hljs-built_in">console</span>.log(event.key + <span class="hljs-string">&quot;=&quot;</span> + event.newValue);    &#125;);     <span class="hljs-comment">//使用storage事件监听添加、修改、删除的动作  </span>&#125;);</code></pre></div><h3 id="使用cookie"><a href="#使用cookie" class="headerlink" title="使用cookie"></a>使用cookie</h3><p>将要传递的信息存储在cookie中，定时读取cookie</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 标签页1：</span>$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        $(<span class="hljs-string">&quot;#btn&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-keyword">var</span> name=$(<span class="hljs-string">&quot;#name&quot;</span>).val();            <span class="hljs-built_in">document</span>.cookie=<span class="hljs-string">&quot;name=&quot;</span>+name;        &#125;);    &#125;);<span class="hljs-comment">// 标签页2：</span> $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCookie</span>(<span class="hljs-params">key</span>) </span>&#123;       <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&quot;&#123;\&quot;&quot;</span> + <span class="hljs-built_in">document</span>.cookie.replace(<span class="hljs-regexp">/;\s+/gim</span>,<span class="hljs-string">&quot;\&quot;,\&quot;&quot;</span>).replace(<span class="hljs-regexp">/=/gim</span>, <span class="hljs-string">&quot;\&quot;:\&quot;&quot;</span>) + <span class="hljs-string">&quot;\&quot;&#125;&quot;</span>)[key];    &#125;     <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;name=&quot;</span> + getCookie(<span class="hljs-string">&quot;name&quot;</span>));    &#125;, <span class="hljs-number">10000</span>);    &#125;);</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js运行机制</title>
    <link href="/2019/04/23/JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <url>/2019/04/23/JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/10714ad38f9a">ref:javascript 运行机制 EventLoop</a></p><h2 id="JS的单线程"><a href="#JS的单线程" class="headerlink" title="JS的单线程"></a>JS的单线程</h2><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。</p><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><ul><li><p>概括：主线程不断从任务队列读取任务进入执行栈执行的循环过程</p></li><li><p>因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。如果遇到了异步任务，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。</p></li><li><p>任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务队列中的任务。</p></li><li><p>事件循环的运行</p><ol><li>循环开始，整体函数script推入执行栈</li><li>执行执行栈中同步函数</li><li>遇到异步函数将其回调分别加入<em>宏任务队列</em>和<em>微任务队列</em></li><li>执行栈为空后（同步函数执行完），查看任务队列里微任务推入执行栈执行</li><li>执行完后，读取宏任务进入执行栈执行</li><li>执行该宏任务，如果该宏任务继续产生微任务则执行完微任务才能继续往下执行<br>blahblahblah。。。</li></ol></li></ul><h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><ul><li>setTimeout/setInterval<blockquote><p>需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行</p></blockquote><ul><li>DOM事件(onclick,onload)</li><li>Promise</li></ul></li></ul><h2 id="微任务-宏任务"><a href="#微任务-宏任务" class="headerlink" title="微任务/宏任务"></a>微任务/宏任务</h2><ul><li><p>不同的异步任务被分为两类：微任务（<code>micro task</code>）和宏任务（<code>macro task</code>）</p></li><li><p>JS的事件循环中每个宏任务称为一个<code>Tick</code>(标记)，在每个标记的末尾会追加一个微任务队列，一个宏任务执行完后会执行所有的微任务，直到队列清空。</p></li><li><p>微任务包括 <code>process.nextTick</code> ，<code>promise.then</code> ，<code>catch</code>,<code>finally</code> ，<code>MutationObserver</code></p><ul><li>！遇到<code>nextTick</code>会提到微任务的栈顶</li></ul></li><li><p>宏任务包括 <code>整体代码script</code> ， <code>setTimeout</code> ，<code>setInterval</code> ，<code>setImmediate</code> ，<code>I/O</code>操作 ，<code>UI</code>渲染</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// js执行顺序</span><span class="hljs-comment">// 1</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;script start&quot;</span>);  <span class="hljs-comment">// 1</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;setTimeout&quot;</span>);<span class="hljs-comment">// 4</span>&#125;, <span class="hljs-number">0</span>);<span class="hljs-built_in">Promise</span>.resolve()  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise1&quot;</span>);<span class="hljs-comment">//2</span>  &#125;)  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise2&quot;</span>);<span class="hljs-comment">//3</span>  &#125;);<span class="hljs-comment">// 2</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//1</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span>);<span class="hljs-comment">// 5</span>  process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3&quot;</span>);<span class="hljs-comment">//7</span>  &#125;);  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;4&quot;</span>);<span class="hljs-comment">//6</span>    resolve();  &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;5&quot;</span>);<span class="hljs-comment">//8</span>  &#125;);&#125;);process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;6&quot;</span>); <span class="hljs-comment">//3</span>&#125;);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;7&quot;</span>); <span class="hljs-comment">//2</span>  resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;8&quot;</span>); <span class="hljs-comment">//4</span>&#125;);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;9&quot;</span>); <span class="hljs-comment">//9</span>  process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;10&quot;</span>); <span class="hljs-comment">//11</span>  &#125;);  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;11&quot;</span>); <span class="hljs-comment">//10</span>    resolve();  &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;12&quot;</span>);  &#125;);<span class="hljs-comment">//12</span>&#125;);<span class="hljs-comment">// 3</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>) <span class="hljs-comment">//1</span>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<span class="hljs-comment">//2</span>  &#125;)  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;异步3&#x27;</span>)<span class="hljs-comment">//6</span>  &#125;)  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;同步3&#x27;</span>)<span class="hljs-comment">//3</span>&#125;<span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">()=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)<span class="hljs-comment">//5</span>&#125;)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>)<span class="hljs-comment">//7</span>&#125;)async1()<span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>)<span class="hljs-comment">//4</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js面试题</title>
    <link href="/2019/04/22/js%E9%9D%A2%E8%AF%95/"/>
    <url>/2019/04/22/js%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><ul><li><p>&lt;冒泡排序&gt; O(n^2)</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">const</span> len = arr.length;  <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++) &#123;      <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;        [arr[j], arr[j + <span class="hljs-number">1</span>]] = [arr[j + <span class="hljs-number">1</span>], arr[j]];        flag = <span class="hljs-literal">true</span>;      &#125;    &#125;    <span class="hljs-keyword">if</span> (!flag) <span class="hljs-keyword">break</span>;  &#125;  <span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-comment">// 例如从小到大排序</span><span class="hljs-comment">// 每次循环结束都将把该次循环范围内的最大值移动到最右边</span></code></pre></div></li><li><p>&lt;插入排序&gt; O(n^2)</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> insertionSort = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> len = arr.length;  <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span> ; i&lt; len i++)&#123;    <span class="hljs-keyword">let</span> temp = arr[i]    <span class="hljs-keyword">let</span> j = i - <span class="hljs-number">1</span>    <span class="hljs-comment">// i左边理解为有序数组，已经排序过的</span>    <span class="hljs-comment">// 取出arr[i]插入到i之前数组中</span>    <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; temp)&#123;      <span class="hljs-comment">// 找出合理位置</span>      <span class="hljs-comment">// 数组整体后移</span>      arr[j+<span class="hljs-number">1</span>] = arr[j]      j--    &#125;    <span class="hljs-comment">// 之前结束循环后j-1了</span>    <span class="hljs-comment">// 这里加上</span>    arr[j+<span class="hljs-number">1</span>] = temp  &#125;  <span class="hljs-keyword">return</span> arr&#125;</code></pre></div><ul><li><p>&lt;希尔排序&gt; 动态定义了区间的选择排序 O(n log^2 n)</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shellSort</span>(<span class="hljs-params">arr, gap = <span class="hljs-number">3</span></span>) </span>&#123;  <span class="hljs-keyword">const</span> len = arr.length;  <span class="hljs-keyword">let</span> n = <span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span> (n &lt; len / gap) &#123;    n = n * gap + <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">for</span> (; n &gt; <span class="hljs-number">0</span>; n = <span class="hljs-built_in">Math</span>.floor(n / gap)) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = n; i &lt; len; i++) &#123;      <span class="hljs-keyword">let</span> temp = arr[i];      <span class="hljs-keyword">let</span> j = i - n;      <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;        arr[j + n] = arr[j];        j -= n;      &#125;      arr[j + n] = temp;    &#125;  &#125;  <span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-comment">// 使用位运算得到动态区间</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shellSort2</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">let</span> len = arr.length;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> gap = len &gt;&gt; <span class="hljs-number">1</span>; gap &gt; <span class="hljs-number">0</span>; gap &gt;&gt;= <span class="hljs-number">1</span>) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = gap; i &lt; len; i++) &#123;      <span class="hljs-keyword">let</span> j;      <span class="hljs-keyword">let</span> temp = arr[i];      <span class="hljs-keyword">for</span> (j = i - gap; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;        arr[j + gap] = arr[j];      &#125;      arr[j + <span class="hljs-number">1</span>] = temp;    &#125;  &#125;  <span class="hljs-keyword">return</span> arr&#125;</code></pre></div></li></ul></li><li><p>&lt;选择排序&gt; O(n^2)</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectionSort</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">var</span> len = arr.length;  <span class="hljs-keyword">var</span> minIndex;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;    minIndex = i;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;      <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;        <span class="hljs-comment">// 寻找最小的数</span>        minIndex = j; <span class="hljs-comment">// 将最小数的索引保存</span>      &#125;    &#125;    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];  &#125;  <span class="hljs-keyword">return</span> arr;&#125;</code></pre></div></li><li><p>&lt;快速排序&gt; 时间复杂度 平均 O(n log n) 最坏 O(n^2)</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> quickSort = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">if</span> (arr.length &lt; <span class="hljs-number">2</span>) &#123;    <span class="hljs-keyword">return</span> arr;  &#125; <span class="hljs-comment">//一直排序到区间内只有一个数</span>  <span class="hljs-keyword">var</span> pivotIndex = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>); <span class="hljs-comment">//基准位置（可任意选取）</span>  <span class="hljs-keyword">var</span> pivot = arr.splice(pivotIndex, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]; <span class="hljs-comment">//找出基准数并把它从原数组删除</span>  <span class="hljs-comment">// splice()</span>  <span class="hljs-comment">// arrayObject.splice(index,howmany,item1,.....,itemX)</span>  <span class="hljs-comment">// splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。</span>  <span class="hljs-comment">// 如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。</span>  <span class="hljs-keyword">var</span> left = [];  <span class="hljs-keyword">var</span> right = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;    <span class="hljs-keyword">if</span> (arr[i] &lt; pivot) &#123;      left.push(arr[i]);    &#125; <span class="hljs-keyword">else</span> &#123;      right.push(arr[i]);    &#125;  &#125;  <span class="hljs-keyword">return</span> [...quickSort(left), pivot, ...quickSort(right)]; <span class="hljs-comment">//链接左数组、基准数构成的数组、右数组</span>  <span class="hljs-comment">// concat() 方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。</span>&#125;;<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">22</span>, <span class="hljs-number">5235</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">21</span>, <span class="hljs-number">90</span>];<span class="hljs-built_in">console</span>.log(quickSort(arr)); <span class="hljs-comment">//(7) [1, 3, 6, 21, 22, 90, 5235]</span><span class="hljs-comment">// 三路块排</span><span class="hljs-comment">// 小于pivot，等于 pivot 和大于 pivot</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort3</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">const</span> len = arr.length;  <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) &#123;    <span class="hljs-keyword">return</span> arr;  &#125;  <span class="hljs-keyword">let</span> left = [],    center = [],    right = [],    pivot = arr[<span class="hljs-number">0</span>];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;    <span class="hljs-keyword">if</span> (arr[i] &lt; pivot) &#123;      left.push(arr[i]);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] === pivot) &#123;      center.push(arr[i]);    &#125; <span class="hljs-keyword">else</span> &#123;      right.push(arr[i]);    &#125;  &#125;  <span class="hljs-keyword">return</span> [...quickSort3(left), ...center, ...quickSort3(right)];&#125;</code></pre></div></li><li><p>&lt;希尔排序&gt; 平均 O(n log^2 n) 最坏 O(n^2)</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shellSort</span>(<span class="hljs-params">arr, gap</span>) </span>&#123;  <span class="hljs-comment">//gap为设置的间隔，原始的插入排序相当于gap为1</span>  <span class="hljs-keyword">const</span> len = arr.length;  <span class="hljs-keyword">let</span> n = <span class="hljs-number">1</span>,    temp,    j;  <span class="hljs-keyword">while</span> (n &lt; len / gap) &#123;    n = n * gap + <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">for</span> (n; n &gt; <span class="hljs-number">0</span>; n = <span class="hljs-built_in">Math</span>.floor(n / gap)) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = n; i &lt; len; i++) &#123;      temp = arr[i];      j = i - n;      <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;        arr[j + n] = arr[j];        j -= n;      &#125;      arr[j + n] = temp;    &#125;  &#125;  <span class="hljs-keyword">return</span> arr;&#125;</code></pre></div></li></ul><h2 id="堆栈-队列-链表"><a href="#堆栈-队列-链表" class="headerlink" title="堆栈 队列 链表"></a>堆栈 队列 链表</h2><p><a href="http://huang303513.github.io/2016/12/08/Javascript%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(%E4%B8%80).html">-&gt;&gt;&gt;&gt;REF</a></p><ul><li><p>堆栈</p><ul><li>迭代器函数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> isEven = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;  <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;&#125;;<span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>];<span class="hljs-comment">//every方法会迭代数组中的每个元素,直到返回false。</span><span class="hljs-keyword">var</span> result = numbers.every(isEven);<span class="hljs-built_in">console</span>.log(result); <span class="hljs-comment">//false</span><span class="hljs-comment">//some方法会迭代数组的每个元 素,直到函数返回true.</span>result = numbers.some(isEven);<span class="hljs-built_in">console</span>.log(result); <span class="hljs-comment">//true</span><span class="hljs-comment">//forEach对每一项运行给定的函数，没有返回值</span>numbers.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, index</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);&#125;);<span class="hljs-comment">//map会迭代数组中的每个值，并且返回迭代结果</span><span class="hljs-keyword">var</span> myMap = numbers.map(isEven);<span class="hljs-built_in">console</span>.log(myMap); <span class="hljs-comment">// [false, true, false, true, false, true, false, true, false, true, false, true, false, true, false]</span><span class="hljs-comment">//filter方法返回的新数组由使函数返回true的元素组成</span><span class="hljs-keyword">var</span> myFilter = numbers.filter(isEven);<span class="hljs-built_in">console</span>.log(myFilter); <span class="hljs-comment">// [2, 4, 6, 8, 10, 12, 14]</span><span class="hljs-comment">//reduce函数</span><span class="hljs-keyword">var</span> myReduce = numbers.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">previous, current, index</span>) </span>&#123;  <span class="hljs-keyword">return</span> previous + <span class="hljs-string">&quot;&quot;</span> + current;&#125;);<span class="hljs-built_in">console</span>.log(myReduce); <span class="hljs-comment">//123456789101112131415</span></code></pre></div><ul><li>栈</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Stack</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">this</span>.items = [];&#125;Stack.prototype = &#123;  <span class="hljs-title">constructor</span>: <span class="hljs-title">Stack</span>,  <span class="hljs-title">push</span>: <span class="hljs-title">function</span> (<span class="hljs-params">element</span>) &#123;    <span class="hljs-built_in">this</span>.items.push(element);  &#125;,  pop: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.pop();  &#125;,  peek: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items[<span class="hljs-built_in">this</span>.items.length - <span class="hljs-number">1</span>];  &#125;,  isEmpty: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length == <span class="hljs-number">0</span>;  &#125;,  clear: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.items = [];  &#125;,  size: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length;  &#125;,  print: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.items.toString());  &#125;,&#125;;<span class="hljs-comment">// 栈的基本操作</span><span class="hljs-keyword">var</span> stack = <span class="hljs-keyword">new</span> Stack();<span class="hljs-built_in">console</span>.log(stack.isEmpty()); <span class="hljs-comment">//true</span>stack.push(<span class="hljs-number">5</span>);stack.push(<span class="hljs-number">8</span>);<span class="hljs-built_in">console</span>.log(stack.peek()); <span class="hljs-comment">//8</span>stack.push(<span class="hljs-number">11</span>);<span class="hljs-built_in">console</span>.log(stack.size()); <span class="hljs-comment">//3</span><span class="hljs-built_in">console</span>.log(stack.isEmpty());stack.push(<span class="hljs-number">15</span>);stack.pop(); <span class="hljs-comment">//删除数组中最后一个并返回该元素</span>stack.pop();<span class="hljs-built_in">console</span>.log(stack.size()); <span class="hljs-comment">//2</span><span class="hljs-built_in">console</span>.log(stack.print()); <span class="hljs-comment">//5,8</span><span class="hljs-comment">// 通过栈实现对正整数的二进制转换。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">divideBy2</span>(<span class="hljs-params">decNumber</span>) </span>&#123;  <span class="hljs-keyword">var</span> decStack = <span class="hljs-keyword">new</span> Stack();  <span class="hljs-keyword">var</span> rem;  <span class="hljs-keyword">var</span> decString = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">while</span> (decNumber &gt; <span class="hljs-number">0</span>) &#123;    rem = decNumber % <span class="hljs-number">2</span>; <span class="hljs-comment">//1 //1 //0 //1</span>    decStack.push(rem); <span class="hljs-comment">//[1] //[1,1] //[1,1,0] //[1,1,0,1]</span>    decNumber = <span class="hljs-built_in">Math</span>.floor(decNumber / <span class="hljs-number">2</span>); <span class="hljs-comment">//5 //2 //1 //0</span>  &#125;  <span class="hljs-keyword">while</span> (!decStack.isEmpty()) &#123;    decString += decStack.pop().toString();  &#125;  <span class="hljs-keyword">return</span> decString;&#125;<span class="hljs-built_in">console</span>.log(divideBy2(<span class="hljs-number">11</span>)); <span class="hljs-comment">//1011</span></code></pre></div><ul><li>队列</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Queue</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">this</span>.items = [];&#125;Queue.prototype = &#123;  <span class="hljs-title">constructor</span>: <span class="hljs-title">Queue</span>,  <span class="hljs-title">enqueue</span>: <span class="hljs-title">function</span> (<span class="hljs-params">elements</span>) &#123;    <span class="hljs-built_in">this</span>.items.push(elements);  &#125;,  dequeue: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.shift();  &#125;,  front: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items[<span class="hljs-number">0</span>];  &#125;,  isEmpty: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length == <span class="hljs-number">0</span>;  &#125;,  size: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length;  &#125;,  clear: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.items = [];  &#125;,  print: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.items.toString());  &#125;,&#125;;<span class="hljs-comment">// 队列的基本使用</span><span class="hljs-keyword">var</span> queue = <span class="hljs-keyword">new</span> Queue();<span class="hljs-built_in">console</span>.log(queue.isEmpty()); <span class="hljs-comment">//true</span>queue.enqueue(<span class="hljs-string">&quot;huang&quot;</span>);queue.enqueue(<span class="hljs-string">&quot;cheng&quot;</span>);<span class="hljs-built_in">console</span>.log(queue.print()); <span class="hljs-comment">//huang,cheng</span><span class="hljs-built_in">console</span>.log(queue.size()); <span class="hljs-comment">//2</span><span class="hljs-built_in">console</span>.log(queue.isEmpty()); <span class="hljs-comment">//false</span>queue.enqueue(<span class="hljs-string">&quot;du&quot;</span>);<span class="hljs-built_in">console</span>.log(queue.dequeue()); <span class="hljs-comment">//huang</span><span class="hljs-built_in">console</span>.log(queue.print()); <span class="hljs-comment">//cheng,du</span></code></pre></div><ul><li>链表</li></ul><p>要存储多个元素，数组可能是最常用的数据结构。这种数据结构非常方便，但是有一个缺点：从数组的起点或者中间插入或移除项的成本非常高，因为需要移动元素（比如你插入一个元素后面的所有的元素都移动了“位置”）。</p><p>链表存储有序的元素集合，但是不同于数组，链表中的元素在内存中并不是连续放置的。每个元素都是由一个存储元素本身的节点和一个指向下一元素的引用（也叫指针或者链接）组成。相比于数组来说，链表的好处在于添加或者删除元素的时候不需要移动其他元素。但是操作链表需要使用指针。数组的一个优点是可以直接访问任何位置的任何元素，但是要是想访问链表中的某一元素，则是必须从起点开始迭代直到找到目标元素。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LinkedList</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">element</span>) </span>&#123;    <span class="hljs-built_in">this</span>.element = element;    <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;  &#125;  <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span>;  <span class="hljs-built_in">this</span>.length = <span class="hljs-number">0</span>;  <span class="hljs-comment">//通过对一个方法append判断就可以知道是否设置了prototype</span>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span>.append !== <span class="hljs-string">&quot;function&quot;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span>.append !== <span class="hljs-string">&quot;string&quot;</span>) &#123;    <span class="hljs-comment">//添加元素</span>    LinkedList.prototype.append = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>&#123;      <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> Node(element);      <span class="hljs-keyword">var</span> current;      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.head === <span class="hljs-literal">null</span>) &#123;        <span class="hljs-built_in">this</span>.head = node;      &#125; <span class="hljs-keyword">else</span> &#123;        current = <span class="hljs-built_in">this</span>.head;        <span class="hljs-keyword">while</span> (current.next !== <span class="hljs-literal">null</span>) &#123;          current = current.next;        &#125;        current.next = node;      &#125;      <span class="hljs-built_in">this</span>.length++;    &#125;;    <span class="hljs-comment">//插入元素，成功true，失败false</span>    LinkedList.prototype.insert = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">position, element</span>) </span>&#123;      <span class="hljs-keyword">if</span> (position &gt; -<span class="hljs-number">1</span> &amp;&amp; position &lt; <span class="hljs-built_in">this</span>.length) &#123;        <span class="hljs-keyword">var</span> current = <span class="hljs-built_in">this</span>.head;        <span class="hljs-keyword">var</span> previous;        <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> Node(element);        <span class="hljs-keyword">if</span> (position == <span class="hljs-number">0</span>) &#123;          node.next = current;          <span class="hljs-built_in">this</span>.head = node;        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-keyword">while</span> (index++ &lt; position) &#123;            previous = current;            current = current.next;          &#125;          node.next = current;          previous.next = node;        &#125;        <span class="hljs-built_in">this</span>.length++;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      &#125;    &#125;;    <span class="hljs-comment">//根据位置删除指定元素，成功 返回元素， 失败 返回null</span>    LinkedList.prototype.removeAt = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">position</span>) </span>&#123;      <span class="hljs-keyword">if</span> (position &gt; -<span class="hljs-number">1</span> &amp;&amp; position &lt; <span class="hljs-built_in">this</span>.length) &#123;        <span class="hljs-keyword">var</span> current = <span class="hljs-built_in">this</span>.head;        <span class="hljs-keyword">var</span> previous = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (position == <span class="hljs-number">0</span>) &#123;          <span class="hljs-built_in">this</span>.head = current.next;        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-keyword">while</span> (index++ &lt; position) &#123;            previous = current;            current = current.next;          &#125;          previous.next = current.next;        &#125;        <span class="hljs-built_in">this</span>.length--;        <span class="hljs-keyword">return</span> current.element;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;      &#125;    &#125;;    <span class="hljs-comment">//根据元素删除指定元素，成功 返回元素， 失败 返回null</span>    LinkedList.prototype.remove = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>&#123;      <span class="hljs-keyword">var</span> index = <span class="hljs-built_in">this</span>.indexOf(element);      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.removeAt(index);    &#125;;    <span class="hljs-comment">//返回给定元素的索引，如果没有则返回-1</span>    LinkedList.prototype.indexOf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>&#123;      <span class="hljs-keyword">var</span> current = <span class="hljs-built_in">this</span>.head;      <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;      <span class="hljs-keyword">while</span> (current) &#123;        <span class="hljs-keyword">if</span> (current.element === element) &#123;          <span class="hljs-keyword">return</span> index;        &#125;        index++;        current = current.next;      &#125;      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;;    LinkedList.prototype.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.length === <span class="hljs-number">0</span>;    &#125;;    LinkedList.prototype.size = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.length;    &#125;;    LinkedList.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">var</span> string = <span class="hljs-string">&quot;&quot;</span>;      <span class="hljs-keyword">var</span> current = <span class="hljs-built_in">this</span>.head;      <span class="hljs-keyword">while</span> (current) &#123;        string += current.element;        current = current.next;      &#125;      <span class="hljs-keyword">return</span> string;    &#125;;    LinkedList.prototype.getHead = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.head;    &#125;;  &#125;&#125;<span class="hljs-comment">// 链表的基本使用</span><span class="hljs-keyword">var</span> linkedList = <span class="hljs-keyword">new</span> LinkedList();<span class="hljs-built_in">console</span>.log(linkedList.isEmpty()); <span class="hljs-comment">//true;</span>linkedList.append(<span class="hljs-string">&quot;huang&quot;</span>);linkedList.append(<span class="hljs-string">&quot;du&quot;</span>);linkedList.insert(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;cheng&quot;</span>);<span class="hljs-built_in">console</span>.log(linkedList.toString()); <span class="hljs-comment">//huangchengdu</span><span class="hljs-built_in">console</span>.log(linkedList.indexOf(<span class="hljs-string">&quot;du&quot;</span>)); <span class="hljs-comment">//2</span><span class="hljs-built_in">console</span>.log(linkedList.size()); <span class="hljs-comment">//3</span><span class="hljs-built_in">console</span>.log(linkedList.removeAt(<span class="hljs-number">2</span>)); <span class="hljs-comment">//du</span><span class="hljs-built_in">console</span>.log(linkedList.toString()); <span class="hljs-comment">//huangcheng</span></code></pre></div></li><li><p>双向链表</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//节点</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">element</span>) </span>&#123;  <span class="hljs-built_in">this</span>.element = element; <span class="hljs-comment">//当前节点的元素</span>  <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">//下一个节点链接</span>  <span class="hljs-built_in">this</span>.previous = <span class="hljs-literal">null</span>; <span class="hljs-comment">//上一个节点链接</span>&#125;<span class="hljs-comment">//链表类</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LList</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">this</span>.head = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">&quot;head&quot;</span>);  <span class="hljs-built_in">this</span>.find = find;  <span class="hljs-built_in">this</span>.findLast = findLast;  <span class="hljs-built_in">this</span>.insert = insert;  <span class="hljs-built_in">this</span>.remove = remove;  <span class="hljs-built_in">this</span>.display = display;  <span class="hljs-built_in">this</span>.dispReverse = dispReverse;&#125;<span class="hljs-comment">//查找元素</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params">item</span>) </span>&#123;  <span class="hljs-keyword">var</span> currNode = <span class="hljs-built_in">this</span>.head;  <span class="hljs-keyword">while</span> (currNode.element != item) &#123;    currNode = currNode.next;  &#125;  <span class="hljs-keyword">return</span> currNode;&#125;<span class="hljs-comment">//查找链表中的最后一个元素</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findLast</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">var</span> currNode = <span class="hljs-built_in">this</span>.head;  <span class="hljs-keyword">while</span> (!(currNode.next == <span class="hljs-literal">null</span>)) &#123;    currNode = currNode.next;  &#125;  <span class="hljs-keyword">return</span> currNode;&#125;<span class="hljs-comment">//插入节点</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insert</span>(<span class="hljs-params">newElement, item</span>) </span>&#123;  <span class="hljs-keyword">var</span> newNode = <span class="hljs-keyword">new</span> Node(newElement);  <span class="hljs-keyword">var</span> currNode = <span class="hljs-built_in">this</span>.find(item);  newNode.next = currNode.next;  newNode.previous = currNode;  currNode.next = newNode;&#125;<span class="hljs-comment">//显示链表元素</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">var</span> currNode = <span class="hljs-built_in">this</span>.head;  <span class="hljs-keyword">while</span> (!(currNode.next == <span class="hljs-literal">null</span>)) &#123;    <span class="hljs-built_in">console</span>.debug(currNode.next.element);    currNode = currNode.next;  &#125;&#125;<span class="hljs-comment">//反向显示链表元素</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispReverse</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">var</span> currNode = <span class="hljs-built_in">this</span>.findLast();  <span class="hljs-keyword">while</span> (!(currNode.previous == <span class="hljs-literal">null</span>)) &#123;    <span class="hljs-built_in">console</span>.log(currNode.element);    currNode = currNode.previous;  &#125;&#125;<span class="hljs-comment">//删除节点</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span>(<span class="hljs-params">item</span>) </span>&#123;  <span class="hljs-keyword">var</span> currNode = <span class="hljs-built_in">this</span>.find(item);  <span class="hljs-keyword">if</span> (!(currNode.next == <span class="hljs-literal">null</span>)) &#123;    currNode.previous.next = currNode.next;    currNode.next.previous = currNode.previous;    currNode.next = <span class="hljs-literal">null</span>;    currNode.previous = <span class="hljs-literal">null</span>;  &#125;&#125;<span class="hljs-keyword">var</span> fruits = <span class="hljs-keyword">new</span> LList();fruits.insert(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;head&quot;</span>);fruits.insert(<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>);fruits.insert(<span class="hljs-string">&quot;Pear&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>);fruits.insert(<span class="hljs-string">&quot;Grape&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>);<span class="hljs-built_in">console</span>.log(fruits.display()); <span class="hljs-comment">// Apple</span><span class="hljs-comment">// Banana</span><span class="hljs-comment">// Pear</span><span class="hljs-comment">// Grape</span><span class="hljs-built_in">console</span>.log(fruits.dispReverse()); <span class="hljs-comment">// Grape</span><span class="hljs-comment">// Pear</span><span class="hljs-comment">// Banana</span><span class="hljs-comment">// Apple</span></code></pre></div></li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul><li>递归<br><a href="https://www.jianshu.com/p/e1c0faeca43c">js 中的递归遍历</a></li></ul><h2 id="波兰式和逆波兰式"><a href="#波兰式和逆波兰式" class="headerlink" title="波兰式和逆波兰式"></a>波兰式和逆波兰式</h2><p><a href="https://blog.csdn.net/linraise/article/details/20459751">波兰式、逆波兰式与表达式求值</a></p><h3 id="数组随机排序"><a href="#数组随机排序" class="headerlink" title="数组随机排序"></a>数组随机排序</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//方法一：</span><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randSort</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) &#123;    <span class="hljs-keyword">var</span> rand = <span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">Math</span>.random() * len);    <span class="hljs-keyword">var</span> temp = arr[rand];    arr[rand] = arr[i];    arr[i] = temp;  &#125;  <span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-comment">//方法二：</span><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randSort</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">var</span> mixedArray = [];  <span class="hljs-keyword">while</span> (arr.length &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">var</span> randomIndex = <span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">Math</span>.random() * arr.length);    mixedArray.push(arr[randomIndex]);    arr.splice(randomIndex, <span class="hljs-number">1</span>);  &#125;  <span class="hljs-keyword">return</span> mixedArray;&#125;<span class="hljs-comment">//方法三：</span><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>];arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random() - <span class="hljs-number">0.5</span>;&#125;);</code></pre></div><h3 id="use-strict-严格模式"><a href="#use-strict-严格模式" class="headerlink" title="use strict 严格模式"></a>use strict 严格模式</h3><p>strict 是一种 ES6 添加的（严格）运行模式，这种模式使得 JS 在更严格的条件下运行；</p><ul><li>默认支持的槽糕特性都会被禁用，比如不能使用 with，也不能再意外的情况下给全局变量赋值；</li><li>全局变量的显示声明，函数必须声明在顶层，不允许再非函数代码块内声明函数，arguments.callee 也不允许使用；</li><li>消除代码运行的一些不安全之处，保证代码运行的安全，限制函数中的 arguments 修改，严格模式下的 eval 函数的行为和非严格模式的也不相同。</li></ul><h3 id="js-获取文件扩展名"><a href="#js-获取文件扩展名" class="headerlink" title="js 获取文件扩展名"></a>js 获取文件扩展名</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getExt</span>(<span class="hljs-params">filename</span>) </span>&#123;  <span class="hljs-keyword">return</span> filename.split(<span class="hljs-string">&quot;.&quot;</span>).pop();&#125;<span class="hljs-comment">// 按.分割字符串为数组</span><span class="hljs-comment">// pop删除最后一项并返回</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getExt</span>(<span class="hljs-params">filename</span>) </span>&#123;  <span class="hljs-keyword">return</span> filename.replace(<span class="hljs-regexp">/.+\./</span>, <span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div><h3 id="babel-工作过程"><a href="#babel-工作过程" class="headerlink" title="babel 工作过程"></a>babel 工作过程</h3><p>ES6 代码输入 -&gt; <code>babylon</code>进行解析 -&gt; 得到 AST<br>-&gt; <code>babel-traverse</code>对 AST 树进行遍历转译 -&gt; 得到新的 AST 树<br>-&gt; 用<code>babel-generator</code>通过 AST 树生成 ES5 代码</p><ul><li><code>babylon</code>：js 的词法解析器</li><li><code>babel-traverse</code>：用于对 AST 的遍历</li><li><code>babel-generator</code>：根据 AST 生成代码\</li></ul><h3 id="匿名函数自执行"><a href="#匿名函数自执行" class="headerlink" title="匿名函数自执行"></a>匿名函数自执行</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 直接在匿名函数之后加（）无效</span><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>])&#125;(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<span class="hljs-comment">//加号</span>+<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);&#125;(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//减号</span>-<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);&#125;(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//感叹号</span>!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);&#125;(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//括号</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);&#125;)(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);&#125;(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>));</code></pre></div><h3 id="方法重载和重写"><a href="#方法重载和重写" class="headerlink" title="方法重载和重写"></a>方法重载和重写</h3><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><ul><li><p>同一个类中函数名相同，函数的参数列表不同(包括参数个数和参数类型)，根据参数的不同去执行不同的操作。</p></li><li><p>在 JavaScript 中，同一个作用域，出现两个名字一样的函数，后面的会覆盖前面的，所以 JavaScript 没有真正意义的重载。</p></li></ul><h4 id="重写-覆盖"><a href="#重写-覆盖" class="headerlink" title="重写/覆盖"></a>重写/覆盖</h4><ul><li>子类重写父类方法，方法的名字参数列表都相同</li></ul><h3 id="array-gt-tree"><a href="#array-gt-tree" class="headerlink" title="array-&gt;tree"></a>array-&gt;tree</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 如下数据</span><span class="hljs-keyword">let</span> data = [  &#123;id=<span class="hljs-number">1</span>,pid=<span class="hljs-literal">null</span>,name=<span class="hljs-string">&#x27;no1&#x27;</span>&#125;,  &#123;id=<span class="hljs-number">2</span>,pid=<span class="hljs-number">1</span>,name=<span class="hljs-string">&#x27;no1_1&#x27;</span>&#125;,  &#123;id=<span class="hljs-number">3</span>,pid=<span class="hljs-number">1</span>,name=<span class="hljs-string">&#x27;no1_2&#x27;</span>&#125;,  &#123;id=<span class="hljs-number">4</span>,pid=<span class="hljs-number">2</span>,name=<span class="hljs-string">&#x27;no2_1&#x27;</span>&#125;,  &#123;id=<span class="hljs-number">5</span>,pid=<span class="hljs-number">3</span>,name=<span class="hljs-string">&#x27;no3_1&#x27;</span>&#125;]<span class="hljs-keyword">const</span> tree =<span class="hljs-function">(<span class="hljs-params">list,id=<span class="hljs-literal">null</span>,link=<span class="hljs-string">&#x27;pid&#x27;</span></span>)=&gt;</span>  list  .filter(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item[link]===id)  .map(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>(&#123;...items,<span class="hljs-attr">children</span>:tree(list,item.id)&#125;))</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax</title>
    <link href="/2019/04/16/Ajax/"/>
    <url>/2019/04/16/Ajax/</url>
    
    <content type="html"><![CDATA[<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a><code>Ajax</code></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// example</span><span class="hljs-keyword">const</span> request = <span class="hljs-function">(<span class="hljs-params">method,url,<span class="hljs-keyword">async</span>=<span class="hljs-literal">true</span>,data</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()    xhr.onreadystateChange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.readyState !== <span class="hljs-number">4</span>)<span class="hljs-keyword">return</span>      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.status === <span class="hljs-number">200</span>)&#123;        resolve(<span class="hljs-built_in">this</span>.response)      &#125;<span class="hljs-keyword">else</span>&#123;        reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-built_in">this</span>.statusText))      &#125;    &#125;    xhr.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;      reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;error&#x27;</span>))    &#125;    xhr.responseType = <span class="hljs-string">&#x27;json&#x27;</span>    xhr.setRequestHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)    <span class="hljs-keyword">if</span>(method===<span class="hljs-string">&#x27;GET&#x27;</span>)&#123;      xhr.open(<span class="hljs-string">&quot;GET&quot;</span>,URl+<span class="hljs-string">&#x27;?&#x27;</span>+data,<span class="hljs-literal">true</span>)      xhr.send()    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(method === <span class="hljs-string">&quot; POST&quot;</span>)&#123;      xhr.setRequestHeader(<span class="hljs-string">&quot;Content-type&quot;</span>,<span class="hljs-string">&quot;application/x-www-form-urlencode&quot;</span>)      xhr.send(<span class="hljs-built_in">encodeURIComponent</span>(data))    &#125;  &#125;)&#125;<span class="hljs-comment">//GET</span><span class="hljs-comment">//POST</span>xhr.open(<span class="hljs-string">&quot;POST&quot;</span>,URL,<span class="hljs-literal">true</span>)xhr.setRequestHeader(<span class="hljs-string">&quot;Content-type&quot;</span>,<span class="hljs-string">&quot;application/x-www-form-urlencode&quot;</span>)xhr.send(data)</code></pre></div><h3 id="什么是-AJAX"><a href="#什么是-AJAX" class="headerlink" title="什么是 AJAX"></a>什么是 AJAX</h3><ul><li>Asynchronous JavaScript and XML” –&gt; 异步 JavaScript 和 XML</li><li>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新</li></ul><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getXHR</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">var</span> xhr = <span class="hljs-literal">null</span>;  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.XMLHttpRequest) &#123;    <span class="hljs-comment">// 兼容 IE7+, Firefox, Chrome, Opera, Safari</span>    xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.ActiveXObject) &#123;    <span class="hljs-keyword">try</span> &#123;      xhr = <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">&quot;Msxml2.XMLHTTP&quot;</span>); <span class="hljs-comment">// 即  MSXML3</span>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;      <span class="hljs-keyword">try</span> &#123;        xhr = <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">&quot;Microsoft.XMLHTTP&quot;</span>); <span class="hljs-comment">// /  / 兼容 IE6, IE5，很老的api,虽然浏览器支持,功能可能不完 善,故不建议使用</span>      &#125; <span class="hljs-keyword">catch</span> (e) &#123;        alert(<span class="hljs-string">&quot;您的浏览器暂不支持Ajax!&quot;</span>);      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> xhr;&#125;</code></pre></div><h3 id="原生-js-写法"><a href="#原生-js-写法" class="headerlink" title="原生 js 写法"></a>原生 js 写法</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">XMLHttpRequest.onreadystateChange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">if</span>(XMLHttpRequest.readyState == <span class="hljs-number">4</span> &amp;&amp; XMLHttpRequest.status == <span class="hljs-number">200</span>) &#123;    <span class="hljs-comment">// 请求成功的回调</span>  &#125;&#125;<span class="hljs-comment">// get请求的参数加到URL后 ？</span>XMLHttpRequest.open(<span class="hljs-string">&#x27;请求方法&#x27;</span>,请求url？key=value,是否异步)<span class="hljs-comment">// 若是post请求还要设置请求头</span>XMLHttpRequest.setRequestHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>,<span class="hljs-string">&#x27;app;ication/x-www-form-urlencode&#x27;</span>)<span class="hljs-comment">//</span>XMLHttpRequest.send()</code></pre></div><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>XMLHttpRequest 对象</li><li>Javascript/DOM</li><li>CSS</li><li>XML</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象</title>
    <link href="/2019/04/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2019/04/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>面向对象的设计思想是从自然界中来的，因为在自然界中就存在类（Class）和实例（Instance）的概念。</p><ul><li><p>Class 是一种抽象概念，比如我们定义的 Class——Student ，是指学生这个概念，</p></li><li><p>而实例（Instance）则是一个个具体的 Student ，比如， Michael 和 Bob 是两个具体的 Student 。</p></li><li><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</p></li><li><p>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p></li></ul><h2 id="面向对象三要素"><a href="#面向对象三要素" class="headerlink" title="面向对象三要素"></a>面向对象三要素</h2><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#%E5%B0%81%E8%A3%85">ref:https://github.com/CyC2018</a></p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p><p>优点：</p><ul><li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li><li>减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li><li>有效地调节性能：可以通过剖析确定哪些模块影响了系统的性能<br>提高软件的可重用性</li><li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</span><span class="hljs-comment">// 注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    private <span class="hljs-built_in">String</span> name;    private int gender;    private int age;    public <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    public <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getGender</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> gender == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;man&quot;</span> : <span class="hljs-string">&quot;woman&quot;</span>;    &#125;    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">work</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-number">18</span> &lt;= age &amp;&amp; age &lt;= <span class="hljs-number">50</span>) &#123;            System.out.println(name + <span class="hljs-string">&quot; is working very hard!&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(name + <span class="hljs-string">&quot; can&#x27;t work any more!&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p><ul><li><p>继承应该遵循里氏替换原则，子类对象必须能够替换掉父类对象。</p></li><li><p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型 。</p></li></ul><p><code>Animal animal = new Cat();</code></p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态分为编译时多态和运行时多态：</p><ul><li><p>编译时多态主要指方法的重载</p></li><li><p>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定<br>运行时多态有三个条件：</p><ol><li><p>继承</p></li><li><p>覆盖（重写）</p></li><li><p>向上转型</p></li></ol>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//  下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Instrument</span> </span>&#123;    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">play</span>(<span class="hljs-params"></span>)</span> &#123;        System.out.println(<span class="hljs-string">&quot;Instument is playing...&quot;</span>);    &#125;&#125;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wind</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Instrument</span> </span>&#123;    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">play</span>(<span class="hljs-params"></span>)</span> &#123;        System.out.println(<span class="hljs-string">&quot;Wind is playing...&quot;</span>);    &#125;&#125;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Percussion</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Instrument</span> </span>&#123;    public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">play</span>(<span class="hljs-params"></span>)</span> &#123;        System.out.println(<span class="hljs-string">&quot;Percussion is playing...&quot;</span>);    &#125;&#125;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Music</span> </span>&#123;    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;        List&lt;Instrument&gt; instruments = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        instruments.add(<span class="hljs-keyword">new</span> Wind());        instruments.add(<span class="hljs-keyword">new</span> Percussion());        <span class="hljs-keyword">for</span>(Instrument instrument : instruments) &#123;            instrument.play();        &#125;    &#125;&#125;</code></pre></div><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2></li></ul><ol><li><code>JavaScript</code> 常被描述为一种基于原型的语言 (prototype-based language),每个对象拥有一个原型对象，对象以其原型为模板创建新对象、并从原型继承方法和属性。而这个原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为<code>原型链 (prototype chain)</code>，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</li></ol><ol><li><p>特殊的<code>Object</code>和<code>Function</code></p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数对象都是由Function函数生成的,则</span><span class="hljs-built_in">Object</span>._proto_ === <span class="hljs-built_in">Function</span>.prototype<span class="hljs-comment">//特例</span><span class="hljs-built_in">Function</span>.__proto__ ===  <span class="hljs-built_in">Function</span>.prototypeƒ () &#123; [native code] &#125;</code></pre></div></li><li><p>原形链的终点</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.prototye === <span class="hljs-string">&#x27;object&#x27;</span><span class="hljs-comment">// 说明他是一个object类型的对象，如果他是由Object函数生成的，</span><span class="hljs-comment">// 为了让原型链有终点。Javascript规定，</span><span class="hljs-built_in">Object</span>.prototype.__proto__ === <span class="hljs-literal">null</span><span class="hljs-comment">// 对于Function</span><span class="hljs-built_in">Function</span>.prototype.__proto__ === <span class="hljs-built_in">Object</span>.prototype<span class="hljs-built_in">Object</span>.prototype.__proto__ === <span class="hljs-literal">null</span></code></pre></div></li><li><p>只有函数才有<code>prototype</code></p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;&#125;f1.__proto__ === <span class="hljs-built_in">Function</span>.prototype <span class="hljs-comment">// f1直接由Function构造而来</span></code></pre></div></li><li><p>在传统的’面向对象‘中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到新实例中。在 JavaScript 中并不如此复制，而是在对象实例和它的构造器之间建立一个链接（它是__proto__属性，是从构造函数的prototype属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。</p></li></ol><div class="hljs code-wrapper"><pre><code>![proto](../images/proto.png)</code></pre></div><ul><li><p>当 js 在查找某属性时，对象本体上没有该属性则会访问对象的<code>__proto__</code>进行查找(即在该函数构造函数的<code>prototype</code>中查找)，还是没有则继续递归访问<code>__proto__</code>,一直到<code>Object</code>，【【【<code>Object.prototype</code>没有<code>__proto__</code>属性】】】，继续访问则返回<code>null</code>,这样一条由<code>__proto__</code>把所有对象链接起来的线成为原型链</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Function</span>.prototype)ƒ () &#123; [native code] &#125;<span class="hljs-built_in">console</span>.log(f1.__proto__)ƒ () &#123; [native code] &#125;<span class="hljs-comment">//    !!!!!!!!!</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Function</span>.prototype.__proto__ == f1.__proto__.__proto__)<span class="hljs-literal">true</span><span class="hljs-comment">// 实例继承自构造函数</span><span class="hljs-comment">// 函数继承自Function对象</span><span class="hljs-comment">// Function继承自Object对象</span><span class="hljs-comment">// 非函数对象</span><span class="hljs-keyword">const</span> o1 = &#123;&#125;o1.__proto__<span class="hljs-comment">// &#123;constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …&#125;</span>o1.__proto__ === <span class="hljs-built_in">Object</span>.prototype<span class="hljs-comment">// true</span>o1.__proto__.__proto__ = <span class="hljs-literal">null</span></code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议</title>
    <link href="/2019/04/14/http%E5%8D%8F%E8%AE%AE/"/>
    <url>/2019/04/14/http%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP（HyperText-Transfer-Protocol，超文本传输协议"><a href="#HTTP（HyperText-Transfer-Protocol，超文本传输协议" class="headerlink" title="HTTP（HyperText Transfer Protocol，超文本传输协议"></a>HTTP（HyperText Transfer Protocol，超文本传输协议</h2><blockquote><p>HTTP 是基于 TCP/IP 协议的应用层协议，用于客户端和服务器之间的通信<br>链路层，网络层，传输层，应用层</p></blockquote><h3 id="HTTP-报文组成部分"><a href="#HTTP-报文组成部分" class="headerlink" title="HTTP 报文组成部分"></a>HTTP 报文组成部分</h3><ul><li><p>请求报文</p><ul><li>请求行 <code>Request Method</code>,<code>Request URI</code>,<code>Request Version</code></li><li>请求头 包含若干属性，key:value 值</li><li>空行</li><li>请求体</li></ul></li><li><p>响应报文</p><ul><li>状态行 <code>Request Version</code>,<code>Status Code及其描述</code></li><li>响应头 包含若干属性，key:value 值</li><li>空行</li><li>响应体</li></ul></li></ul><h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><ul><li><p>缓存相关</p><ul><li><code>Cache-Control</code></li><li><code>Pragma</code></li><li><code>Expires</code>实体首部</li><li><code>Last-Modified</code>实体首部</li><li><code>If-Modified-Since</code></li><li><code>ETag</code></li><li><code>If-None-Match</code></li></ul></li><li><p>Cookie</p><ul><li><code>Cookie</code></li><li><code>Set-Cookie</code></li></ul></li><li><p>跨域</p><ul><li><code>Origin</code></li><li><code>Access-Control-Request-Method</code></li><li><code>Access-Control-Allow-Origin</code></li><li><code>Access-Control-Allow-Methods</code></li><li><code>Access-Control-Max-Age</code></li><li><code>Access-Control-Allow-Credentials</code></li></ul></li><li><p>连接</p><ul><li><code>Connection</code>:keep-alive / close / upgrade</li><li><code>Referer</code>请求发起URL</li><li><code>Host</code>服务器域名</li><li><code>Upgrade</code>:websocket<h4 id="HTTP-的响应状态码"><a href="#HTTP-的响应状态码" class="headerlink" title="HTTP 的响应状态码"></a>HTTP 的响应状态码</h4></li></ul></li></ul><p><code>1xx 请求收到</code>,</p><p><code>2xx 处理成功</code>,</p><p><code>3xx 重定向</code>,</p><p><code>4xx 处理发生错误，责任在客户端</code>,</p><p><code>5xx 处理发生错误，责任在服务端</code></p><h4 id="常见-code"><a href="#常见-code" class="headerlink" title="常见 code"></a>常见 code</h4><ul><li>100 继续发送</li><li>101 协议升级到请求中upgrade定义的协议</li><li>200 OK</li><li>206 完成了带 Range 的 GET 请求</li><li>301 永久性重定向，资源已经分配了新的 URl</li><li>302 临时重定向</li><li>303 表示资源存在着另一个 URL，应使用 GET 方法获取资源（对于 301/302/303 响应，几乎所有浏览器都会删除报文主体并自动用 GET 重新请求）</li><li>304 继续使用本地的缓存资源，</li><li>400 Bad Request请求报文语法错误</li><li>401 Unauthorized需要有通过 HTTP 认证的认证信息</li><li>403 Forbidden禁止访问</li><li>404 Not Found</li><li>405 请求方法不能被用于请求相关资源</li><li>408 请求超时</li><li>500 Internal Server Error</li><li>502 bad gateway从上游服务器接受到无效响应</li><li>503 Server Unavailable请求未完成，服务器临时过载</li></ul><h2 id="HTTP-发展"><a href="#HTTP-发展" class="headerlink" title="HTTP 发展"></a>HTTP 发展</h2><h3 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h3><ul><li><p>串行连接：每次通信完后断开TCP通道，每个新请求都需要建立新的连接</p></li><li><p><code>GET</code></p><ol><li>请求放在参数放在URL地址后</li><li>刷新无副作用</li><li>能保存书签，会被浏览器缓存，加入历史记录</li><li>编码urlencoded</li><li>参数数据类型限制为ASCII字符，浏览器或者服务器会对参数长度做限制</li></ol></li><li><p><code>POST</code></p><ol><li>请求参数放在body中</li><li>刷新提示再次提交？</li><li>不缓存不保存不记录</li><li>编码form-data，数据类型无限制</li></ol></li><li><p><code>HEAD</code> 与 get 相同的请求，不过只请求头部，获取其中“关于该资源的信息”(元信息或称元数据)</p><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3></li><li><p>持久连接：一定时间内，只要不是主动断开则保持连接，但是下一个请求必须等待上一个请求响应完成（线头阻塞）</p></li><li><p>管线化持久连接：请求/响应 打包处理，可以不用等待响应返回而发送下个请求并+按顺序返回响应+,只能用于GET和HEAD请求</p></li><li><p><code>OPTIONS</code>询问获取当前资源所支持的方法</p></li><li><p><code>PUT</code>从客户端向服务器传送新文件</p></li><li><p><code>PATCH</code>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</p></li><li><p><code>DELETE</code>请求服务器删除指定文件</p></li><li><p><code>TRACE</code>回显服务器收到的请求，主要用于测试或诊断。</p></li><li><p><code>CONNECT</code> HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</p></li></ul><h3 id="SPDY-协议"><a href="#SPDY-协议" class="headerlink" title="SPDY 协议"></a>SPDY 协议</h3><ul><li>2009 年推出</li></ul><blockquote><p>特性：</p></blockquote><ol><li><p>多路复用：通过一个 TCP 连接，可以无限制处理多个 HTTP 请求。</p></li><li><p>赋予请求优先级：给请求逐个分配优先级顺序。可以解决在发送多个请求时，因带宽低而导致响应变慢的问题。</p></li><li><p>压缩 HTTP 首部：压缩方式：DELEFT</p></li><li><p>服务端推送功能</p></li><li><p>服务器提示功能：服务器可以主动提示客户端请求所需的资源。</p></li><li><p>SPDY 位于 HTTP 下，TCP 和 SSL 之上，可以兼容老版本 http 同时使用可用的 ssl 功能</p></li></ol><blockquote><p>缺点：</p></blockquote><p>SPDY 强制使用 https。而且 SPDY 基本上只是将单个域名下的通信多路复用，所以当一个 web 网站上使用多个域名下的资源时，改善效果有限</p><h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><ul><li><p>2015 年发布，基于 SPDY 协议</p></li><li><p>http/1.x 是一个超文本协议，而 http2 是一个二进制协议</p></li></ul><blockquote><p>特性：</p></blockquote><ol><li><p>二进制格式传输数据</p><ul><li><p>1.X使用的文本格式传输数据</p></li><li><p>当客户端同时向服务端发起多个请求，那么这些请求会被分解成一一个的帧，每个帧都会在一个 TCP 链路中无序的传输，同一个请求的帧的 Stream Identifier 都是一样的。当帧到达服务端之后，就可以根据 Stream Identifier 来重新组合得到完整的请求。</p></li></ul></li><li><p>头部压缩</p><ul><li>请求和响应首部压缩</li><li>HPACK 算法，客户端和服务器建立字典（首部表）重复头部不用再发送</li></ul></li><li><p>服务端推送</p></li><li><p>多路复用</p><ul><li>同域名的通信都在单个连接上完成(只占用一个 tcp 连接</li><li>单连接可以承受任意数量的双向数据流</li></ul></li></ol><h3 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h3><ul><li>http3使用新的UDP协议<code>QUIC</code>代替TCP</li><li>解决http2时代丢包阻塞</li><li>切换网络时的连接保持（快速重启会话）</li><li>加密传输</li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS 是运行在 SSL/TLS 上的 HTTP，HTTPS 先和 SSL/TLS 通信，再由 SSL/TLS 与 TCP 通信</p><p>HTTPS 的主要功能都由 SSL/TLS 提供，包括</p><ul><li>非对称加密+对称加密</li></ul><p>发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信</p><ul><li>校验数字签名（数字证书</li></ul><p>向 CA 申请得到合法证书（证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文<br>）并得到由 CA 私钥加密的<code>签名</code>-&gt;客户端请求时服务器返回证书-&gt;客户端读取证书，使用对应的 CA 密钥解密<code>签名</code>，对比证书的信息摘要，一致则说明合法。</p><p>同时客户端还会验证证书的域名信息，有效时间，是不是受信任的证书颁发机构。</p><h3 id="HTTPS-工作流程"><a href="#HTTPS-工作流程" class="headerlink" title="HTTPS 工作流程"></a>HTTPS 工作流程</h3><ol><li>开通https的服务器将 <em><strong>服务器公钥</strong></em> 发送给CA机构</li><li>CA生成与这服务器对应的 <em><strong>CA公私钥</strong></em> <ul><li> <em><strong>CA公钥</strong></em> 下发至用户浏览器</li><li>使用 <em><strong>CA私钥</strong></em> 对 <em><strong>服务器公钥</strong></em> 签名生成证书</li></ul></li><li>用户访问:443</li><li>服务器返回证书</li><li>用户浏览器使用 <em><strong>CA公钥</strong></em> 打开并验证证书的合法性，(比如是否在有效期内，证书的用途是不是匹配 Client 的站点，是不是在 CRL 吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根（操作系统内置的 Root 证书或者 Client 内置的 Root 证书）。如果验证通过则继续，不通过则显示信息。<br>)得到证书中的 <em><strong>服务器公钥</strong></em></li><li>用户生成 <em><strong>客户端私钥</strong></em>，并使用 <em><strong>服务器公钥</strong></em> 加密发送给服务器</li><li>服务器使用自己的 <em><strong>服务器私钥</strong></em> 解密，得到 <em><strong>客户端私钥</strong></em></li><li>至此双方得到了对称加密密钥</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM事件</title>
    <link href="/2019/04/14/DOM%E4%BA%8B%E4%BB%B6/"/>
    <url>/2019/04/14/DOM%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="document-object-model"><a href="#document-object-model" class="headerlink" title="document object model"></a>document object model</h2><p>DOM（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML文档交互的API。DOM 是载入到浏览器中的文档模型，以节点树的形式来表现文档，每个节点代表文档的构成部分（例如:页面元素、字符串或注释等等）。</p><p>DOM 是万维网上使用最为广泛的API之一，因为它允许运行在浏览器中的代码访问文件中的节点并与之交互。节点可以被创建，移动或修改。事件监听器可以被添加到节点上并在给定事件发生时触发。</p><h3 id="DOM的级别"><a href="#DOM的级别" class="headerlink" title="DOM的级别"></a>DOM的级别</h3><ul><li>DOM0</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 其实并没有这个级别，便于区分，浏览器刚开始引入js的时期</span><span class="hljs-comment">// example</span>element.onclick()</code></pre></div><ul><li>DOM1</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 该标准指定时没有涉及事件相关,主要映射文档结构</span></code></pre></div><ul><li>DOM2</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 在DOM1的基础上增加了视图、事件、样式、遍历和范围的接口，和支持XML命名空间</span><span class="hljs-comment">// example</span>element.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,<span class="hljs-literal">false</span>)</code></pre></div><ul><li>DOM3</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">element.addEventListener(<span class="hljs-string">&#x27;keyup&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,<span class="hljs-literal">false</span>)<span class="hljs-comment">// UI事件，当用户与页面上的元素交互时触发，如：load、scroll</span><span class="hljs-comment">// 焦点事件，当元素获得或失去焦点时触发，如：blur、focus</span><span class="hljs-comment">// 鼠标事件，当用户通过鼠标在页面执行操作时触发如：dblclick、mouseup</span><span class="hljs-comment">// 滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</span><span class="hljs-comment">// 文本事件，当在文档中输入文本时触发，如：textInput</span><span class="hljs-comment">// 键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</span><span class="hljs-comment">// 合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart</span><span class="hljs-comment">// 变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified</span><span class="hljs-comment">// 同时DOM3级事件也允许使用者自定义一些事件。</span></code></pre></div><h3 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h3><ul><li>捕获</li><li>冒泡</li><li>事件委托</li></ul><h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><ul><li>捕获阶段<blockquote><p>事件从Document节点自上而下向目标节点传播的阶段</p></blockquote></li><li>目标阶段<blockquote><p>事件通过捕获到达目标元素，真正的目标节点正在处理事件的阶段</p></blockquote></li><li>冒泡阶段<blockquote><p>事件从目标元素冒泡，事件从目标节点自下而上向Document节点传播的阶段</p></blockquote></li></ul><h3 id="描述DOM事件捕获的具体流程"><a href="#描述DOM事件捕获的具体流程" class="headerlink" title="描述DOM事件捕获的具体流程"></a>描述DOM事件捕获的具体流程</h3><p><code>window --&gt; document --&gt; html(*) --&gt; body --&gt; ...--&gt; 目标元素</code></p><blockquote><p>*js中使用<code>document.documentElement</code>获取html的根（root）节点<code>&lt;html&gt;</code></p></blockquote><h3 id="Event对象的常见使用"><a href="#Event对象的常见使用" class="headerlink" title="Event对象的常见使用"></a>Event对象的常见使用</h3><ul><li><code>e.clientX/e.clientY</code>可视区域内的窗口坐标（方向参考left和top）</li><li><code>e.ScreenX/e.ScreenY</code>相对于屏幕的坐标</li><li><code>event.button</code>识别鼠标点击左中右键</li><li><code>event.keycode</code>键盘事件</li><li><code>event.</code>鼠标事件</li><li><code>event.preventDefault()</code>阻止默认行为</li><li><code>event.stopPropagation()</code>阻止冒泡</li><li><code>event.stopImmediatePropagation()</code>考虑事件响应优先级时,该函数用于阻止剩余的事件处理函数的执行，并防止当前事件在DOM树上冒泡。</li><li><code>event.currentTarget()</code>是绑定监听事件的对象</li><li><code>event.target()</code>触发事件的当前元素（早期ie中的source）</li><li><code>e.currentTarget</code>是绑定监听事件的对象</li></ul><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><ul><li>定义一个自定义事件<code>var eve = new Event(&#39;Ename&#39;)</code></li><li>绑定<code>ev.addEventListener(&#39;Ename&#39;,fn)</code></li><li>自定义触发事件<code>ev.dispathEvent(eve)</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> CustomEvent(typeArg, customEventInit&#123;       <span class="hljs-string">`bubbles`</span>, <span class="hljs-comment">// 事件是否支持冒泡</span>       <span class="hljs-string">`cancelable`</span>, <span class="hljs-comment">// 是否可取消事件的默认行为</span>       <span class="hljs-string">`composed`</span>, <span class="hljs-comment">// 事件是否会触发shadow DOM（阴影DOM）根节点之外的事件监听器</span>       <span class="hljs-string">`detail`</span>  &#125;);-  typeArg：指定事件类型，传递一个字符串。- customEventInit：可以接受EventInit字典的参数（bubbles等）和detail</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// Example</span><span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">&#x27;msg&#x27;</span>, &#123;  detail: <span class="hljs-string">&#x27;this is detail in CustomEvent&#x27;</span>&#125;)<span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.bodyelement.addEventListener(<span class="hljs-string">&#x27;msg&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(e.detail);&#125;, <span class="hljs-literal">false</span>)element.dispatchEvent(event)<span class="hljs-comment">//this is detail in CustomEvent</span></code></pre></div><h3 id="事件委托-事件代理"><a href="#事件委托-事件代理" class="headerlink" title="事件委托/事件代理"></a>事件委托/事件代理</h3><p>由于事件会在<em>冒泡</em>阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理。</p><ul><li><p><strong>提高性能</strong>:每一个函数都会占用内存空间，只需添加一个事件处理程序代理所有事件,所占用的内存空间更少。</p></li><li><p><strong>动态监听</strong>:使用事件委托可以自动绑定动态添加的元素,即新增的节点不需要主动添加也可以一样具有和其他元素一样的事件。</p></li></ul><h3 id="addEventListener和on"><a href="#addEventListener和on" class="headerlink" title="addEventListener和on"></a><code>addEventListener</code>和<code>on</code></h3><ul><li><p>add支持为同一个DOM元素注册多个同类型事件,on后注册的事件会覆盖前注册的</p></li><li><p>add可设置事件捕获或者冒泡</p></li><li><p>add可以使用事件委托</p></li><li><p>addEventListener监听的移除<code>removeEventListener()</code></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
      <tag>dom</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
